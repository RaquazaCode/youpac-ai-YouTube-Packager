Directory structure:
‚îî‚îÄ‚îÄ michaelshimeles-youpac-ai/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ components.json
    ‚îú‚îÄ‚îÄ Dockerfile
    ‚îú‚îÄ‚îÄ DONE.md
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ r2-cors-config.json
    ‚îú‚îÄ‚îÄ react-router.config.ts
    ‚îú‚îÄ‚îÄ TASKS.md
    ‚îú‚îÄ‚îÄ tsconfig.json
    ‚îú‚îÄ‚îÄ vite.config.ts
    ‚îú‚îÄ‚îÄ .dockerignore
    ‚îú‚îÄ‚îÄ .env.example
    ‚îú‚îÄ‚îÄ app/
    ‚îÇ   ‚îú‚îÄ‚îÄ app.css
    ‚îÇ   ‚îú‚îÄ‚îÄ root.tsx
    ‚îÇ   ‚îú‚îÄ‚îÄ routes.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ components/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ClientOnly.tsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ErrorBoundary.tsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logo.tsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ VideoProcessingHelp.tsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ canvas/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AgentNode.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Canvas.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CanvasWrapper.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ClientCanvas.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ContentModal.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DeleteConfirmationDialog.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FloatingChat.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MentionAutocomplete.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PromptModal.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ReactFlowComponents.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ReactFlowWrapper.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SharedCanvas.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ThumbnailUploadModal.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ VideoNode.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ VideoPlayerModal.tsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app-sidebar.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chart-area-interactive.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ nav-main.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ nav-secondary.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ nav-user.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ section-cards.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ site-header.tsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ homepage/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ content.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ footer.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hero.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ navbar.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ team.tsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logos/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ClerkIcon.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Convex.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OpenAI.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Polar.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ReactIcon.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ReactRouter.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TailwindIcon.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Typescript.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ YouTube.tsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ preview/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PreviewModal.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TwitterThreadPreview.tsx
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ YouTubePreview.tsx
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ui/
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ alert-dialog.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ avatar.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ badge.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ button.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ card.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ chart.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ checkbox.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ dialog.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ dropdown-menu.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ form.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ hero-designali.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ input.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ label.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ progress.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ scroll-area.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ select.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ separator.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ sheet.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ sidebar.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ skeleton.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ table.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ tabs.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ textarea.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ toggle-group.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ toggle.tsx
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ tooltip.tsx
    ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ use-mobile.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ lib/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ audio-compression.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ffmpeg-audio.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ thumbnail-generator.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ video-error-handler.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ video-frames.ts
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ video-metadata.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ routes/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ $.tsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ home.tsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ share.$shareId.tsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sign-in.tsx
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sign-up.tsx
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dashboard/
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ chat.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ index.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ layout.tsx
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ project.$projectId.tsx
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ settings.tsx
    ‚îÇ   ‚îî‚îÄ‚îÄ styles/
    ‚îÇ       ‚îî‚îÄ‚îÄ reactflow.css
    ‚îú‚îÄ‚îÄ convex/
    ‚îÇ   ‚îú‚îÄ‚îÄ README.md
    ‚îÇ   ‚îú‚îÄ‚îÄ agents.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ ai.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ aiHackathon.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ auth.config.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ canvas.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ chat.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ convex.config.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ files.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ http.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ profiles.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ projects.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ schema.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ shares.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ thumbnail.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ thumbnailGPTImage.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ thumbnailRefine.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ transcription.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json
    ‚îÇ   ‚îú‚îÄ‚îÄ users.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ videoJobs.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ videos.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ _generated/
    ‚îÇ       ‚îú‚îÄ‚îÄ api.d.ts
    ‚îÇ       ‚îú‚îÄ‚îÄ api.js
    ‚îÇ       ‚îú‚îÄ‚îÄ dataModel.d.ts
    ‚îÇ       ‚îú‚îÄ‚îÄ server.d.ts
    ‚îÇ       ‚îî‚îÄ‚îÄ server.js
    ‚îî‚îÄ‚îÄ .vercel/
        ‚îî‚îÄ‚îÄ react-router-build-result.json

================================================
FILE: README.md
================================================
# YouPac AI - YouTube Content Creation Assistant

An AI-powered platform that helps YouTube creators generate compelling titles, descriptions, thumbnails, and social media posts from their video content. Built with React Router v7, Convex, and OpenAI.

## Features

### Core Functionality
- üé¨ **Video Upload & Processing** - Upload videos up to 1GB with automatic transcription
- ü§ñ **AI Content Generation** - Generate titles, descriptions, thumbnails, and tweets
- üé® **Visual Canvas Interface** - Drag-and-drop nodes for content workflow
- üí¨ **Smart Chat Integration** - Chat with AI agents to refine content
- üëÅÔ∏è **Content Preview** - See how content looks on YouTube and Twitter/X
- üîó **Share System** - Share read-only canvas views with collaborators

### AI Agents
- üìù **Title Agent** - Creates catchy, SEO-optimized video titles
- üìÑ **Description Agent** - Writes comprehensive video descriptions
- üñºÔ∏è **Thumbnail Agent** - Generates thumbnail concepts and images with DALL-E 3
- üê¶ **Social Media Agent** - Creates Twitter/X threads for video promotion

### Technical Features
- üöÄ **React Router v7** - Modern full-stack React framework
- ‚ö°Ô∏è **Real-time Updates** - Live canvas synchronization with Convex
- üîí **TypeScript** - Full type safety throughout the codebase
- üé® **Beautiful UI** - Modern design with Tailwind CSS and shadcn/ui
- üîê **Authentication** - Secure user management with Clerk
- üì± **Responsive Design** - Works seamlessly on all devices
- üö¢ **Vercel Ready** - Optimized for one-click deployment

## Tech Stack

### Frontend
- **React Router v7** - Full-stack React framework with SSR
- **React Flow** - Interactive canvas for visual workflows
- **TailwindCSS v4** - Utility-first CSS framework
- **shadcn/ui** - Modern component library with Radix UI
- **Lucide React** - Beautiful icon library
- **Sonner** - Toast notifications

### Backend & Services
- **Convex** - Real-time database and serverless functions
- **Clerk** - Authentication and user management
- **OpenAI** - GPT-4 for content generation, DALL-E 3 for thumbnails
- **ElevenLabs** - Advanced speech-to-text transcription
- **FFmpeg** - Video processing and audio extraction

### Development & Deployment
- **Vite** - Lightning-fast build tool
- **TypeScript** - End-to-end type safety
- **Vercel** - Deployment platform

## Getting Started

### Prerequisites

- Node.js 18+ 
- Clerk account for authentication
- Convex account for database
- OpenAI API key for content generation
- ElevenLabs API key for transcription

### Installation

1. Clone the repository and install dependencies:

```bash
npm install
```

2. Copy the environment file and configure your credentials:

```bash
cp .env.example .env.local
```

3. Set up your environment variables in `.env.local`:

```bash
# Convex Configuration
CONVEX_DEPLOYMENT=your_convex_deployment_here
VITE_CONVEX_URL=your_convex_url_here

# Clerk Authentication
VITE_CLERK_PUBLISHABLE_KEY=your_clerk_publishable_key_here
CLERK_SECRET_KEY=your_clerk_secret_key_here

# OpenAI Configuration
OPENAI_API_KEY=your_openai_api_key_here

# ElevenLabs Configuration
ELEVENLABS_API_KEY=your_elevenlabs_api_key_here

# Frontend URL
FRONTEND_URL=http://localhost:5173
```

4. Initialize Convex:

```bash
npx convex dev
```

5. Set up environment variables in Convex dashboard:
   - `OPENAI_API_KEY`
   - `ELEVENLABS_API_KEY`

### Development

Start the development server with HMR:

```bash
npm run dev
```

Your application will be available at `http://localhost:5173`.

## Building for Production

Create a production build:

```bash
npm run build
```

## Deployment

### Vercel Deployment (Recommended)

This starter kit is optimized for Vercel deployment with the `@vercel/react-router` preset:

1. Connect your repository to Vercel
2. Set environment variables in Vercel dashboard
3. Deploy automatically on push to main branch

The `react-router.config.ts` includes the Vercel preset for seamless deployment.

### Docker Deployment

To build and run using Docker:

```bash
docker build -t my-app .

# Run the container
docker run -p 3000:3000 my-app
```

The containerized application can be deployed to any platform that supports Docker:

- AWS ECS
- Google Cloud Run
- Azure Container Apps
- Digital Ocean App Platform
- Fly.io
- Railway

### DIY Deployment

If you're familiar with deploying Node applications, the built-in app server is production-ready.

Make sure to deploy the output of `npm run build`

```
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ build/
‚îÇ   ‚îú‚îÄ‚îÄ client/    # Static assets
‚îÇ   ‚îî‚îÄ‚îÄ server/    # Server-side code
```

## How It Works

### 1. Upload Video
- Upload any video file (up to 1GB)
- Automatic transcription using ElevenLabs
- Extract video metadata (duration, resolution, etc.)

### 2. Generate Content
- AI agents analyze your video and transcription
- Generate optimized titles, descriptions, thumbnails, and social posts
- Each agent can be regenerated individually

### 3. Refine with Chat
- Use @mentions to chat with specific agents
- Request changes or regenerate content
- AI understands context from your video

### 4. Preview & Export
- Preview how content looks on YouTube and Twitter/X
- Copy content to clipboard
- Export as markdown files
- Share canvas with collaborators

## Architecture

### Key Routes
- `/` - Homepage with features overview
- `/sign-in` & `/sign-up` - Authentication pages
- `/dashboard` - Projects dashboard
- `/dashboard/settings` - Profile configuration
- `/canvas/:projectId` - Interactive content canvas
- `/share/:shareId` - Read-only shared canvas

### Key Features

#### Canvas System
- Visual workflow with draggable nodes
- Real-time collaboration support
- Auto-save every 5 seconds
- Connection validation between nodes

#### AI Content Generation
- Context-aware generation using video transcription
- Profile-based personalization
- Batch generation with "Generate All"
- Individual regeneration per agent

#### Profile System
- Channel information for personalized content
- Tone and style preferences
- Target audience configuration
- Progress tracking

## Environment Variables

### Required for Production

#### Application Variables
- `VITE_CONVEX_URL` - Your Convex client URL
- `VITE_CLERK_PUBLISHABLE_KEY` - Clerk publishable key
- `CLERK_SECRET_KEY` - Clerk secret key for server-side auth
- `FRONTEND_URL` - Your production frontend URL

#### Convex Environment Variables (set in Convex dashboard)
- `OPENAI_API_KEY` - OpenAI API key for GPT-4 and DALL-E 3
- `ELEVENLABS_API_KEY` - ElevenLabs API key for transcription

## Project Structure

```
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ components/         
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/           # shadcn/ui components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ canvas/       # Canvas and node components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ homepage/     # Landing page sections
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard/    # Dashboard layout components
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ preview/      # YouTube/Twitter preview components
‚îÇ   ‚îú‚îÄ‚îÄ routes/           # React Router routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard/    # Protected dashboard routes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ canvas/       # Canvas route and share
‚îÇ   ‚îú‚îÄ‚îÄ lib/              # Utility functions
‚îÇ   ‚îî‚îÄ‚îÄ styles/           # Global styles
‚îú‚îÄ‚îÄ convex/               # Backend functions
‚îÇ   ‚îú‚îÄ‚îÄ schema.ts         # Database schema
‚îÇ   ‚îú‚îÄ‚îÄ videos.ts         # Video operations
‚îÇ   ‚îú‚îÄ‚îÄ agents.ts         # AI agent functions
‚îÇ   ‚îú‚îÄ‚îÄ projects.ts       # Project management
‚îÇ   ‚îî‚îÄ‚îÄ aiHackathon.ts    # AI generation logic
‚îú‚îÄ‚îÄ public/               # Static assets
‚îî‚îÄ‚îÄ docs/                 # Documentation
```

## Key Dependencies

- `react` & `react-dom` v19 - Latest React
- `react-router` v7 - Full-stack React framework
- `@clerk/react-router` - Authentication
- `convex` - Real-time database
- `@xyflow/react` - Interactive canvas (React Flow)
- `openai` - GPT-4 and DALL-E 3 integration
- `@vercel/react-router` - Vercel deployment
- `tailwindcss` v4 - Styling
- `@radix-ui/*` - UI primitives
- `sonner` - Toast notifications
- `ffmpeg-wasm` - Client-side video processing

## Scripts

- `npm run dev` - Start development server with Convex
- `npm run build` - Build for production
- `npm run start` - Start production server
- `npm run typecheck` - Run TypeScript checks

## Screenshots

### Dashboard
Projects dashboard with grid view and quick actions.

### Canvas
Interactive visual workflow for content generation.

### Content Preview
See how your content looks on YouTube and Twitter/X.

## Roadmap

- [ ] YouTube URL import support
- [ ] Batch export functionality
- [ ] Team collaboration features
- [ ] Analytics integration
- [ ] More social media platforms
- [ ] Custom AI prompts
- [ ] Video trimming tools

## Contributing

We welcome contributions! Please:

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the LICENSE file for details.

---

**Transform your YouTube content creation workflow with AI.** YouPac AI helps creators save hours by automatically generating optimized titles, descriptions, thumbnails, and social media posts from their video content.

Built with ‚ù§Ô∏è using React Router v7, Convex, OpenAI, and ElevenLabs.


================================================
FILE: components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/app.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "~/components",
    "utils": "~/lib/utils",
    "ui": "~/components/ui",
    "lib": "~/lib",
    "hooks": "~/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: Dockerfile
================================================
FROM node:20-alpine AS development-dependencies-env
COPY . /app
WORKDIR /app
RUN npm ci

FROM node:20-alpine AS production-dependencies-env
COPY ./package.json package-lock.json /app/
WORKDIR /app
RUN npm ci --omit=dev

FROM node:20-alpine AS build-env
COPY . /app/
COPY --from=development-dependencies-env /app/node_modules /app/node_modules
WORKDIR /app
RUN npm run build

FROM node:20-alpine
COPY ./package.json package-lock.json /app/
COPY --from=production-dependencies-env /app/node_modules /app/node_modules
COPY --from=build-env /app/build /app/build
WORKDIR /app
CMD ["npm", "run", "start"]


================================================
FILE: DONE.md
================================================
# ‚úÖ DONE - YouTube AI Assistant Completed Features

## Core Features ‚úì
- [x] Project-based architecture (one project = one video)
- [x] Projects dashboard with grid view
- [x] Canvas with drag-and-drop nodes
- [x] Real video upload to storage
- [x] Video playback in canvas
- [x] AI content generation for all agents
- [x] Profile system for personalized content
- [x] Auto-save canvas every 5 seconds
- [x] Node connections with validation
- [x] "Generate All" batch content creation
- [x] Content viewing/editing modal
- [x] Copy to clipboard

## Recent Updates ‚úì
- [x] Real video transcription using Whisper API
- [x] Audio extraction for videos >25MB (using FFmpeg)
- [x] Collapsible canvas sidebar with icons
- [x] Hamburger icon on draggable nodes
- [x] Video thumbnail generation (GPT-4 Vision + gpt-image-1)
- [x] Thumbnail image storage in Convex (permanent URLs)
- [x] Thumbnail refinement using existing image as base
- [x] Floating chat interface (always visible)
- [x] @mention system for agents
- [x] Chat autocomplete dropdown
- [x] Dashboard sidebar closed by default
- [x] Fixed all ESM module loading issues
- [x] Removed redundant toast notifications
- [x] Video preview on hover with play button
- [x] Video player modal on click
- [x] Video duration and file size display
- [x] Thumbnail upload modal (instead of frame extraction)

## Latest Fixes ‚úì
- [x] Fixed chat input flickering issue (removed two-way state binding)
- [x] Enable content regeneration from chat with context (@mention regenerate)
- [x] Fixed OpenAI safety errors (corrected model name to dall-e-3)
- [x] Fixed canvas position saving (re-enabled onNodeDragStop handler)
- [x] Changed from right-click to Cmd+U keyboard shortcut for upload
- [x] Fixed video info extraction (added timeout and HTML5 fallback)
- [x] Updated sidebar text to clarify video drag direction
- [x] Fixed SSR/hydration errors with React Flow
- [x] Fixed audio info display (hide zero/invalid values)
- [x] Fixed thumbnail generation validator (accept video metadata)
- [x] Fixed node deletion functionality
- [x] Replace browser dialog with shadcn dialog for deletions
- [x] Removed video info nodes from canvas
- [x] Fixed canvas zoom/viewport persistence issue
- [x] Redesigned agents sidebar with modern UI
- [x] Redesigned nodes and canvas with beautiful aesthetics

## New Features Added ‚úì
- [x] YouTube Preview Component - Realistic video player interface
- [x] Twitter Thread Preview Component - Authentic Twitter thread UI
- [x] Content Preview Sheet - Slides in from right with tabs
- [x] Export content as Markdown files
- [x] Copy content to clipboard from preview
- [x] Delete confirmation dialog using shadcn AlertDialog
- [x] Modern UI design for sidebar with gradients and animations
- [x] Beautiful node designs with glassmorphism effects
- [x] Styled canvas background with dot grid pattern

## Video Features ‚úì
- [x] Fix video preview on hover
- [x] Add video duration display
- [x] Add video metadata to agent context

## Canvas UX ‚úì
- [x] Add mini-map toggle button (Added toggle in sidebar)
- [x] Nodes sometimes overlap on creation (FIXED - Added collision detection)
- [x] Edge animations cause performance issues (FIXED - Added toggle & performance limits)
- [x] Canvas state sometimes doesn't save (FIXED)
- [x] SSR/hydration errors with React Flow (FIXED)
- [x] Node deletion not working (FIXED)
- [x] Canvas zoom randomly resetting (FIXED)

## Export & Sharing ‚úì
- [x] Export individual content as Markdown files
- [x] Copy individual content to clipboard
- [x] Share canvas link (read-only) - Complete share system with unique URLs
- [x] Share link copy to clipboard with visual feedback
- [x] Read-only canvas viewer with all node data
- [x] View count tracking for shared canvases
- [x] Proper data loading for shared views

## AI Improvements ‚úì
- [x] Regenerate single content button with chat context
- [x] Thumbnail refinement via chat (edit existing thumbnails)
- [x] Improved description generation (2-line viewer benefits)
- [x] Simplified tweet generation (2-tweet format with thumbnail)
- [x] Generation progress indicators for all agents
- [x] Support for multiple mention formats (@thumbnail, @Thumbnail Agent, etc)

## Quick Wins ‚úì
- [x] Show video file size in node
- [x] Fix chat input focus issues
- [x] Add video info node with metadata display
- [x] Add keyboard shortcut (Cmd+U) for upload
- [x] Content preview with realistic UI mockups
- [x] Quick export buttons in preview

## Fixed Issues ‚úì
- [x] Chat input flickering (FIXED)
- [x] Sidebar hydration mismatch (FIXED)
- [x] Video info extraction failing (FIXED with timeout/fallback)
- [x] Node deletion functionality (FIXED)
- [x] Canvas zoom persistence (FIXED)
- [x] Viewport randomly resetting (FIXED)

## UI/UX Improvements ‚úì
- [x] Modern sidebar design with gradient backgrounds
- [x] Color-coded agent nodes with unique icons
- [x] Glassmorphism effects on nodes
- [x] Animated hover states and transitions
- [x] Professional shadow effects
- [x] Improved typography hierarchy
- [x] Dot grid canvas background
- [x] Styled controls and minimap

## Share System Implementation ‚úì
- [x] Created shares table with proper indexes
- [x] Share link generation with unique 8-character IDs
- [x] Share button in both collapsed and expanded sidebar states
- [x] Copy to clipboard functionality with visual feedback
- [x] SharedCanvas component for read-only viewing
- [x] Share route with server-side data loading
- [x] View count tracking and display
- [x] Proper error handling for missing shares
- [x] All editing capabilities disabled in shared view
- [x] Clean UI with back button and view count display
- [x] Preview modal automatically opens on shared pages
- [x] Fixed SSR issues with React Flow imports
- [x] Share canvas link (read-only) - Complete implementation
- [x] Preview modal on shared pages - Auto-opens for better UX

## AI Improvements (Additional) ‚úì
- [x] Generation progress indicators for all agents

## Transcription Improvements ‚úì
- [x] ElevenLabs Speech-to-Text integration
- [x] Cloudflare R2 integration for ALL video files (up to 1GB!)
- [x] Direct upload to R2 (bypassing Convex storage entirely)
- [x] Fixed ElevenLabs implementation to use R2 URLs
- [x] Moved mutations out of Node.js action files (Convex deployment fix)
- [x] API key moved to environment variables for security
- [x] Clear user feedback with detailed progress updates
- [x] Comprehensive error handling with user-friendly messages
- [x] Removed OpenAI Whisper completely per user request
- [x] Added transcription progress tracking in UI
- [x] Fixed large file handling with R2 for files up to 1GB
- [x] R2 files preserved (not deleted after transcription)

## Recent Enhancements ‚úì
- [x] Beautiful Content Preview Sheet with gradients and animations
- [x] Enhanced ContentModal with YouTube/Twitter preview tabs
- [x] Fixed View Preview in share page (corrected prop names)
- [x] Stunning hero section with Apple-style design
- [x] Grid pattern backgrounds for depth
- [x] Animated gradient orbs and glassmorphism effects
- [x] Professional typography with gradient text
- [x] Improved tech stack showcase with hover effects
- [x] Client-side transcription with ElevenLabs via proxy
- [x] CORS fix for transcription proxy endpoint
- [x] Better error handling for "no speech detected"
- [x] Removed all R2 integration (Convex storage only)

## Progress Summary
- ‚úÖ Core Infrastructure (100%)
- ‚úÖ Project System (100%)
- ‚úÖ Canvas Functionality (100%)
- ‚úÖ AI Integration (100%)
- ‚úÖ Video Transcription (100%)
- ‚úÖ Thumbnail Generation (100%)
- ‚úÖ Chat Interface (100%)
- ‚úÖ Profile System (85%)
- ‚úÖ Canvas State Persistence (100%)
- ‚úÖ Video Metadata Extraction (100%)
- ‚úÖ UI/UX Design (100%)
- ‚úÖ Share System (100%)
- ‚úÖ Convex Deployment (100%)


================================================
FILE: package.json
================================================
{
  "name": "my-react-router-app",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "react-router build",
    "dev": "react-router dev",
    "start": "react-router-serve ./build/server/index.js",
    "typecheck": "react-router typegen && tsc"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.3.22",
    "@ai-sdk/react": "^1.2.12",
    "@aws-sdk/client-s3": "^3.832.0",
    "@aws-sdk/s3-presigned-post": "^3.832.0",
    "@aws-sdk/s3-request-presigner": "^3.832.0",
    "@clerk/react-router": "^1.4.8",
    "@convex-dev/polar": "^0.4.5",
    "@elevenlabs/elevenlabs-js": "^2.3.0",
    "@ffmpeg/ffmpeg": "^0.12.15",
    "@ffmpeg/util": "^0.12.2",
    "@hookform/resolvers": "^5.1.1",
    "@polar-sh/sdk": "^0.32.16",
    "@radix-ui/react-alert-dialog": "^1.1.14",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.2",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-toggle": "^1.1.9",
    "@radix-ui/react-toggle-group": "^1.1.10",
    "@radix-ui/react-tooltip": "^1.2.7",
    "@react-router/node": "^7.5.3",
    "@react-router/serve": "^7.5.3",
    "@tabler/icons-react": "^3.33.0",
    "@tanstack/react-table": "^8.21.3",
    "@vercel/analytics": "^1.5.0",
    "@vercel/react-router": "^1.1.2",
    "@xyflow/react": "^12.7.0",
    "ai": "^4.3.16",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "convex": "^1.24.3",
    "d3-drag": "^3.0.0",
    "date-fns": "^4.1.0",
    "framer-motion": "^12.18.1",
    "isbot": "^5.1.27",
    "lucide-react": "^0.511.0",
    "motion": "^12.15.0",
    "next-themes": "^0.4.6",
    "node-fetch": "^3.3.2",
    "openai": "^5.6.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-hook-form": "^7.58.1",
    "react-markdown": "^10.1.0",
    "react-router": "^7.5.3",
    "react-typed": "^2.0.12",
    "recharts": "^2.15.3",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.3.0",
    "vaul": "^1.1.2",
    "zod": "^3.25.67"
  },
  "devDependencies": {
    "@react-router/dev": "^7.5.3",
    "@tailwindcss/vite": "^4.1.4",
    "@types/node": "^20",
    "@types/react": "^19.1.2",
    "@types/react-dom": "^19.1.2",
    "tailwindcss": "^4.1.4",
    "tw-animate-css": "^1.3.2",
    "typescript": "^5.8.3",
    "vite": "^6.3.3",
    "vite-tsconfig-paths": "^5.1.4"
  }
}



================================================
FILE: r2-cors-config.json
================================================
{
  "CORSRules": [
    {
      "AllowedOrigins": [
        "http://localhost:5173",
        "http://localhost:5174",
        "http://localhost:3000",
        "https://your-production-domain.com"
      ],
      "AllowedMethods": [
        "GET",
        "PUT",
        "POST",
        "DELETE",
        "HEAD"
      ],
      "AllowedHeaders": [
        "*"
      ],
      "ExposeHeaders": [
        "ETag",
        "Content-Length",
        "Content-Type"
      ],
      "MaxAgeSeconds": 3600
    }
  ]
}


================================================
FILE: react-router.config.ts
================================================
import type { Config } from "@react-router/dev/config";
import { vercelPreset } from "@vercel/react-router/vite";

export default {
  // Config options...
  // Server-side render by default, to enable SPA mode set this to `false`
  ssr: true,
  presets: [vercelPreset()],
} satisfies Config;



================================================
FILE: TASKS.md
================================================
# üìù YouTube AI Assistant - To-Do List

## üéØ FOCUS: UX & FTUE (First Time User Experience)

### üî¥ IMMEDIATE - Smooth Onboarding
- [ ] Welcome tour/tutorial for first-time users
- [ ] Sample project with pre-filled content
- [ ] Interactive tooltips on hover
- [ ] "What's this?" help buttons
- [ ] Onboarding checklist sidebar
- [ ] Video walkthrough modal

### üü° QUICK WINS - Better User Feedback
- [ ] Loading skeletons instead of spinners
- [ ] Progress bars for all async operations
- [ ] Success animations (confetti, checkmarks)
- [ ] Better error messages with solutions
- [ ] Undo notifications with action buttons
- [ ] Empty states with helpful CTAs

### üü¢ POLISH - Delightful Interactions
- [ ] Smooth page transitions
- [ ] Micro-animations on interactions
- [ ] Drag preview for nodes
- [ ] Sound effects (optional)
- [ ] Keyboard shortcuts overlay (?)
- [ ] Command palette (Cmd+K)

## üöÄ Original High Priority Features

### Video Features üé¨
- [ ] Support YouTube URL input (not just file upload)
- [ ] Handle video processing errors more gracefully
- [ ] Add video trimming/clipping functionality
- [ ] Support for video subtitles/captions

### Export & Sharing üì§
- [ ] Direct publish to YouTube (API integration)

## üü° MEDIUM PRIORITY (Nice to Have)

### Profile Enhancements üë§
- [ ] Quick profile switcher in canvas
- [ ] Profile templates (Gaming, Tech, Vlog, etc)
- [ ] Import profile from YouTube channel
- [ ] Multiple profile support

### AI Improvements ü§ñ
- [ ] Content variations (generate 3 options)
- [ ] Custom prompts per agent
- [ ] Generation history with rollback
- [ ] Tone adjustment slider
- [ ] Language translation support

### Chat Features üí¨
- [ ] Chat history persistence
- [ ] Export chat as context
- [ ] Voice input for chat
- [ ] Suggested prompts/questions
- [ ] Multi-agent conversations

### Canvas Enhancements üé®
- [ ] Undo/Redo functionality
- [ ] Canvas templates
- [ ] Custom node colors
- [ ] Node grouping/folders
- [ ] Canvas zoom presets

## üü¢ LOW PRIORITY (Future Updates)

### Analytics & Insights üìä
- [ ] SEO score for titles/descriptions
- [ ] Trending keywords suggestions
- [ ] Competitor analysis
- [ ] Performance predictions

### Collaboration üë•
- [ ] Real-time collaboration
- [ ] Comments on nodes
- [ ] Version control
- [ ] Team workspaces

## üéØ QUICK WINS (< 1 hour each)

- [ ] Add loading progress for video upload
- [ ] Add "Clear All" button for content
- [ ] Add generation time estimate
- [ ] Show word count in content modal
- [ ] Add keyboard shortcuts guide
- [ ] Add dark/light theme toggle
- [ ] Export settings/preferences

## üí° Known Issues to Fix

1. **UX/FTUE Issues** üéØ NEW FOCUS
   - [ ] First-time users don't know where to start
   - [ ] No clear indication of what each agent does
   - [ ] Canvas feels empty before video upload
   - [ ] No sample content to explore
   - [ ] Settings page needs better organization

2. **Performance**
   - [ ] Canvas lag with many nodes
   - [ ] Memory usage with large videos

3. **UX Issues**
   - [ ] No visual feedback during long operations
   - [ ] Can't cancel generation in progress

4. **Thumbnail Issues**
   - [ ] Large image uploads may fail for refinement
   - [ ] Connection errors when uploading to OpenAI

## üìä UX/FTUE Prioritization (Easiest ‚Üí Hardest)

### üü¢ EASIEST UX WINS (15-30 mins each)
1. **Empty states with helpful CTAs**
2. **Interactive tooltips on hover**
3. **"What's this?" help buttons**
4. **Better error messages with solutions**
5. **Loading skeletons for projects grid**

### üü° MEDIUM UX (1-2 hours each)
1. **Welcome tour/tutorial overlay**
2. **Progress bars for all operations**
3. **Success animations (confetti)**
4. **Onboarding checklist sidebar**
5. **Command palette (Cmd+K)**
6. **Smooth page transitions**

### üî¥ HARDER UX (2-4 hours each)
1. **Sample project with pre-filled content**
2. **Video walkthrough modal**
3. **Undo notifications with actions**
4. **Drag preview for nodes**
5. **Interactive canvas tutorial**

### ‚ö´ Original Feature List (4+ hours each)
1. **Direct publish to YouTube**
2. **Support YouTube URL input**
3. **Video trimming/clipping**
4. **Content variations (3 options)**
5. **Profile templates**
6. **Real-time collaboration**


================================================
FILE: tsconfig.json
================================================
{
  "include": [
    "**/*",
    "**/.server/**/*",
    "**/.client/**/*",
    ".react-router/types/**/*"
  ],
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "types": ["node", "vite/client"],
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "jsx": "react-jsx",
    "rootDirs": [".", "./.react-router/types"],
    "baseUrl": ".",
    "paths": {
      "~/*": ["./app/*"]
    },
    "esModuleInterop": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "strict": true
  }
}



================================================
FILE: vite.config.ts
================================================
import { reactRouter } from "@react-router/dev/vite";
import tailwindcss from "@tailwindcss/vite";
import { defineConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";

export default defineConfig({
  plugins: [tailwindcss(), reactRouter(), tsconfigPaths()],
  ssr: {
    noExternal: ["@xyflow/react", "@xyflow/system"],
  },
  resolve: {
    alias: {
      "use-sync-external-store/shim/with-selector": "use-sync-external-store/shim/with-selector.js",
    },
  },
  optimizeDeps: {
    include: ["@xyflow/react", "@xyflow/system", "use-sync-external-store/shim/with-selector"],
  },
});



================================================
FILE: .dockerignore
================================================
.react-router
build
node_modules
README.md


================================================
FILE: .env.example
================================================
# Convex
CONVEX_DEPLOYMENT=

# Clerk Authentication
VITE_CLERK_PUBLISHABLE_KEY=
CLERK_SECRET_KEY=

# Frontend
FRONTEND_URL=http://localhost:5173




================================================
FILE: app/app.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
    --color-background: var(--background);
    --color-foreground: var(--foreground);
    --font-sans: var(--font-apple-system);
    --font-mono: var(--font-sf-mono);
    --color-sidebar-ring: var(--sidebar-ring);
    --color-sidebar-border: var(--sidebar-border);
    --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
    --color-sidebar-accent: var(--sidebar-accent);
    --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
    --color-sidebar-primary: var(--sidebar-primary);
    --color-sidebar-foreground: var(--sidebar-foreground);
    --color-sidebar: var(--sidebar);
    --color-chart-5: var(--chart-5);
    --color-chart-4: var(--chart-4);
    --color-chart-3: var(--chart-3);
    --color-chart-2: var(--chart-2);
    --color-chart-1: var(--chart-1);
    --color-ring: var(--ring);
    --color-input: var(--input);
    --color-border: var(--border);
    --color-destructive: var(--destructive);
    --color-accent-foreground: var(--accent-foreground);
    --color-accent: var(--accent);
    --color-muted-foreground: var(--muted-foreground);
    --color-muted: var(--muted);
    --color-secondary-foreground: var(--secondary-foreground);
    --color-secondary: var(--secondary);
    --color-primary-foreground: var(--primary-foreground);
    --color-primary: var(--primary);
    --color-popover-foreground: var(--popover-foreground);
    --color-popover: var(--popover);
    --color-card-foreground: var(--card-foreground);
    --color-card: var(--card);
    --radius-sm: 8px;
    --radius-md: 10px;
    --radius-lg: 12px;
    --radius-xl: 20px;
}

:root {
    /* Apple Light Theme Colors */
    --background: #ffffff;
    --foreground: #000000;
    --card: #ffffff;
    --card-foreground: #000000;
    --popover: #ffffff;
    --popover-foreground: #000000;
    --primary: #0071e3; /* Apple Blue */
    --primary-foreground: #ffffff;
    --secondary: #f5f5f7; /* Apple Light Gray */
    --secondary-foreground: #1d1d1f;
    --muted: #f5f5f7;
    --muted-foreground: #86868b;
    --accent: #0071e3; /* Apple Blue */
    --accent-foreground: #ffffff;
    --destructive: #ff3b30; /* Apple Red */
    --destructive-foreground: #ffffff;
    --border: #e2e2e7; /* Lighter, more subtle border */
    --input: #f5f5f7;
    --ring: #0071e3;
    --chart-1: #0071e3; /* Apple Blue */
    --chart-2: #34c759; /* Apple Green */
    --chart-3: #ff9500; /* Apple Orange */
    --chart-4: #ffcc00; /* Apple Yellow */
    --chart-5: #af52de; /* Apple Purple */
    --sidebar: #f5f5f7;
    --sidebar-foreground: #1d1d1f;
    --sidebar-primary: #0071e3;
    --sidebar-primary-foreground: #ffffff;
    --sidebar-accent: #e8e8ed;
    --sidebar-accent-foreground: #1d1d1f;
    --sidebar-border: #e2e2e7; /* Lighter border */
    --sidebar-ring: #0071e3;
    /* Apple Fonts */
    --font-apple-system:
        -apple-system, BlinkMacSystemFont, "San Francisco", "Helvetica Neue",
        Helvetica, sans-serif;
    --font-sf-mono: "SF Mono", Menlo, monospace;
    --font-sans: var(--font-apple-system);
    --font-serif: "New York", Georgia, serif;
    --font-mono: var(--font-sf-mono);
    /* Apple uses more rounded corners */
    --radius: 10px;
    /* Apple-style shadows */
    --shadow-2xs: 0px 1px 2px rgba(0, 0, 0, 0.05);
    --shadow-xs: 0px 1px 3px rgba(0, 0, 0, 0.1);
    --shadow-sm: 0px 2px 4px rgba(0, 0, 0, 0.1);
    --shadow: 0px 2px 6px rgba(0, 0, 0, 0.1);
    --shadow-md: 0px 4px 8px rgba(0, 0, 0, 0.1);
    --shadow-lg: 0px 8px 16px rgba(0, 0, 0, 0.1);
    --shadow-xl: 0px 12px 24px rgba(0, 0, 0, 0.1);
    --shadow-2xl: 0px 16px 32px rgba(0, 0, 0, 0.1);
}

@layer base {
    * {
        @apply border-border outline-ring/50;
    }
    body {
        @apply bg-background text-foreground font-sans;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }
    button,
    input,
    select,
    textarea {
        @apply focus:outline-none focus:ring-2 focus:ring-primary/50 transition-all duration-200;
    }
    button {
        @apply hover:cursor-pointer;
    }
    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
        @apply font-medium tracking-tight;
    }
}

.dark {
    --sidebar: hsl(240 5.9% 10%);
    --sidebar-foreground: hsl(240 4.8% 95.9%);
    --sidebar-primary: hsl(224.3 76.3% 48%);
    --sidebar-primary-foreground: hsl(0 0% 100%);
    --sidebar-accent: hsl(240 3.7% 15.9%);
    --sidebar-accent-foreground: hsl(240 4.8% 95.9%);
    --sidebar-border: hsl(240 3.7% 15.9%);
    --sidebar-ring: hsl(217.2 91.2% 59.8%);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
    }
  body {
    @apply bg-background text-foreground;
    }
}

/* Grid pattern backgrounds */
.bg-grid-white\/5 {
  background-image: 
    linear-gradient(to right, rgba(255, 255, 255, 0.05) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
  background-size: 20px 20px;
}

.bg-grid-black\/\[0\.02\] {
  background-image: 
    linear-gradient(to right, rgba(0, 0, 0, 0.02) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(0, 0, 0, 0.02) 1px, transparent 1px);
  background-size: 40px 40px;
}

.bg-grid-white\/\[0\.02\] {
  background-image: 
    linear-gradient(to right, rgba(255, 255, 255, 0.02) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
  background-size: 40px 40px;
}

/* Shine Border Animation */
@keyframes shine-pulse {
  0% {
    background-position: 0% 0%;
  }
  50% {
    background-position: 100% 100%;
  }
  100% {
    background-position: 0% 0%;
  }
}

.before\:bg-shine-size::before {
  background-size: 300% 300%;
}



================================================
FILE: app/root.tsx
================================================
import {
  isRouteErrorResponse,
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "react-router";

import { ClerkProvider, useAuth } from "@clerk/react-router";
import { rootAuthLoader } from "@clerk/react-router/ssr.server";
import { ConvexReactClient } from "convex/react";
import { ConvexProviderWithClerk } from "convex/react-clerk";
import type { Route } from "./+types/root";
import "./app.css";
import { Analytics } from "@vercel/analytics/react";
import { Toaster } from "sonner";

const convex = new ConvexReactClient(import.meta.env.VITE_CONVEX_URL as string);

export async function loader(args: Route.LoaderArgs) {
  return rootAuthLoader(args);
}
export const links: Route.LinksFunction = () => [
  // DNS prefetch for external services
  { rel: "dns-prefetch", href: "https://fonts.googleapis.com" },
  { rel: "dns-prefetch", href: "https://fonts.gstatic.com" },
  { rel: "dns-prefetch", href: "https://api.convex.dev" },
  { rel: "dns-prefetch", href: "https://clerk.dev" },
  
  // Preconnect to font services
  { rel: "preconnect", href: "https://fonts.googleapis.com" },
  {
    rel: "preconnect",
    href: "https://fonts.gstatic.com",
    crossOrigin: "anonymous",
  },
  
  // Font with display=swap for performance
  {
    rel: "stylesheet",
    href: "https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap",
  },
  
  // Preload critical assets
  {
    rel: "preload",
    href: "/ypai.png",
    as: "image",
    type: "image/png",
  },
  {
    rel: "preload",
    href: "/ypai.png", 
    as: "image",
    type: "image/png",
  },
  
  // Icon
  {
    rel: "icon",
    type: "image/png",
    href: "/ypai.png",
  },
];

export function Layout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
      </head>
      <body>
        <Analytics />
        {children}
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}

export default function App({ loaderData }: Route.ComponentProps) {
  return (
    <ClerkProvider
      loaderData={loaderData}
      signUpFallbackRedirectUrl="/dashboard"
      signInFallbackRedirectUrl="/dashboard"
    >
      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
        <Outlet />
        <Toaster position="bottom-right" />
      </ConvexProviderWithClerk>
    </ClerkProvider>
  );
}

export function ErrorBoundary({ error }: Route.ErrorBoundaryProps) {
  let message = "Oops!";
  let details = "An unexpected error occurred.";
  let stack: string | undefined;

  if (isRouteErrorResponse(error)) {
    message = error.status === 404 ? "404" : "Error";
    details =
      error.status === 404
        ? "The requested page could not be found."
        : error.statusText || details;
  } else if (import.meta.env.DEV && error && error instanceof Error) {
    details = error.message;
    stack = error.stack;
  }

  return (
    <main className="pt-16 p-4 container mx-auto">
      <h1>{message}</h1>
      <p>{details}</p>
      {stack && (
        <pre className="w-full p-4 overflow-x-auto">
          <code>{stack}</code>
        </pre>
      )}
    </main>
  );
}



================================================
FILE: app/routes.ts
================================================
import {
  type RouteConfig,
  index,
  layout,
  route,
} from "@react-router/dev/routes";

export default [
  index("routes/home.tsx"),
  route("sign-in/*", "routes/sign-in.tsx"),
  route("sign-up/*", "routes/sign-up.tsx"),
  route("share/:shareId", "routes/share.$shareId.tsx"),
  layout("routes/dashboard/layout.tsx", [
    route("dashboard", "routes/dashboard/index.tsx"),
    route("dashboard/project/:projectId", "routes/dashboard/project.$projectId.tsx"),
    route("dashboard/chat", "routes/dashboard/chat.tsx"),
    route("dashboard/settings", "routes/dashboard/settings.tsx"),
  ]),
] satisfies RouteConfig;



================================================
FILE: app/components/ClientOnly.tsx
================================================
import { useEffect, useState } from "react";

interface ClientOnlyProps {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

export function ClientOnly({ children, fallback = null }: ClientOnlyProps) {
  const [hasMounted, setHasMounted] = useState(false);

  useEffect(() => {
    setHasMounted(true);
  }, []);

  if (!hasMounted) {
    return <>{fallback}</>;
  }

  return <>{children}</>;
}


================================================
FILE: app/components/ErrorBoundary.tsx
================================================
import React from 'react';
import { Button } from "~/components/ui/button";
import { Card } from "~/components/ui/card";
import { AlertCircle, RefreshCw, Home } from "lucide-react";

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: React.ErrorInfo | null;
}

export class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  ErrorBoundaryState
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error, errorInfo: null };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    this.setState({ error, errorInfo });
  }

  handleReset = () => {
    this.setState({ hasError: false, error: null, errorInfo: null });
    window.location.reload();
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-background p-4">
          <Card className="max-w-lg w-full p-6">
            <div className="flex flex-col items-center text-center space-y-4">
              <div className="w-12 h-12 rounded-full bg-destructive/10 flex items-center justify-center">
                <AlertCircle className="h-6 w-6 text-destructive" />
              </div>
              
              <div className="space-y-2">
                <h1 className="text-2xl font-semibold">Something went wrong</h1>
                <p className="text-muted-foreground">
                  We encountered an unexpected error. Don't worry, your work has been saved.
                </p>
              </div>

              {this.state.error && (
                <Card className="w-full p-4 bg-muted/50">
                  <p className="text-sm font-mono text-left">
                    {this.state.error.message}
                  </p>
                </Card>
              )}

              <div className="flex gap-3 pt-2">
                <Button
                  variant="outline"
                  onClick={() => window.location.href = '/'}
                  className="gap-2"
                >
                  <Home className="h-4 w-4" />
                  Go Home
                </Button>
                <Button
                  onClick={this.handleReset}
                  className="gap-2"
                >
                  <RefreshCw className="h-4 w-4" />
                  Reload Page
                </Button>
              </div>

              <p className="text-xs text-muted-foreground pt-4">
                If this issue persists, please contact support
              </p>
            </div>
          </Card>
        </div>
      );
    }

    return this.props.children;
  }
}


================================================
FILE: app/components/logo.tsx
================================================
import { cn } from "../lib/utils";

export const Logo = ({
  className,
  uniColor,
}: {
  className?: string;
  uniColor?: boolean;
}) => {
  return (
    <svg
      viewBox="0 0 78 18"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      className={cn("text-foreground h-5 w-auto", className)}
    >
      <path
        d="M3 0H5V18H3V0ZM13 0H15V18H13V0ZM18 3V5H0V3H18ZM0 15V13H18V15H0Z"
        fill={uniColor ? "currentColor" : "url(#logo-gradient)"}
      />
      <path
        d="M27.06 7.054V12.239C27.06 12.5903 27.1393 12.8453 27.298 13.004C27.468 13.1513 27.7513 13.225 28.148 13.225H29.338V14.84H27.808C26.9353 14.84 26.2667 14.636 25.802 14.228C25.3373 13.82 25.105 13.157 25.105 12.239V7.054H24V5.473H25.105V3.144H27.06V5.473H29.338V7.054H27.06ZM30.4782 10.114C30.4782 9.17333 30.6709 8.34033 31.0562 7.615C31.4529 6.88967 31.9855 6.32867 32.6542 5.932C33.3342 5.524 34.0822 5.32 34.8982 5.32C35.6349 5.32 36.2752 5.46733 36.8192 5.762C37.3745 6.04533 37.8165 6.40233 38.1452 6.833V5.473H40.1002V14.84H38.1452V13.446C37.8165 13.888 37.3689 14.2563 36.8022 14.551C36.2355 14.8457 35.5895 14.993 34.8642 14.993C34.0595 14.993 33.3229 14.789 32.6542 14.381C31.9855 13.9617 31.4529 13.3837 31.0562 12.647C30.6709 11.899 30.4782 11.0547 30.4782 10.114ZM38.1452 10.148C38.1452 9.502 38.0092 8.941 37.7372 8.465C37.4765 7.989 37.1309 7.62633 36.7002 7.377C36.2695 7.12767 35.8049 7.003 35.3062 7.003C34.8075 7.003 34.3429 7.12767 33.9122 7.377C33.4815 7.615 33.1302 7.972 32.8582 8.448C32.5975 8.91267 32.4672 9.468 32.4672 10.114C32.4672 10.76 32.5975 11.3267 32.8582 11.814C33.1302 12.3013 33.4815 12.6753 33.9122 12.936C34.3542 13.1853 34.8189 13.31 35.3062 13.31C35.8049 13.31 36.2695 13.1853 36.7002 12.936C37.1309 12.6867 37.4765 12.324 37.7372 11.848C38.0092 11.3607 38.1452 10.794 38.1452 10.148ZM43.6317 4.232C43.2803 4.232 42.9857 4.113 42.7477 3.875C42.5097 3.637 42.3907 3.34233 42.3907 2.991C42.3907 2.63967 42.5097 2.345 42.7477 2.107C42.9857 1.869 43.2803 1.75 43.6317 1.75C43.9717 1.75 44.2607 1.869 44.4987 2.107C44.7367 2.345 44.8557 2.63967 44.8557 2.991C44.8557 3.34233 44.7367 3.637 44.4987 3.875C44.2607 4.113 43.9717 4.232 43.6317 4.232ZM44.5837 5.473V14.84H42.6457V5.473H44.5837ZM49.0661 2.26V14.84H47.1281V2.26H49.0661ZM50.9645 10.114C50.9645 9.17333 51.1572 8.34033 51.5425 7.615C51.9392 6.88967 52.4719 6.32867 53.1405 5.932C53.8205 5.524 54.5685 5.32 55.3845 5.32C56.1212 5.32 56.7615 5.46733 57.3055 5.762C57.8609 6.04533 58.3029 6.40233 58.6315 6.833V5.473H60.5865V14.84H58.6315V13.446C58.3029 13.888 57.8552 14.2563 57.2885 14.551C56.7219 14.8457 56.0759 14.993 55.3505 14.993C54.5459 14.993 53.8092 14.789 53.1405 14.381C52.4719 13.9617 51.9392 13.3837 51.5425 12.647C51.1572 11.899 50.9645 11.0547 50.9645 10.114ZM58.6315 10.148C58.6315 9.502 58.4955 8.941 58.2235 8.465C57.9629 7.989 57.6172 7.62633 57.1865 7.377C56.7559 7.12767 56.2912 7.003 55.7925 7.003C55.2939 7.003 54.8292 7.12767 54.3985 7.377C53.9679 7.615 53.6165 7.972 53.3445 8.448C53.0839 8.91267 52.9535 9.468 52.9535 10.114C52.9535 10.76 53.0839 11.3267 53.3445 11.814C53.6165 12.3013 53.9679 12.6753 54.3985 12.936C54.8405 13.1853 55.3052 13.31 55.7925 13.31C56.2912 13.31 56.7559 13.1853 57.1865 12.936C57.6172 12.6867 57.9629 12.324 58.2235 11.848C58.4955 11.3607 58.6315 10.794 58.6315 10.148ZM65.07 6.833C65.3533 6.357 65.7273 5.98867 66.192 5.728C66.668 5.456 67.229 5.32 67.875 5.32V7.326H67.382C66.6227 7.326 66.0447 7.51867 65.648 7.904C65.2627 8.28933 65.07 8.958 65.07 9.91V14.84H63.132V5.473H65.07V6.833ZM73.3624 10.165L77.6804 14.84H75.0624L71.5944 10.811V14.84H69.6564V2.26H71.5944V9.57L74.9944 5.473H77.6804L73.3624 10.165Z"
        fill="currentColor"
      />
      <defs>
        <linearGradient
          id="logo-gradient"
          x1="10"
          y1="0"
          x2="10"
          y2="20"
          gradientUnits="userSpaceOnUse"
        >
          <stop stopColor="#9B99FE" />
          <stop offset="1" stopColor="#2BC8B7" />
        </linearGradient>
      </defs>
    </svg>
  );
};

export const LogoIcon = ({
  className,
  uniColor,
}: {
  className?: string;
  uniColor?: boolean;
}) => {
  return <img src="/youtube-ai-logo.png" className="w-12 h-12" />;
};

export const LogoStroke = ({ className }: { className?: string }) => {
  return (
    <svg
      className={cn("size-7 w-7", className)}
      viewBox="0 0 71 25"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M61.25 1.625L70.75 1.5625C70.75 4.77083 70.25 7.79167 69.25 10.625C68.2917 13.4583 66.8958 15.9583 65.0625 18.125C63.2708 20.25 61.125 21.9375 58.625 23.1875C56.1667 24.3958 53.4583 25 50.5 25C46.875 25 43.6667 24.2708 40.875 22.8125C38.125 21.3542 35.125 19.2083 31.875 16.375C29.75 14.4167 27.7917 12.8958 26 11.8125C24.2083 10.7292 22.2708 10.1875 20.1875 10.1875C18.0625 10.1875 16.25 10.7083 14.75 11.75C13.25 12.75 12.0833 14.1875 11.25 16.0625C10.4583 17.9375 10.0625 20.1875 10.0625 22.8125L0 22.9375C0 19.6875 0.479167 16.6667 1.4375 13.875C2.4375 11.0833 3.83333 8.64583 5.625 6.5625C7.41667 4.47917 9.54167 2.875 12 1.75C14.5 0.583333 17.2292 0 20.1875 0C23.8542 0 27.1042 0.770833 29.9375 2.3125C32.8125 3.85417 35.7708 5.97917 38.8125 8.6875C41.1042 10.7708 43.1042 12.3333 44.8125 13.375C46.5625 14.375 48.4583 14.875 50.5 14.875C52.6667 14.875 54.5417 14.3125 56.125 13.1875C57.75 12.0625 59 10.5 59.875 8.5C60.7917 6.5 61.25 4.20833 61.25 1.625Z"
        fill="none"
        strokeWidth={0.5}
        stroke="currentColor"
      />
    </svg>
  );
};



================================================
FILE: app/components/VideoProcessingHelp.tsx
================================================
import { Card } from "~/components/ui/card";
import { Button } from "~/components/ui/button";
import { AlertCircle, HelpCircle, Video, FileAudio, Image, X } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "~/components/ui/dialog";

export function VideoProcessingHelp() {
  return (
    <Dialog>
      <DialogTrigger asChild>
        <Button variant="ghost" size="sm" className="gap-2">
          <HelpCircle className="h-4 w-4" />
          Help
        </Button>
      </DialogTrigger>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>Video Processing Guide</DialogTitle>
          <DialogDescription>
            Learn about video processing, common issues, and solutions
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-4 py-4">
          {/* File Size Limits */}
          <Card className="p-4">
            <div className="flex gap-3">
              <Video className="h-5 w-5 text-primary mt-0.5" />
              <div className="space-y-2">
                <h3 className="font-semibold">Video Size Limits</h3>
                <ul className="text-sm text-muted-foreground space-y-1">
                  <li>‚Ä¢ <strong>Under 25MB:</strong> Direct transcription (fastest)</li>
                  <li>‚Ä¢ <strong>25MB - 100MB:</strong> Audio extraction required (slower)</li>
                  <li>‚Ä¢ <strong>Over 100MB:</strong> Not supported</li>
                </ul>
                <p className="text-sm">
                  For best results, compress videos to under 25MB or trim to ~10 minutes.
                </p>
              </div>
            </div>
          </Card>

          {/* Supported Formats */}
          <Card className="p-4">
            <div className="flex gap-3">
              <FileAudio className="h-5 w-5 text-primary mt-0.5" />
              <div className="space-y-2">
                <h3 className="font-semibold">Supported Formats</h3>
                <p className="text-sm text-muted-foreground">
                  MP4, MOV, AVI, WebM ‚Ä¢ H.264/H.265 codecs ‚Ä¢ AAC/MP3 audio
                </p>
                <p className="text-sm">
                  If your video won't upload, try converting it to MP4 format.
                </p>
              </div>
            </div>
          </Card>

          {/* Common Errors */}
          <Card className="p-4">
            <div className="flex gap-3">
              <AlertCircle className="h-5 w-5 text-yellow-500 mt-0.5" />
              <div className="space-y-2">
                <h3 className="font-semibold">Common Issues & Solutions</h3>
                <div className="space-y-3 text-sm">
                  <div>
                    <p className="font-medium">Transcription Failed</p>
                    <p className="text-muted-foreground">
                      ‚Ä¢ Check if video has audio track<br/>
                      ‚Ä¢ Ensure audio isn't muted or empty<br/>
                      ‚Ä¢ Try a shorter video clip
                    </p>
                  </div>
                  <div>
                    <p className="font-medium">Upload Failed</p>
                    <p className="text-muted-foreground">
                      ‚Ä¢ Check your internet connection<br/>
                      ‚Ä¢ Verify file isn't corrupted<br/>
                      ‚Ä¢ Try a smaller file size
                    </p>
                  </div>
                  <div>
                    <p className="font-medium">Thumbnail Generation Failed</p>
                    <p className="text-muted-foreground">
                      ‚Ä¢ Upload a custom thumbnail instead<br/>
                      ‚Ä¢ Ensure video content is appropriate<br/>
                      ‚Ä¢ Try with different video frames
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </Card>
        </div>
      </DialogContent>
    </Dialog>
  );
}


================================================
FILE: app/components/canvas/AgentNode.tsx
================================================
import { memo } from "react";
import { Handle, Position, type NodeProps } from "./ReactFlowComponents";
import { 
  FileText, 
  Image, 
  Twitter, 
  MessageSquare,
  Loader2,
  CheckCircle2,
  AlertCircle,
  RefreshCw,
  Sparkles,
  Hash,
  Palette,
  Zap,
  Bot,
  Brain
} from "lucide-react";
import { Card } from "~/components/ui/card";
import { Badge } from "~/components/ui/badge";
import { Button } from "~/components/ui/button";

export interface AgentNodeData {
  type: "title" | "description" | "thumbnail" | "tweets";
  draft: string;
  thumbnailUrl?: string;
  status: "idle" | "generating" | "ready" | "error";
  connections: string[];
  generationProgress?: {
    stage: string;
    percent: number;
  };
  lastPrompt?: string;
}

const agentConfig = {
  title: {
    icon: Hash,
    label: "Title Generator",
    description: "Create engaging titles",
    color: "blue",
    gradient: "from-blue-500/20 to-cyan-500/20",
    iconColor: "text-blue-500",
  },
  description: {
    icon: FileText,
    label: "Description Writer",
    description: "SEO-optimized descriptions",
    color: "green",
    gradient: "from-green-500/20 to-emerald-500/20",
    iconColor: "text-green-500",
  },
  thumbnail: {
    icon: Palette,
    label: "Thumbnail Designer",
    description: "Eye-catching visuals",
    color: "purple",
    gradient: "from-purple-500/20 to-pink-500/20",
    iconColor: "text-purple-500",
  },
  tweets: {
    icon: Zap,
    label: "Social Media",
    description: "Viral tweets & posts",
    color: "yellow",
    gradient: "from-yellow-500/20 to-orange-500/20",
    iconColor: "text-yellow-500",
  },
};

interface ExtendedNodeProps {
  data: AgentNodeData & {
    onGenerate?: () => void;
    onChat?: () => void;
    onView?: () => void;
    onRegenerate?: () => void;
    onViewPrompt?: () => void;
  };
  selected?: boolean;
  id: string;
}

// Helper function to clean up draft text
const cleanDraftText = (draft: string, type: string): string => {
  if (!draft) return '';
  
  // For title type, remove common markdown patterns
  if (type === 'title') {
    // Remove **Title: prefix and trailing **
    let cleaned = draft.replace(/^\*\*Title:\s*/i, '');
    cleaned = cleaned.replace(/\*\*/g, '');
    // Remove quotes if they wrap the entire title
    cleaned = cleaned.trim();
    if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
      cleaned = cleaned.slice(1, -1);
    }
    return cleaned.trim();
  }
  
  return draft;
};

export const AgentNode = memo(({ data, selected, id }: ExtendedNodeProps) => {
  const config = agentConfig[data.type];
  const Icon = config.icon;

  const statusIcons = {
    idle: null,
    generating: <Loader2 className="h-4 w-4 animate-spin" />,
    ready: <CheckCircle2 className="h-4 w-4 text-green-500" />,
    error: <AlertCircle className="h-4 w-4 text-red-500" />,
  };

  const statusColors = {
    idle: "secondary",
    generating: "default",
    ready: "default", // Changed from "success" since that variant doesn't exist
    error: "destructive",
  } as const;

  return (
    <div className={`relative group ${selected ? "scale-105" : ""} transition-transform duration-200`}>
      {/* Glow effect when selected */}
      {selected && (
        <div className={`absolute -inset-1 bg-gradient-to-r ${config.gradient} rounded-2xl blur-lg animate-pulse`} />
      )}
      
      <Card className={`relative w-72 p-5 border-muted/50 shadow-xl bg-gradient-to-b from-background to-background/90 backdrop-blur-sm transition-all duration-300 hover:shadow-2xl ${selected ? "border-primary/50" : ""}`}>
        <Handle
          type="target"
          position={Position.Left}
          id="agent-input"
          className={`!w-3 !h-3 !bg-gradient-to-r ${config.gradient} !border-2 !border-background`}
          style={{ top: '50%' }}
        />
        
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-3">
            <div className={`p-2 rounded-lg bg-gradient-to-br ${config.gradient} backdrop-blur-sm`}>
              <Icon className={`h-5 w-5 ${config.iconColor}`} />
            </div>
            <div>
              <h3 className="font-semibold text-foreground">{config.label}</h3>
              <p className="text-xs text-muted-foreground">{config.description}</p>
            </div>
          </div>
          <div className="flex items-center gap-1">
            {data.status !== "idle" && (
              <div className="flex items-center gap-1.5">
                {statusIcons[data.status]}
                <Bot className="h-3.5 w-3.5 text-muted-foreground" />
              </div>
            )}
            {data.lastPrompt && data.status === "ready" && (
              <Button
                size="icon"
                variant="ghost"
                className="h-7 w-7 hover:bg-primary/10"
                onClick={data.onViewPrompt}
                title="View generation prompt"
              >
                <Brain className="h-4 w-4 text-primary" />
              </Button>
            )}
          </div>
        </div>
      
      {/* Show progress when generating */}
      {data.status === "generating" && data.generationProgress && (
        <div className="mb-4">
          <div className="rounded-lg bg-primary/10 p-4 border border-primary/20">
            <div className="flex items-center gap-3 mb-2">
              <div className="relative">
                <div className="absolute inset-0 bg-primary/20 rounded-full blur animate-pulse" />
                <Loader2 className="relative h-5 w-5 animate-spin text-primary" />
              </div>
              <div className="flex-1">
                <p className="text-sm font-medium">{data.generationProgress.stage}</p>
                <p className="text-xs text-muted-foreground">Generating amazing content...</p>
              </div>
            </div>
            <div className="w-full bg-muted rounded-full h-2 overflow-hidden">
              <div 
                className="h-full bg-gradient-to-r from-primary to-primary/80 transition-all duration-500 ease-out"
                style={{ width: `${data.generationProgress.percent}%` }}
              />
            </div>
          </div>
        </div>
      )}
      
      {/* Regular content display */}
      {data.status !== "generating" && (data.type === "thumbnail" && data.thumbnailUrl ? (
        <div className="mb-4 cursor-pointer group/content" onClick={data.onView}>
          <div className="aspect-video relative rounded-xl overflow-hidden bg-black shadow-lg transition-all duration-300 hover:shadow-xl">
            <img 
              src={data.thumbnailUrl} 
              alt="Generated thumbnail" 
              className="w-full h-full object-cover transition-transform duration-300 group-hover/content:scale-105"
            />
            <div className="absolute inset-0 bg-gradient-to-t from-black/50 via-transparent to-transparent opacity-0 group-hover/content:opacity-100 transition-opacity" />
          </div>
          {data.draft && (
            <p className="text-xs text-muted-foreground mt-2 line-clamp-2 px-1">
              {cleanDraftText(data.draft, data.type)}
            </p>
          )}
        </div>
      ) : data.draft ? (
        <div className="mb-4 cursor-pointer group/content" onClick={data.onView}>
          <div className="rounded-lg bg-muted/50 p-4 border border-border/50 transition-all duration-200 hover:bg-muted/70 hover:border-border">
            <p className="text-sm text-foreground/80 line-clamp-3 leading-relaxed">
              {cleanDraftText(data.draft, data.type)}
            </p>
          </div>
        </div>
      ) : (
        <div className="mb-4">
          <div className="rounded-lg bg-gradient-to-br from-muted/30 to-muted/10 p-8 border border-dashed border-muted-foreground/20">
            <div className="text-center">
              <Sparkles className="h-8 w-8 text-muted-foreground/30 mx-auto mb-2" />
              <p className="text-sm text-muted-foreground">
                No content generated yet
              </p>
              <p className="text-xs text-muted-foreground/70 mt-1">
                Click Generate to create content
              </p>
            </div>
          </div>
        </div>
      ))}
      
      <div className="flex items-center gap-2">
        <Button 
          size="sm" 
          variant="outline" 
          className="flex-1 hover:bg-primary/10 hover:border-primary/50 hover:text-primary transition-all"
          onClick={data.onChat}
          disabled={data.status === "generating"}
        >
          <MessageSquare className="h-3.5 w-3.5 mr-1.5" />
          Chat
        </Button>
        {data.status === "ready" && data.draft ? (
          <Button 
            size="sm" 
            variant="outline" 
            className="flex-1 hover:bg-primary/10 hover:border-primary/50 hover:text-primary transition-all"
            onClick={data.onRegenerate}
            disabled={data.status === "generating"}
          >
            <RefreshCw className="h-3.5 w-3.5 mr-1.5" />
            Regenerate
          </Button>
        ) : (
          <Button 
            size="sm" 
            variant="default" 
            className={`flex-1 bg-gradient-to-r ${config.gradient} hover:opacity-90 transition-all text-foreground font-medium shadow-sm`}
            onClick={data.onGenerate}
            disabled={data.status === "generating"}
          >
            {data.status === "generating" ? (
              <>
                <Loader2 className="h-3.5 w-3.5 mr-1.5 animate-spin" />
                Generating...
              </>
            ) : (
              <>
                <Sparkles className="h-3.5 w-3.5 mr-1.5" />
                Generate
              </>
            )}
          </Button>
        )}
      </div>
      
      <Handle
        type="source"
        position={Position.Right}
        id="agent-output"
        className={`!w-3 !h-3 !bg-gradient-to-r ${config.gradient} !border-2 !border-background`}
        style={{ top: '50%' }}
      />
    </Card>
    </div>
  );
});

AgentNode.displayName = "AgentNode";


================================================
FILE: app/components/canvas/Canvas.tsx
================================================
import { api } from "convex/_generated/api";
import type { Id } from "convex/_generated/dataModel";
import { useAction, useMutation, useQuery } from "convex/react";
import { Bot, Check, ChevronLeft, ChevronRight, Eye, FileText, GripVertical, Hash, Layers, Map, Palette, Settings2, Share2, Sparkles, Upload, Video, Zap } from "lucide-react";
import { useCallback, useEffect, useRef, useState, type DragEvent } from "react";
import { toast } from "sonner";
import { PreviewModal } from "~/components/preview/PreviewModal";
import { Button } from "~/components/ui/button";
import { VideoProcessingHelp } from "~/components/VideoProcessingHelp";
import { extractAudioFromVideo } from "~/lib/ffmpeg-audio";
import { createRetryAction, handleVideoError } from "~/lib/video-error-handler";
import { extractVideoMetadata } from "~/lib/video-metadata";

import { compressAudioFile, isFileTooLarge, getFileSizeMB } from "~/lib/audio-compression";
import { AgentNode } from "./AgentNode";
import { ContentModal } from "./ContentModal";
import { DeleteConfirmationDialog } from "./DeleteConfirmationDialog";
import { FloatingChat } from "./FloatingChat";
import { PromptModal } from "./PromptModal";
import type {
  Edge,
  Node,
  NodeTypes,
  OnConnect,
} from "./ReactFlowComponents";
import { ReactFlowWrapper } from "./ReactFlowWrapper";
import { ThumbnailUploadModal } from "./ThumbnailUploadModal";
import { VideoNode } from "./VideoNode";
import { VideoPlayerModal } from "./VideoPlayerModal";

const nodeTypes: NodeTypes = {
  video: VideoNode,
  agent: AgentNode,
};

function CanvasContent({ projectId }: { projectId: Id<"projects"> }) {
  return (
    <ReactFlowWrapper>
      {({ ReactFlow, ReactFlowProvider, Background, Controls, MiniMap, useNodesState, useEdgesState, addEdge }) => (
        <InnerCanvas 
          projectId={projectId}
          ReactFlow={ReactFlow}
          ReactFlowProvider={ReactFlowProvider}
          Background={Background}
          Controls={Controls}
          MiniMap={MiniMap}
          useNodesState={useNodesState}
          useEdgesState={useEdgesState}
          addEdge={addEdge}
        />
      )}
    </ReactFlowWrapper>
  );
}

function InnerCanvas({ 
  projectId,
  ReactFlow,
  ReactFlowProvider,
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState,
  addEdge
}: { 
  projectId: Id<"projects">;
  ReactFlow: any;
  ReactFlowProvider: any;
  Background: any;
  Controls: any;
  MiniMap: any;
  useNodesState: any;
  useEdgesState: any;
  addEdge: any;
}) {
  const reactFlowWrapper = useRef<HTMLDivElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [reactFlowInstance, setReactFlowInstance] = useState<any>(null);
  const [selectedNodeForModal, setSelectedNodeForModal] = useState<string | null>(null);
  const [chatInput, setChatInput] = useState<string>("");
  const [hasLoadedFromDB, setHasLoadedFromDB] = useState(false);
  const [hasInitializedViewport, setHasInitializedViewport] = useState(false);
  const [isGeneratingAll, setIsGeneratingAll] = useState(false);
  const [generationProgress, setGenerationProgress] = useState({ current: 0, total: 0 });
  const [thumbnailModalOpen, setThumbnailModalOpen] = useState(false);
  const [pendingThumbnailNode, setPendingThumbnailNode] = useState<string | null>(null);
  const [videoModalOpen, setVideoModalOpen] = useState(false);
  const [selectedVideo, setSelectedVideo] = useState<{ url: string; title: string; duration?: number; fileSize?: number } | null>(null);
  const [previewModalOpen, setPreviewModalOpen] = useState(false);
  const [enableEdgeAnimations, setEnableEdgeAnimations] = useState(true);
  const [isDragging, setIsDragging] = useState(false);
  const [showMiniMap, setShowMiniMap] = useState(true);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [nodesToDelete, setNodesToDelete] = useState<Node[]>([]);
  const [promptModalOpen, setPromptModalOpen] = useState(false);
  const [selectedPrompt, setSelectedPrompt] = useState<{ agentType: string; prompt: string } | null>(null);
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(() => {
    // Get initial state from localStorage
    if (typeof window !== "undefined") {
      const saved = localStorage.getItem("canvas-sidebar-collapsed");
      return saved === "true";
    }
    return false;
  });
  const [chatMessages, setChatMessages] = useState<Array<{
    id: string;
    role: "user" | "ai";
    content: string;
    timestamp: number;
    agentId?: string;
  }>>([]);
  const [isChatGenerating, setIsChatGenerating] = useState(false);
  const [isShareModalOpen, setIsShareModalOpen] = useState(false);
  const [copiedShareLink, setCopiedShareLink] = useState(false);
  
  // Use refs to access current values in callbacks
  const nodesRef = useRef(nodes);
  const edgesRef = useRef(edges);
  
  // Keep refs updated
  useEffect(() => {
    nodesRef.current = nodes;
  }, [nodes]);
  
  useEffect(() => {
    edgesRef.current = edges;
  }, [edges]);
  
  // Save sidebar collapsed state
  useEffect(() => {
    localStorage.setItem("canvas-sidebar-collapsed", String(isSidebarCollapsed));
  }, [isSidebarCollapsed]);
  
  // Convex queries
  const canvasState = useQuery(api.canvas.getState, { projectId });
  const projectVideos = useQuery(api.videos.getByProject, { projectId });
  const projectAgents = useQuery(api.agents.getByProject, { projectId });
  const userProfile = useQuery(api.profiles.get);
  
  // Convex mutations
  const createVideo = useMutation(api.videos.create);
  const updateVideoMetadata = useMutation(api.videos.updateMetadata);
  const updateVideo = useMutation(api.videos.update);
  const generateUploadUrl = useMutation(api.files.generateUploadUrl);
  const updateVideoStorageId = useMutation(api.videos.updateVideoStorageId);
  const createAgent = useMutation(api.agents.create);
  const updateAgentDraft = useMutation(api.agents.updateDraft);
  const updateAgentConnections = useMutation(api.agents.updateConnections);
  const updateAgentPosition = useMutation(api.agents.updatePosition);
  const saveCanvasState = useMutation(api.canvas.saveState);
  const scheduleTranscription = useMutation(api.videoJobs.scheduleTranscription);
  const deleteVideo = useMutation(api.videos.remove);
  const deleteAgent = useMutation(api.agents.remove);
  const createShareLink = useMutation(api.shares.createShareLink);
  const getShareLink = useQuery(api.shares.getShareLink, { projectId });
  
  // Convex actions for AI
  const generateContent = useAction(api.aiHackathon.generateContentSimple);
  const generateThumbnail = useAction(api.thumbnail.generateThumbnail);
  const refineContent = useAction(api.chat.refineContent);
  const refineThumbnail = useAction(api.thumbnailRefine.refineThumbnail);

  // Handle content generation for an agent node
  const handleGenerate = useCallback(async (nodeId: string, thumbnailImages?: File[], additionalContext?: string) => {
    const agentNode = nodesRef.current.find((n: any) => n.id === nodeId);
    if (!agentNode) {
      console.error("Agent node not found:", nodeId);
      return;
    }
    
    // For thumbnail agents without images, show the upload modal
    if (agentNode.data.type === "thumbnail" && !thumbnailImages) {
      console.log("[Canvas] Opening thumbnail upload modal for node:", nodeId);
      setPendingThumbnailNode(nodeId);
      setThumbnailModalOpen(true);
      return;
    }
    
    try {
      // Update status to generating in UI with initial progress
      setNodes((nds: any) =>
        nds.map((node: any) =>
          node.id === nodeId
            ? { 
                ...node, 
                data: { 
                  ...node.data, 
                  status: "generating",
                  generationProgress: {
                    stage: "Preparing...",
                    percent: 0
                  }
                } 
              }
            : node
        )
      );
      
      // Also update status in database if we have an agentId
      if (agentNode.data.agentId) {
        await updateAgentDraft({
          id: agentNode.data.agentId as Id<"agents">,
          draft: agentNode.data.draft || "",
          status: "generating",
        });
      }
      
      // Find connected video node
      const connectedVideoEdge = edgesRef.current.find((e: any) => e.target === nodeId && e.source?.includes('video'));
      const videoNode = connectedVideoEdge ? nodesRef.current.find((n: any) => n.id === connectedVideoEdge.source) : null;
      
      // Find other connected agent nodes
      const connectedAgentNodes = edgesRef.current
        .filter((e: any) => e.target === nodeId && e.source?.includes('agent'))
        .map((e: any) => nodesRef.current.find((n: any) => n.id === e.source))
        .filter(Boolean);
      
      // Update progress: Gathering context
      setNodes((nds: any) =>
        nds.map((node: any) =>
          node.id === nodeId
            ? { 
                ...node, 
                data: { 
                  ...node.data, 
                  generationProgress: {
                    stage: "Gathering context...",
                    percent: 20
                  }
                } 
              }
            : node
        )
      );

      // Prepare data for AI generation
      let videoData: { 
        title?: string; 
        transcription?: string;
        duration?: number;
        resolution?: { width: number; height: number };
        format?: string;
      } = {};
      if (videoNode && videoNode.data.videoId) {
        // Fetch the video with transcription and metadata from database
        const video = projectVideos?.find((v: any) => v._id === videoNode.data.videoId);
        videoData = {
          title: videoNode.data.title as string,
          transcription: video?.transcription,
          duration: video?.duration,
          resolution: video?.resolution,
          format: video?.format,
        };
        
        // If no transcription, warn the user
        if (!video?.transcription) {
          toast.warning("Generating without transcription - results may be less accurate");
        }
      }
      
      const connectedAgentOutputs = connectedAgentNodes.map((n: any) => ({
        type: n!.data.type as string,
        content: (n!.data.draft || "") as string,
      }));
      
      // Use real user profile data or fallback to defaults
      const profileData = userProfile ? {
        channelName: userProfile.channelName,
        contentType: userProfile.contentType,
        niche: userProfile.niche,
        tone: userProfile.tone || "Professional and engaging",
        targetAudience: userProfile.targetAudience || "General audience",
      } : {
        channelName: "My Channel",
        contentType: "General Content",
        niche: "General",
        tone: "Professional and engaging",
        targetAudience: "General audience",
      };
      
      // Update progress: Analyzing content
      setNodes((nds: any) =>
        nds.map((node: any) =>
          node.id === nodeId
            ? { 
                ...node, 
                data: { 
                  ...node.data, 
                  generationProgress: {
                    stage: "Analyzing content...",
                    percent: 40
                  }
                } 
              }
            : node
        )
      );

      // Generate content based on agent type
      let result: string;
      let thumbnailUrl: string | undefined;
      let thumbnailStorageId: string | undefined;
      
      if (agentNode.data.type === "thumbnail" && thumbnailImages) {
        // For thumbnail agent, use uploaded images
        console.log("[Canvas] Starting thumbnail generation with uploaded images:", thumbnailImages.length);
        toast.info("Processing uploaded images for thumbnail generation...");
        
        // Convert uploaded images to data URLs
        console.log("[Canvas] Converting images to data URLs...");
        const frames = await Promise.all(
          thumbnailImages.map(async (file, index) => {
            const dataUrl = await new Promise<string>((resolve) => {
              const reader = new FileReader();
              reader.onloadend = () => resolve(reader.result as string);
              reader.readAsDataURL(file);
            });
            return {
              dataUrl,
              timestamp: index, // Use index as timestamp for uploaded images
            };
          })
        );
        console.log("[Canvas] Images converted to data URLs:", frames.length);
        
        // Update progress: Generating with AI
        setNodes((nds: any) =>
          nds.map((node: any) =>
            node.id === nodeId
              ? { 
                  ...node, 
                  data: { 
                    ...node.data, 
                    generationProgress: {
                      stage: "Creating thumbnail design...",
                      percent: 60
                    }
                  } 
                }
              : node
          )
        );

        // Generate thumbnail with vision API
        console.log("[Canvas] Calling generateThumbnail action with:", {
          videoId: videoNode?.data.videoId,
          frameCount: frames.length,
          hasVideoData: !!videoData,
          hasTranscription: !!videoData.transcription,
          connectedAgentsCount: connectedAgentOutputs.length,
          hasProfile: !!profileData
        });
        
        const thumbnailResult = await generateThumbnail({
          agentType: "thumbnail",
          videoId: videoNode?.data.videoId as Id<"videos"> | undefined,
          videoFrames: frames.map(f => ({
            dataUrl: f.dataUrl,
            timestamp: f.timestamp,
          })),
          videoData,
          connectedAgentOutputs,
          profileData,
          additionalContext,
        });
        
        console.log("[Canvas] Thumbnail generation completed");
        console.log("[Canvas] Concept received:", thumbnailResult.concept.substring(0, 100) + "...");
        console.log("[Canvas] Image URL received:", !!thumbnailResult.imageUrl);
        
        result = thumbnailResult.concept;
        thumbnailUrl = thumbnailResult.imageUrl;
        thumbnailStorageId = thumbnailResult.storageId;
        
        // Store the prompt for thumbnail too
        if (thumbnailResult.prompt) {
          setNodes((nds: any) =>
            nds.map((node: any) =>
              node.id === nodeId
                ? { 
                    ...node, 
                    data: { 
                      ...node.data, 
                      lastPrompt: thumbnailResult.prompt
                    } 
                  }
                : node
            )
          );
        }
        
        // If no image was generated due to safety issues, inform the user
        if (!thumbnailUrl) {
          toast.warning("Thumbnail concept created, but image generation was blocked by safety filters. Try uploading different images or adjusting your requirements.");
        }
      } else {
        // Update progress based on agent type
        const progressMessages = {
          title: "Crafting compelling title...",
          description: "Writing SEO-optimized description...",
          tweets: "Creating viral social content..."
        };
        
        setNodes((nds: any) =>
          nds.map((node: any) =>
            node.id === nodeId
              ? { 
                  ...node, 
                  data: { 
                    ...node.data, 
                    generationProgress: {
                      stage: progressMessages[agentNode.data.type as keyof typeof progressMessages] || "Generating content...",
                      percent: 60
                    }
                  } 
                }
              : node
          )
        );

        // Use regular content generation for other agent types
        const generationResult = await generateContent({
          agentType: agentNode.data.type as "title" | "description" | "thumbnail" | "tweets",
          videoId: videoNode?.data.videoId as Id<"videos"> | undefined,
          videoData,
          connectedAgentOutputs,
          profileData,
        });
        result = generationResult.content;
        
        // Store the prompt for viewing later
        setNodes((nds: any) =>
          nds.map((node: any) =>
            node.id === nodeId
              ? { 
                  ...node, 
                  data: { 
                    ...node.data, 
                    lastPrompt: generationResult.prompt
                  } 
                }
              : node
          )
        );
      }
      
      // Update progress: Finalizing
      setNodes((nds: any) =>
        nds.map((node: any) =>
          node.id === nodeId
            ? { 
                ...node, 
                data: { 
                  ...node.data, 
                  generationProgress: {
                    stage: "Finalizing...",
                    percent: 90
                  }
                } 
              }
            : node
        )
      );

      // Update node with generated content
      console.log("[Canvas] Updating node with generated content");
      if (agentNode.data.type === "thumbnail") {
        console.log("[Canvas] Thumbnail URL to save:", thumbnailUrl ? "Present" : "Missing");
      }
      
      setNodes((nds: any) =>
        nds.map((node: any) =>
          node.id === nodeId
            ? {
                ...node,
                data: {
                  ...node.data,
                  draft: result,
                  thumbnailUrl: thumbnailUrl,
                  status: "ready",
                  generationProgress: undefined, // Clear progress when done
                },
              }
            : node
        )
      );
      
      // Save to database if the node has an agentId
      if (agentNode.data.agentId) {
        await updateAgentDraft({
          id: agentNode.data.agentId as Id<"agents">,
          draft: result,
          status: "ready",
          thumbnailUrl: thumbnailUrl,
          thumbnailStorageId: thumbnailStorageId as Id<"_storage"> | undefined,
        });
      }
      
      if (agentNode.data.type === "thumbnail" && thumbnailUrl) {
        console.log("[Canvas] Thumbnail generation successful with image URL");
        toast.success("Thumbnail generated successfully! Click 'View' to see the image.");
      } else {
        toast.success(`${agentNode.data.type} generated successfully!`);
      }
    } catch (error: any) {
      console.error("[Canvas] Generation error:", error);
      console.error("[Canvas] Error details:", {
        message: error.message,
        stack: error.stack,
        response: error.response
      });
      toast.error(error.message || "Failed to generate content");
      
      // Update status to error
      setNodes((nds: any) =>
        nds.map((node: any) =>
          node.id === nodeId
            ? { 
                ...node, 
                data: { 
                  ...node.data, 
                  status: "error",
                  generationProgress: undefined // Clear progress on error
                } 
              }
            : node
        )
      );
      
      // Update error status in database
      if (agentNode.data.agentId) {
        await updateAgentDraft({
          id: agentNode.data.agentId as Id<"agents">,
          draft: agentNode.data.draft || "",
          status: "error",
        });
      }
    }
  }, [generateContent, generateThumbnail, userProfile, setNodes, updateAgentDraft, projectVideos]);
  
  // Handle thumbnail image upload
  const handleThumbnailUpload = useCallback(async (images: File[]) => {
    if (!pendingThumbnailNode) return;
    
    console.log("[Canvas] Handling thumbnail upload for node:", pendingThumbnailNode);
    console.log("[Canvas] Number of images:", images.length);
    
    // Check if there's a recent regeneration request in chat for this node
    const recentMessages = chatMessages.filter(msg => 
      msg.agentId === pendingThumbnailNode && 
      Date.now() - msg.timestamp < 60000 // Within last minute
    );
    
    const regenerationMessage = recentMessages.find(msg => 
      msg.role === 'user' && msg.content.toLowerCase().includes('regenerate')
    );
    
    // Extract the user's requirements from the regeneration message
    let additionalContext = '';
    if (regenerationMessage) {
      // Remove the @mention and extract the actual requirements
      additionalContext = regenerationMessage.content
        .replace(/@\w+_AGENT/gi, '')
        .replace(/regenerate\s*/gi, '')
        .trim();
      console.log("[Canvas] Found regeneration context:", additionalContext);
    }
    
    // Close modal and reset state
    setThumbnailModalOpen(false);
    
    // Call handleGenerate with the uploaded images and context
    await handleGenerate(pendingThumbnailNode, images, additionalContext);
    
    // Reset pending node
    setPendingThumbnailNode(null);
  }, [pendingThumbnailNode, handleGenerate, chatMessages]);
  
  // Handle video click
  const handleVideoClick = useCallback((videoData: { url: string; title: string; duration?: number; fileSize?: number }) => {
    setSelectedVideo(videoData);
    setVideoModalOpen(true);
  }, []);

  // Handle chat messages with @mentions
  const handleChatMessage = useCallback(async (message: string) => {
    // Extract @mention from message - handle various formats
    const mentionRegex = /@(\w+)[\s_]?(?:AGENT|Agent|agent)?/gi;
    const match = message.match(mentionRegex);
    
    if (!match) {
      // If no mention, just add the message to chat history
      setChatMessages(prev => [...prev, {
        id: `user-${Date.now()}`,
        role: "user",
        content: message,
        timestamp: Date.now(),
      }]);
      
      // Add a general response
      setTimeout(() => {
        setChatMessages(prev => [...prev, {
          id: `ai-${Date.now()}`,
          role: "ai",
          content: "Please @mention a specific agent (e.g., @TITLE_AGENT) to get help with content generation or refinement.",
          timestamp: Date.now(),
        }]);
      }, 500);
      return;
    }
    
    // Find the agent node based on the mention
    const agentType = match[0]
      .replace(/@/gi, "")
      .replace(/[\s_]?(?:AGENT|Agent|agent)/gi, "")
      .toLowerCase()
      .trim();
    const agentNode = nodesRef.current.find((n: any) => n.type === "agent" && n.data.type === agentType);
    
    if (!agentNode || !agentNode.data.agentId) {
      setChatMessages(prev => [...prev, {
        id: `user-${Date.now()}`,
        role: "user",
        content: message,
        timestamp: Date.now(),
      }]);
      
      setTimeout(() => {
        setChatMessages(prev => [...prev, {
          id: `ai-${Date.now()}`,
          role: "ai",
          content: `No ${agentType} agent found in the canvas. Please add one first.`,
          timestamp: Date.now(),
        }]);
      }, 500);
      return;
    }
    
    // Check if agent has no content and user wants to generate
    if (!agentNode.data.draft && (message.toLowerCase().includes('generate') || message.toLowerCase().includes('create'))) {
      // Trigger generation instead of refinement
      await handleGenerate(agentNode.id);
      
      setChatMessages(prev => [...prev, {
        id: `user-${Date.now()}`,
        role: "user",
        content: message,
        timestamp: Date.now(),
        agentId: agentNode.id,
      }]);
      
      return;
    }
    
    // Special handling for thumbnail regeneration
    if (agentNode.data.type === 'thumbnail' && message.toLowerCase().includes('regenerate')) {
      // Store the regeneration request
      setChatMessages(prev => [...prev, {
        id: `user-${Date.now()}`,
        role: "user",
        content: message,
        timestamp: Date.now(),
        agentId: agentNode.id,
      }]);
      
      // Open thumbnail upload modal
      setPendingThumbnailNode(agentNode.id);
      setThumbnailModalOpen(true);
      
      // Add response
      setTimeout(() => {
        setChatMessages(prev => [...prev, {
          id: `ai-${Date.now()}`,
          role: "ai",
          content: `To regenerate the thumbnail, please upload new images in the modal that just opened. I'll use your feedback about making the face more shocked when generating the new thumbnail.`,
          timestamp: Date.now(),
          agentId: agentNode.id,
        }]);
      }, 500);
      
      return;
    }
    
    setIsChatGenerating(true);
    
    // Add user message immediately
    setChatMessages(prev => [...prev, {
      id: `user-${Date.now()}`,
      role: "user",
      content: message,
      timestamp: Date.now(),
      agentId: agentNode.id,
    }]);
    
    try {
      // Find connected video for context
      const connectedVideoEdge = edgesRef.current.find((e: any) => e.target === agentNode.id && e.source?.includes('video'));
      const videoNode = connectedVideoEdge ? nodesRef.current.find((n: any) => n.id === connectedVideoEdge.source) : null;
      
      let videoData: { title?: string; transcription?: string } = {};
      if (videoNode && videoNode.data.videoId) {
        const video = projectVideos?.find((v: any) => v._id === videoNode.data.videoId);
        videoData = {
          title: videoNode.data.title as string,
          transcription: video?.transcription,
        };
      }
      
      // Get relevant chat history for this agent
      const agentHistory = chatMessages.filter(msg => msg.agentId === agentNode.id);
      
      // Get connected agent outputs for context
      const connectedAgentOutputs: Array<{type: string, content: string}> = [];
      const connectedAgentEdges = edgesRef.current.filter((e: any) => e.target === agentNode.id && e.source?.includes('agent'));
      for (const edge of connectedAgentEdges) {
        const connectedAgent = nodesRef.current.find((n: any) => n.id === edge.source);
        if (connectedAgent && connectedAgent.data.draft) {
          connectedAgentOutputs.push({
            type: connectedAgent.data.type,
            content: connectedAgent.data.draft,
          });
        }
      }

      // Check if this is a regeneration request
      const cleanMessage = message.replace(mentionRegex, "").trim();
      const lowerMessage = cleanMessage.toLowerCase();
      
      // Check for various regeneration/modification keywords
      const regenerationKeywords = [
        'regenerate', 'generate again', 'create new', 'make new', 'redo', 
        'try again', 'give me another', 'different version', 'new version',
        'change', 'make', 'create', 'modify', 'update', 'edit'
      ];
      
      const isRegeneration = regenerationKeywords.some(keyword => lowerMessage.includes(keyword)) || 
                            (agentNode.data.draft && lowerMessage.includes('generate'));
      
      // If regenerating, prepend context to the user message
      const finalMessage = isRegeneration && agentNode.data.draft
        ? `REGENERATE the ${agentNode.data.type} with a COMPLETELY NEW version based on the user's instructions. Current version: "${agentNode.data.draft}". User requirements: ${cleanMessage}. Create something different that incorporates their feedback.`
        : cleanMessage;

      // Set node status to generating
      setNodes((nds: any) =>
        nds.map((node: any) =>
          node.id === agentNode.id
            ? {
                ...node,
                data: {
                  ...node.data,
                  status: "generating",
                  generationProgress: {
                    stage: "Refining thumbnail...",
                    percent: 50
                  }
                },
              }
            : node
        )
      );
      
      // Update status in database if we have an agentId
      if (agentNode.data.agentId) {
        await updateAgentDraft({
          id: agentNode.data.agentId as Id<"agents">,
          draft: agentNode.data.draft || "",
          status: "generating",
        });
      }
      
      // Call appropriate refine action based on agent type
      let result: any;
      
      // For thumbnails with existing images, always use refinement (not just for regeneration)
      if (agentNode.data.type === "thumbnail" && agentNode.data.thumbnailUrl) {
        // Use thumbnail-specific refinement that can edit the existing image
        console.log("[Canvas] Using thumbnail refinement with existing image");
        console.log("[Canvas] Agent node data:", agentNode.data);
        console.log("[Canvas] Clean message:", cleanMessage);
        console.log("[Canvas] Is regeneration:", isRegeneration);
        
        // Update progress
        setNodes((nds: any) =>
          nds.map((node: any) =>
            node.id === agentNode.id
              ? {
                  ...node,
                  data: {
                    ...node.data,
                    generationProgress: {
                      stage: "Analyzing current thumbnail...",
                      percent: 30
                    }
                  },
                }
              : node
          )
        );
        
        result = await refineThumbnail({
          agentId: agentNode.data.agentId as Id<"agents">,
          currentThumbnailUrl: agentNode.data.thumbnailUrl,
          userMessage: cleanMessage, // Use clean message, not the REGENERATE prefix
          videoId: videoNode?.data.videoId as Id<"videos"> | undefined,
          profileData: userProfile ? {
            channelName: userProfile.channelName,
            contentType: userProfile.contentType,
            niche: userProfile.niche,
            tone: userProfile.tone,
            targetAudience: userProfile.targetAudience,
          } : undefined,
        });
        
        // Create a response object matching refineContent format
        result = {
          response: result.concept,
          updatedContent: result.concept,
          imageUrl: result.imageUrl,
          storageId: result.storageId,
        };
      } else {
        // Use regular text refinement for other agent types
        result = await refineContent({
          agentId: agentNode.data.agentId as Id<"agents">,
          userMessage: finalMessage,
          currentDraft: agentNode.data.draft || "",
          agentType: agentNode.data.type as "title" | "description" | "thumbnail" | "tweets",
          chatHistory: agentHistory.map(msg => ({
            role: msg.role,
            content: msg.content,
          })),
          videoData,
          profileData: userProfile ? {
            channelName: userProfile.channelName,
            contentType: userProfile.contentType,
            niche: userProfile.niche,
            tone: userProfile.tone,
            targetAudience: userProfile.targetAudience,
          } : undefined,
        });
      }
      
      // Add AI response
      setChatMessages(prev => [...prev, {
        id: `ai-${Date.now()}`,
        role: "ai",
        content: result.response,
        timestamp: Date.now(),
        agentId: agentNode.id,
      }]);
      
      // Update node with new draft and thumbnail URL if applicable
      setNodes((nds: any) =>
        nds.map((node: any) =>
          node.id === agentNode.id
            ? {
                ...node,
                data: {
                  ...node.data,
                  draft: result?.updatedContent || result?.updatedDraft || node.data.draft,
                  status: "ready",
                  ...(result?.imageUrl && { thumbnailUrl: result.imageUrl }),
                },
              }
            : node
        )
      );
      
      // Save to database if it's a thumbnail with a new image
      if (agentNode.data.type === "thumbnail" && result?.imageUrl && agentNode.data.agentId) {
        await updateAgentDraft({
          id: agentNode.data.agentId as Id<"agents">,
          draft: result?.updatedContent || result?.updatedDraft || agentNode.data.draft || "",
          status: "ready",
          thumbnailUrl: result.imageUrl,
          thumbnailStorageId: result?.storageId as Id<"_storage"> | undefined,
        });
      }
      
      // Add a helpful tip if this was their first generation
      if (!agentNode.data.draft && !isRegeneration) {
        setTimeout(() => {
          setChatMessages(prev => [...prev, {
            id: `tip-${Date.now()}`,
            role: "ai",
            content: `üí° Tip: You can regenerate this ${agentNode.data.type} anytime by mentioning @${agentNode.data.type.toUpperCase()}_AGENT and describing what changes you want. For example: "@${agentNode.data.type.toUpperCase()}_AGENT make it more casual" or "@${agentNode.data.type.toUpperCase()}_AGENT try again with a focus on benefits"`,
            timestamp: Date.now(),
            agentId: agentNode.id,
          }]);
        }, 1000);
      }
      
    } catch (error: any) {
      console.error("Chat error:", error);
      
      // Reset node status on error
      setNodes((nds: any) =>
        nds.map((node: any) =>
          node.id === agentNode.id
            ? {
                ...node,
                data: {
                  ...node.data,
                  status: "error",
                  generationProgress: undefined
                },
              }
            : node
        )
      );
      
      // Update error status in database
      if (agentNode.data.agentId) {
        await updateAgentDraft({
          id: agentNode.data.agentId as Id<"agents">,
          draft: agentNode.data.draft || "",
          status: "error",
        });
      }
      
      // Add error message to chat
      setChatMessages(prev => [...prev, {
        id: `ai-error-${Date.now()}`,
        role: "ai",
        content: `‚ùå Sorry, I encountered an error: ${error.message || "Failed to process your request"}. Please try again or generate a new thumbnail if the issue persists.`,
        timestamp: Date.now(),
        agentId: agentNode.id,
      }]);
      
      toast.error("Failed to process chat message");
      
      setChatMessages(prev => [...prev, {
        id: `ai-${Date.now()}`,
        role: "ai",
        content: "Sorry, I encountered an error processing your request. Please try again.",
        timestamp: Date.now(),
        agentId: agentNode.id,
      }]);
    } finally {
      setIsChatGenerating(false);
    }
  }, [chatMessages, projectVideos, userProfile, refineContent, setNodes]);

  // Handle chat button click - add @mention to input
  const handleChatButtonClick = useCallback((nodeId: string) => {
    const agentNode = nodesRef.current.find((n: any) => n.id === nodeId);
    if (!agentNode || agentNode.type !== 'agent') return;
    
    const agentType = agentNode.data.type as string;
    const mention = `@${agentType.toUpperCase()}_AGENT `;
    
    // Add mention to chat input
    setChatInput(mention);
    // Clear it after a short delay to prevent continuous updates
    setTimeout(() => setChatInput(''), 100);
  }, []);

  // Handle regenerate button click - immediate regeneration
  const handleRegenerateClick = useCallback(async (nodeId: string) => {
    const agentNode = nodesRef.current.find((n: any) => n.id === nodeId);
    if (!agentNode || agentNode.type !== 'agent') return;
    
    const agentType = agentNode.data.type as string;
    
    // Special handling for thumbnail regeneration - needs new images
    if (agentType === 'thumbnail') {
      // Open thumbnail upload modal for new images
      setPendingThumbnailNode(nodeId);
      setThumbnailModalOpen(true);
      
      // Add a context message to the chat
      setChatMessages(prev => [...prev, {
        id: `system-${Date.now()}`,
        role: "ai",
        content: `Upload new images for thumbnail regeneration. The previous concept was: "${agentNode.data.draft?.slice(0, 200)}..."`,
        timestamp: Date.now(),
        agentId: nodeId,
      }]);
    } else {
      // For other agents, trigger immediate regeneration
      toast.info(`Regenerating ${agentType}...`);
      
      // Add a system message to chat history
      setChatMessages(prev => [...prev, {
        id: `system-${Date.now()}`,
        role: "ai",
        content: `üîÑ Regenerating ${agentType} content...`,
        timestamp: Date.now(),
        agentId: nodeId,
      }]);
      
      try {
        // Call handleGenerate directly for immediate regeneration
        await handleGenerate(nodeId);
        
        // Add success message to chat
        setChatMessages(prev => [...prev, {
          id: `system-${Date.now()}`,
          role: "ai",
          content: `‚ú® Successfully regenerated ${agentType} content! The new version is ready.`,
          timestamp: Date.now(),
          agentId: nodeId,
        }]);
      } catch (error) {
        console.error("Regeneration failed:", error);
        toast.error(`Failed to regenerate ${agentType}`);
        
        // Add error message to chat
        setChatMessages(prev => [...prev, {
          id: `system-${Date.now()}`,
          role: "ai",
          content: `‚ùå Failed to regenerate ${agentType}. Please try again.`,
          timestamp: Date.now(),
          agentId: nodeId,
        }]);
      }
    }
  }, [handleGenerate]);

  // Generate content for all agent nodes (connect if needed)
  const handleGenerateAll = useCallback(async () => {
    // Find video node
    const videoNode = nodes.find((node: any) => node.type === 'video');
    if (!videoNode) {
      toast.error("Please add a video first!");
      return;
    }
    
    // Find all agent nodes
    const agentNodes = nodes.filter((node: any) => node.type === 'agent');
    if (agentNodes.length === 0) {
      toast.error("No agent nodes found!");
      return;
    }
    
    setIsGeneratingAll(true);
    setGenerationProgress({ current: 0, total: agentNodes.length });
    
    // Ensure all agents are connected to video node
    agentNodes.forEach((agentNode: any) => {
      const existingEdge = edges.find((edge: any) => 
        edge.source === videoNode.id && edge.target === agentNode.id
      );
      
      if (!existingEdge) {
        const newEdge: Edge = {
          id: `e${videoNode.id}-${agentNode.id}`,
          source: videoNode.id,
          target: agentNode.id,
          animated: enableEdgeAnimations && !isDragging,
        };
        setEdges((eds: any) => [...eds, newEdge]);
        
        // Update agent connections in database
        if (agentNode.data.agentId) {
          updateAgentConnections({
            id: agentNode.data.agentId as Id<"agents">,
            connections: [videoNode.data.videoId as string],
          }).catch((error: any) => {
            console.error("Failed to update agent connections:", error);
          });
        }
      }
    });
    
    // Generate content for each agent (skip thumbnail nodes)
    let processedCount = 0;
    for (let i = 0; i < agentNodes.length; i++) {
      const agentNode = agentNodes[i];
      
      if (agentNode.data.type === "thumbnail") {
        console.log("[Canvas] Skipping thumbnail node in Generate All:", agentNode.id);
        toast.info("Thumbnail generation requires manual image upload");
        continue;
      }
      
      processedCount++;
      setGenerationProgress({ current: processedCount, total: agentNodes.length });
      
      try {
        await handleGenerate(agentNode.id);
      } catch (error) {
        console.error(`Failed to generate content for ${agentNode.data.type}:`, error);
        toast.error(`Failed to generate ${agentNode.data.type}`);
      }
    }
    
    setIsGeneratingAll(false);
    setGenerationProgress({ current: 0, total: 0 });
    toast.success("All content generated successfully!");
  }, [nodes, edges, setEdges, handleGenerate, updateAgentConnections]);

  const onConnect: OnConnect = useCallback(
    (params) => {
      const sourceNode = nodes.find((n: any) => n.id === params.source);
      const targetNode = nodes.find((n: any) => n.id === params.target);
      
      // Allow connections from video to agent or agent to agent
      if (!sourceNode || !targetNode) return;
      
      if (
        (sourceNode.type === 'video' && targetNode.type === 'agent') ||
        (sourceNode.type === 'agent' && targetNode.type === 'agent')
      ) {
        setEdges((eds: any) => addEdge(params, eds));
        
        // Update agent connections in database
        if (targetNode.data.agentId && sourceNode.data.videoId) {
          const currentConnections = targetNode.data.connections || [];
          const newConnections = [...currentConnections, sourceNode.data.videoId];
          
          updateAgentConnections({
            id: targetNode.data.agentId as Id<"agents">,
            connections: newConnections,
          }).catch((error: any) => {
            console.error("Failed to update agent connections:", error);
          });
          
          // Update node data
          setNodes((nds: any) =>
            nds.map((node: any) =>
              node.id === targetNode.id
                ? {
                    ...node,
                    data: {
                      ...node.data,
                      connections: newConnections,
                    },
                  }
                : node
            )
          );
        }
      }
    },
    [nodes, setEdges, setNodes, updateAgentConnections]
  );
  
  // Perform the actual deletion
  const performDeletion = useCallback(
    async (nodes: Node[]) => {
      for (const node of nodes) {
        try {
          if (node.type === 'video' && node.data.videoId) {
            // Delete video from database (this also deletes associated agents)
            await deleteVideo({ id: node.data.videoId as Id<"videos"> });
            toast.success("Video and associated content deleted");
            
          } else if (node.type === 'agent' && node.data.agentId) {
            // Delete agent from database
            await deleteAgent({ id: node.data.agentId as Id<"agents"> });
            toast.success("Agent deleted");
          }
        } catch (error) {
          console.error("Failed to delete node:", error);
          toast.error("Failed to delete node");
          
          // Re-add the node if deletion failed
          setNodes((nds: any) => [...nds, node]);
        }
      }
    },
    [deleteVideo, deleteAgent, setNodes]
  );
  
  // Handle share functionality
  const handleShare = useCallback(async () => {
    try {
      // Get current canvas state
      const canvasNodes = nodes.map((node: any) => {
        const cleanedData: any = {};
        
        // Only copy serializable properties
        for (const [key, value] of Object.entries(node.data)) {
          if (typeof value !== 'function' && key !== 'onGenerate' && key !== 'onRegenerate' && 
              key !== 'onChat' && key !== 'onView' && key !== 'onViewPrompt' && 
              key !== 'onRetryTranscription' && key !== 'onVideoClick') {
            cleanedData[key] = value;
          }
        }
        
        return {
          id: node.id,
          type: node.type,
          position: node.position,
          data: cleanedData
        };
      });

      const canvasEdges = edges.map((edge: any) => ({
        id: edge.id,
        source: edge.source,
        target: edge.target,
        type: edge.type,
      }));

      // Create share link
      const shareId = await createShareLink({
        projectId,
        canvasState: {
          nodes: canvasNodes,
          edges: canvasEdges,
          viewport: {
            x: 0,
            y: 0,
            zoom: 1,
          }
        }
      });

      // Build share URL
      const shareUrl = `${window.location.origin}/share/${shareId}`;
      
      // Copy to clipboard
      await navigator.clipboard.writeText(shareUrl);
      setCopiedShareLink(true);
      toast.success("Share link copied to clipboard!");
      
      // Reset copied state after 3 seconds
      setTimeout(() => setCopiedShareLink(false), 3000);
    } catch (error) {
      console.error("Failed to create share link:", error);
      toast.error("Failed to create share link");
    }
  }, [createShareLink, projectId, nodes, edges]);
  
  // Handle node deletion
  const onNodesDelete = useCallback(
    (nodes: Node[]) => {
      console.log("üóëÔ∏è Nodes marked for deletion:", nodes);
      console.log("Node types:", nodes.map(n => n.type));
      
      // Check if any nodes have important data
      const hasVideo = nodes.some((n: any) => n.type === 'video');
      const hasAgent = nodes.some((n: any) => n.type === 'agent' && n.data.draft);
      
      if (hasVideo || hasAgent) {
        // Store nodes for deletion and show dialog
        setNodesToDelete(nodes);
        setDeleteDialogOpen(true);
        return false; // Prevent React Flow from deleting immediately
      } else {
        // For non-important nodes (like videoInfo), delete immediately
        performDeletion(nodes);
        return true;
      }
    },
    [performDeletion]
  );
  
  // Handle deletion confirmation
  const handleDeleteConfirm = useCallback(() => {
    performDeletion(nodesToDelete);
    // Remove nodes from React Flow
    setNodes((nds: any) => 
      nds.filter((node: any) => !nodesToDelete.some(n => n.id === node.id))
    );
    setDeleteDialogOpen(false);
    setNodesToDelete([]);
  }, [nodesToDelete, performDeletion, setNodes]);

  // Find non-overlapping position for new nodes
  const findNonOverlappingPosition = useCallback((desiredPos: { x: number; y: number }, nodeType: string) => {
    const nodeWidth = nodeType === 'video' ? 200 : 150;
    const nodeHeight = nodeType === 'video' ? 120 : 50;
    const spacing = 20;
    
    // Check if position overlaps with any existing node
    const checkOverlap = (pos: { x: number; y: number }) => {
      return nodes.some((node: any) => {
        const existingWidth = node.type === 'video' ? 200 : 150;
        const existingHeight = node.type === 'video' ? 120 : 50;
        
        return (
          pos.x < node.position.x + existingWidth + spacing &&
          pos.x + nodeWidth + spacing > node.position.x &&
          pos.y < node.position.y + existingHeight + spacing &&
          pos.y + nodeHeight + spacing > node.position.y
        );
      });
    };
    
    // If no overlap, return desired position
    if (!checkOverlap(desiredPos)) {
      return desiredPos;
    }
    
    // Otherwise, find nearest free position using spiral search
    const step = 30;
    let distance = 1;
    
    while (distance < 10) {
      // Try positions in a spiral pattern
      const positions = [
        { x: desiredPos.x + step * distance, y: desiredPos.y },
        { x: desiredPos.x - step * distance, y: desiredPos.y },
        { x: desiredPos.x, y: desiredPos.y + step * distance },
        { x: desiredPos.x, y: desiredPos.y - step * distance },
        { x: desiredPos.x + step * distance, y: desiredPos.y + step * distance },
        { x: desiredPos.x - step * distance, y: desiredPos.y - step * distance },
        { x: desiredPos.x + step * distance, y: desiredPos.y - step * distance },
        { x: desiredPos.x - step * distance, y: desiredPos.y + step * distance },
      ];
      
      for (const pos of positions) {
        if (!checkOverlap(pos)) {
          return pos;
        }
      }
      
      distance++;
    }
    
    // If no free position found, offset significantly
    return {
      x: desiredPos.x + 200,
      y: desiredPos.y + 100
    };
  }, [nodes]);

  // Handle content update from modal
  const handleContentUpdate = async (nodeId: string, newContent: string) => {
    const node = nodes.find((n: any) => n.id === nodeId);
    if (!node) return;
    
    setNodes((nds: any) =>
      nds.map((node: any) =>
        node.id === nodeId
          ? { ...node, data: { ...node.data, draft: newContent } }
          : node
      )
    );
    
    // Save to database if it's an agent with an ID
    if (node.type === 'agent' && node.data.agentId) {
      try {
        await updateAgentDraft({
          id: node.data.agentId as Id<"agents">,
          draft: newContent,
          status: "ready",
        });
        toast.success("Content updated!");
      } catch (error) {
        console.error("Failed to update agent content:", error);
        toast.error("Failed to save content");
      }
    } else {
      toast.success("Content updated!");
    }
  };


  // Handle video file upload
  const handleVideoUpload = async (file: File, position: { x: number; y: number }, retryCount = 0) => {
    const MAX_RETRIES = 2;
    try {
      // Create a temporary node with loading state
      const tempNodeId = `video_temp_${Date.now()}`;
      const tempNode: Node = {
        id: tempNodeId,
        type: "video",
        position,
        data: {
          title: file.name.replace(/\.[^/.]+$/, ""),
          isUploading: true,
        },
      };
      setNodes((nds: any) => nds.concat(tempNode));

      // Validate file before upload
      const MAX_FILE_SIZE = 1024 * 1024 * 1024; // 1GB limit for ElevenLabs
      
      if (file.size > MAX_FILE_SIZE) {
        // Remove the temporary node since upload won't proceed
        setNodes((nds: any) => nds.filter((n: any) => n.id !== tempNodeId));
        
        const fileSizeMB = (file.size / 1024 / 1024).toFixed(1);
        toast.error("Video file too large", {
          description: `Your video is ${fileSizeMB}MB but the maximum allowed size is 1GB. Please use a shorter clip or compress your video.`,
          duration: 8000,
          action: {
            label: "Learn more",
            onClick: () => window.open("https://handbrake.fr/", "_blank")
          }
        });
        
        // Throw error for proper error handling
        throw new Error(`File is too large (${fileSizeMB}MB). Maximum size is 1GB.`);
      }
      
      // Show warning for large files
      if (file.size > 100 * 1024 * 1024) {
        const largeFileSizeMB = (file.size / 1024 / 1024).toFixed(1);
        toast.warning("Large file detected", {
          description: `Your ${largeFileSizeMB}MB video may have issues with transcription due to memory limits. Consider using a smaller file.`,
          duration: 6000,
        });
      }

      // Check video format
      const supportedFormats = ['video/mp4', 'video/quicktime', 'video/x-msvideo', 'video/webm', 'video/mov'];
      if (!supportedFormats.includes(file.type) && !file.name.match(/\.(mp4|mov|avi|webm)$/i)) {
        // Remove the temporary node since upload won't proceed
        setNodes((nds: any) => nds.filter((n: any) => n.id !== tempNodeId));
        
        toast.error("Unsupported video format", {
          description: "Please upload MP4, MOV, AVI, or WebM files. Other formats are not supported.",
          duration: 6000,
        });
        
        throw new Error('Unsupported video format. Please upload MP4, MOV, AVI, or WebM files.');
      }

      // Step 1: Create video record in database first
      console.log("Creating video record in database...");
      const video = await createVideo({
        projectId,
        title: file.name.replace(/\.[^/.]+$/, ""),
        canvasPosition: position,
      });
      
      console.log("Video created:", video);
      if (!video || !video._id) {
        throw new Error("Failed to create video record in database. Please try again.");
      }
      
      // Step 2: Upload to Convex storage
      console.log("Uploading to Convex storage...");
      const uploadUrl = await generateUploadUrl();
      const uploadResult = await fetch(uploadUrl, {
        method: "POST",
        headers: { "Content-Type": file.type },
        body: file,
      });
      
      if (!uploadResult.ok) {
        throw new Error("Upload to Convex failed");
      }
      
      const { storageId } = await uploadResult.json();
      console.log("File uploaded to Convex storage:", storageId);
      
      // Step 3: Update video with storage ID (this also updates the videoUrl)
      await updateVideoStorageId({
        id: video._id,
        storageId,
      });
      
      // Step 4: Create a temporary blob URL to show video immediately
      // The actual URL will be set when updateVideoStorageId completes and projectVideos refreshes
      const temporaryUrl = URL.createObjectURL(file);
      
      // Clean up the blob URL after a delay (once the real URL should be available)
      setTimeout(() => {
        URL.revokeObjectURL(temporaryUrl);
      }, 30000); // Clean up after 30 seconds
      
      // Step 5: Update node with real data including video URL
      setNodes((nds: any) => 
        nds.map((node: any) => 
          node.id === tempNodeId
            ? {
                ...node,
                id: `video_${video._id}`,
                data: {
                  ...node.data,
                  isUploading: false,
                  videoId: video._id,
                  storageId: storageId,
                  videoUrl: temporaryUrl,
                  // Using Convex storage exclusively
                  title: video.title,
                  isTranscribing: true,
                  onVideoClick: () => handleVideoClick({
                    url: temporaryUrl,
                    title: video.title || "Untitled Video",
                    duration: undefined, // Will be populated after metadata extraction
                    fileSize: file.size,
                  })
                },
              }
            : node
        )
      );
      
      toast.success("Video uploaded successfully!", {
        description: `${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB)`,
      });
      
      // Update node to show transcribing state immediately
      setNodes((nds: any) =>
        nds.map((node: any) =>
          node.id === `video_${video._id}`
            ? {
                ...node,
                data: {
                  ...node.data,
                  isTranscribing: true,
                  onVideoClick: node.data.onVideoClick, // Preserve the click handler
                },
              }
            : node
        )
      );
      
      // Step 6: Extract video metadata (optional, non-blocking)
      console.log("Starting optional metadata extraction for video:", video._id);
      // Run metadata extraction in parallel, don't block transcription
      (async () => {
        try {
          
          // Extract metadata with timeout
          console.log("Calling extractVideoMetadata...");
          
          let metadata: any;
          try {
            // Set a timeout for metadata extraction
            const metadataPromise = extractVideoMetadata(file, {
              onProgress: (progress) => {
                console.log("Metadata extraction progress:", progress);
              },
              extractThumbnails: false, // Disable thumbnails for now to speed up
              useFFmpeg: false, // Disable FFmpeg to avoid loading issues
            });
            
            const timeoutPromise = new Promise<never>((_, reject) => {
              setTimeout(() => reject(new Error("Metadata extraction timeout")), 15000); // 15 second timeout
            });
            
            metadata = await Promise.race([metadataPromise, timeoutPromise]);
            console.log("Metadata extracted:", metadata);
          } catch (metadataError) {
            console.error("Metadata extraction failed, using basic info:", metadataError);
            // Use basic metadata as fallback
            metadata = {
              duration: 0,
              fileSize: file.size,
              resolution: { width: 0, height: 0 },
              frameRate: 0,
              bitRate: 0,
              format: file.type.split('/')[1] || 'unknown',
              codec: 'unknown',
              thumbnails: []
            };
            
            // Show info message but don't fail the upload
            toast.info("Video details couldn't be extracted", {
              description: "The video was uploaded successfully, but some information may be missing.",
            });
          }
          
          // Update video in database with metadata
          await updateVideoMetadata({
            id: video._id,
            duration: metadata.duration,
            fileSize: metadata.fileSize,
            resolution: metadata.resolution,
            frameRate: metadata.frameRate,
            bitRate: metadata.bitRate,
            format: metadata.format,
            codec: metadata.codec,
            audioInfo: metadata.audioInfo,
          });
          
          // Update video node with metadata
          setNodes((nds: any) =>
            nds.map((node: any) => {
              if (node.id === `video_${video._id}`) {
                return {
                  ...node,
                  data: {
                    ...node.data,
                    duration: metadata.duration,
                    fileSize: metadata.fileSize,
                    onVideoClick: () => handleVideoClick({
                      url: node.data.videoUrl!,
                      title: node.data.title || "Untitled Video",
                      duration: metadata.duration,
                      fileSize: metadata.fileSize,
                    }),
                  },
                };
              }
              return node;
            })
          );
          
          // Only show success if we got real metadata
          if (metadata.duration > 0 || metadata.resolution.width > 0) {
            toast.success("Video information extracted!");
          }
        } catch (metadataError: any) {
          console.error("Metadata extraction error:", metadataError);
          
          // Handle metadata error gracefully
          handleVideoError(metadataError, 'Metadata Extraction');
          
          // Continue with upload even if metadata fails
          toast.warning("Could not extract all video information");
        }
      })();
      
      console.log("Moving to transcription step...");
      
      // Step 6: Transcribe video
      const fileSizeMB = file.size / (1024 * 1024);
      
      console.log(`Video file size: ${fileSizeMB.toFixed(2)}MB`);
      
      // Small delay to ensure file is available in storage
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      try {
        // The backend will automatically use ElevenLabs if available (supports 1GB)
        // Skip audio extraction entirely - let ElevenLabs handle large files directly
        const SKIP_AUDIO_EXTRACTION = true; // Always use direct transcription with ElevenLabs
        
        if (fileSizeMB > 1024) {
          // File is over 1GB - ElevenLabs limit
          throw new Error(`File is too large for transcription (${fileSizeMB.toFixed(1)}MB). Maximum size is 1GB.`);
        }
        
        if (false && fileSizeMB > 25 && !SKIP_AUDIO_EXTRACTION) {
          // For large files, we'll extract audio (unless backend has ElevenLabs)
          toast.info("Processing large video for transcription...");
          
          // Update node to show extraction status
          setNodes((nds: any) =>
            nds.map((node: any) =>
              node.id === `video_${video._id}`
                ? {
                    ...node,
                    data: {
                      ...node.data,
                      isTranscribing: false,
                      isExtracting: true,
                      extractionProgress: 0,
                    },
                  }
                : node
            )
          );
          
          // Extract audio from video
          const audioFile = await extractAudioFromVideo(file, (progress) => {
              setNodes((nds: any) =>
                nds.map((node: any) =>
                  node.id === `video_${video._id}`
                    ? {
                        ...node,
                        data: {
                          ...node.data,
                          extractionProgress: Math.round(progress * 100),
                        },
                      }
                    : node
                )
              );
            });
          
          // Skip audio upload - Convex handles everything
          // This code path should not be reached since we skip audio extraction
          throw new Error("Audio extraction is no longer supported. Please use smaller video files.");
          
          // Update node to show transcription status
          setNodes((nds: any) =>
            nds.map((node: any) =>
              node.id === `video_${video._id}`
                ? {
                    ...node,
                    data: {
                      ...node.data,
                      isExtracting: false,
                      isTranscribing: true,
                    },
                  }
                : node
            )
          );
          
          // Schedule background transcription
          try {
            console.log("Scheduling audio transcription for video:", video._id);
            const result = await scheduleTranscription({
              videoId: video._id,
              storageId: audioStorageId,
              fileType: "audio",
              fileSize: audioFile.size,
              fileName: "audio.mp3",
            });
            console.log("Schedule transcription result:", result);
            
            toast.info("Audio transcription started in background. It will continue even if you close this tab.");
          } catch (scheduleError: any) {
            console.error("Failed to schedule transcription:", scheduleError);
            console.error("Error details:", scheduleError.message, scheduleError.stack);
            
            // Don't throw - transcription failure shouldn't fail the whole upload
            toast.error("Transcription couldn't start", {
              description: "The video was uploaded but transcription failed. You can try again later.",
            });
            
            // Update node to show transcription failed
            setNodes((nds: any) =>
              nds.map((node: any) =>
                node.id === `video_${video._id}`
                  ? {
                      ...node,
                      data: {
                        ...node.data,
                        isTranscribing: false,
                        isExtracting: false,
                        hasTranscription: false,
                        transcriptionError: scheduleError.message,
                        onRetryTranscription: () => retryTranscription(video._id),
                      },
                    }
                  : node
              )
            );
          }
        } else {
          // Client-side transcription with ElevenLabs
          try {
            console.log("Starting client-side transcription for video:", video._id);
            
            // Show transcription started message
            toast.info("Video transcription started", {
              description: `Processing ${file.name}...`,
            });
            
            // Check if file needs compression
            let fileToTranscribe = file;
            if (isFileTooLarge(file, 20)) {
              const fileSizeMB = getFileSizeMB(file);
              toast.info(`Compressing ${fileSizeMB.toFixed(1)}MB file for transcription...`);
              
              try {
                const compressedBlob = await compressAudioFile(file, {
                  targetBitrate: 64, // 64 kbps for speech
                  targetSampleRate: 16000, // 16 kHz for speech recognition
                  mono: true // Mono is sufficient for transcription
                });
                
                fileToTranscribe = new File([compressedBlob], file.name, { type: 'audio/wav' });
                const compressedSizeMB = getFileSizeMB(fileToTranscribe);
                toast.success(`Compressed to ${compressedSizeMB.toFixed(1)}MB`);
              } catch (compressionError) {
                console.error("Audio compression failed:", compressionError);
                toast.warning("Compression failed, attempting with original file...");
              }
            }
            
            // Create FormData for ElevenLabs
            const formData = new FormData();
            formData.append("file", fileToTranscribe);
            formData.append("model_id", "scribe_v1");
            
            // Get the Convex site URL - it should be in format https://xxxxx.convex.site
            const convexUrl = import.meta.env.VITE_CONVEX_URL;
            let siteUrl = '';
            if (convexUrl) {
              // Extract the deployment name from the URL
              const match = convexUrl.match(/https:\/\/([^.]+)\.convex\.cloud/);
              if (match) {
                siteUrl = `https://${match[1]}.convex.site`;
              }
            }
            const transcribeUrl = `${siteUrl}/api/transcribe`;
            
            console.log("Calling transcription API:", transcribeUrl);
            
            if (!siteUrl) {
              throw new Error("Could not determine Convex site URL. Please check your environment configuration.");
            }
            
            // Call our proxy endpoint
            const transcriptionResponse = await fetch(transcribeUrl, {
              method: "POST",
              body: formData,
            });
            
            if (!transcriptionResponse.ok) {
              const errorText = await transcriptionResponse.text();
              console.error("Transcription API error:", errorText);
              throw new Error(`Transcription failed: ${transcriptionResponse.status}`);
            }
            
            const transcriptionResult = await transcriptionResponse.json();
            console.log("Transcription result:", transcriptionResult);
            
            // Check if ElevenLabs couldn't detect speech
            if (transcriptionResult.text === "We couldn't transcribe the audio. The video might be silent or in an unsupported language.") {
              throw new Error("No speech detected. The video might be silent, have no audio track, or use an unsupported language.");
            }
            
            // Update the video with transcription
            if (transcriptionResult.text && transcriptionResult.text.trim().length > 0) {
              await updateVideo({
                id: video._id,
                transcription: transcriptionResult.text,
              });
              
              // Update node to show transcription complete
              setNodes((nds: any) =>
                nds.map((node: any) =>
                  node.id === `video_${video._id}`
                    ? {
                        ...node,
                        data: {
                          ...node.data,
                          isTranscribing: false,
                          hasTranscription: true,
                          transcriptionError: null,
                        },
                      }
                    : node
                )
              );
              
              toast.success("Video transcription completed!");
            } else {
              throw new Error("No transcription text received. The video might not contain any speech.");
            }
          } catch (transcriptionError: any) {
            console.error("Failed to transcribe:", transcriptionError);
            console.error("Error details:", transcriptionError.message, transcriptionError.stack);
            
            // Video status will be updated by the node state
            
            // Update node to show transcription failed
            setNodes((nds: any) =>
              nds.map((node: any) =>
                node.id === `video_${video._id}`
                  ? {
                      ...node,
                      data: {
                        ...node.data,
                        isTranscribing: false,
                        isExtracting: false,
                        hasTranscription: false,
                        transcriptionError: transcriptionError.message,
                        onRetryTranscription: () => retryTranscription(video._id),
                      },
                    }
                  : node
              )
            );
            
            // Don't throw - transcription failure shouldn't fail the whole upload
            if (transcriptionError.message.includes("No speech detected")) {
              toast.warning("No speech detected", {
                description: "The video was uploaded but appears to be silent or in an unsupported language. Try a different video with clear speech.",
                duration: 8000,
              });
            } else {
              toast.error("Transcription failed", {
                description: "The video was uploaded successfully. You can retry transcription later.",
              });
            }
          }
        }
        
        // Note: The transcription status will be updated when we reload from DB
        // For now, keep showing the transcribing state
      } catch (transcriptionError: any) {
        console.error("Transcription error:", transcriptionError);
        
        // Handle transcription errors gracefully
        const errorDetails = handleVideoError(transcriptionError, 'Transcription');
        
        // Update node to show transcription failed
        setNodes((nds: any) =>
          nds.map((node: any) =>
            node.id === `video_${video._id}`
              ? {
                  ...node,
                  data: {
                    ...node.data,
                    isTranscribing: false,
                    isExtracting: false,
                    hasTranscription: false,
                    transcriptionError: errorDetails.message,
                    onRetryTranscription: () => retryTranscription(video._id),
                  },
                }
              : node
          )
        );
      }
    } catch (error: any) {
      console.error("Upload error:", error);
      console.error("Full error details:", error.stack);
      
      // Handle the error with our error handler
      const errorDetails = handleVideoError(error, 'Upload');
      
      // Remove the temporary node on error
      setNodes((nds: any) => nds.filter((node: any) => !node.id.startsWith('video_temp_')));
      
      // If recoverable and haven't exceeded retries, show retry option
      if (errorDetails.recoverable && retryCount < MAX_RETRIES) {
        const retryAction = createRetryAction(() => {
          handleVideoUpload(file, position, retryCount + 1);
        });
        
        toast.error(errorDetails.message, {
          description: errorDetails.details,
          duration: 8000,
          action: retryAction,
        });
      }
    }
  };

  // Retry transcription for a failed video
  // Create refs for viewport saving
  const viewportRef = useRef<{ x: number; y: number; zoom: number } | null>(null);
  const viewportSaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  // Handle viewport changes - debounced save
  const onViewportChange = useCallback((viewport: { x: number; y: number; zoom: number }) => {
    // Store the latest viewport
    viewportRef.current = viewport;
    
    // Clear existing timeout
    if (viewportSaveTimeoutRef.current) {
      clearTimeout(viewportSaveTimeoutRef.current);
    }
    
    // Set new timeout to save viewport
    if (projectId && hasInitializedViewport && hasLoadedFromDB) {
      viewportSaveTimeoutRef.current = setTimeout(() => {
        console.log("Saving viewport after change:", viewport);
        // Only update viewport in the canvas state
        const currentCanvasState = canvasState || { nodes: [], edges: [], viewport: { x: 0, y: 0, zoom: 1 } };
        saveCanvasState({
          projectId,
          nodes: currentCanvasState.nodes,
          edges: currentCanvasState.edges,
          viewport: {
            x: viewport.x,
            y: viewport.y,
            zoom: viewport.zoom,
          },
        }).catch((error) => {
          console.error("Failed to save viewport:", error);
        });
      }, 1000); // Save after 1 second of no viewport changes
    }
  }, [projectId, hasInitializedViewport, hasLoadedFromDB, canvasState, saveCanvasState]);

  const retryTranscription = async (videoId: string) => {
    try {
      const video = nodes.find((n: any) => n.id === `video_${videoId}`)?.data;
      const videoRecord = projectVideos?.find(v => v._id === videoId);
      
      if (!video && !videoRecord) {
        toast.error("Cannot retry: Video data not found");
        return;
      }
      
      // Check if we have storage ID
      const storageId = video?.storageId || videoRecord?.storageId;
      
      if (!storageId) {
        toast.error("Cannot retry: Storage ID not found");
        return;
      }

      // Clear the old transcription first
      await updateVideo({
        id: videoId as any,
        clearTranscription: true,
      });

      // Update node to show transcribing state
      setNodes((nds: any) =>
        nds.map((node: any) =>
          node.id === `video_${videoId}`
            ? {
                ...node,
                data: {
                  ...node.data,
                  isTranscribing: true,
                  hasTranscription: false,
                  transcriptionError: null,
                  transcriptionProgress: null,
                },
              }
            : node
        )
      );

      // Get the video file from storage for client-side transcription
      if (storageId && videoRecord?.videoUrl) {
        toast.info("Downloading video for transcription...");
        
        try {
          // Download the video file
          const response = await fetch(videoRecord.videoUrl);
          if (!response.ok) {
            throw new Error("Failed to download video");
          }
          
          const blob = await response.blob();
          const file = new File([blob], video?.title || "video.mp4", { type: blob.type });
          
          // Check if file needs compression
          let fileToTranscribe = file;
          if (isFileTooLarge(file, 20)) {
            const fileSizeMB = getFileSizeMB(file);
            toast.info(`Compressing ${fileSizeMB.toFixed(1)}MB file for transcription...`);
            
            try {
              const compressedBlob = await compressAudioFile(file, {
                targetBitrate: 64, // 64 kbps for speech
                targetSampleRate: 16000, // 16 kHz for speech recognition
                mono: true // Mono is sufficient for transcription
              });
              
              fileToTranscribe = new File([compressedBlob], file.name, { type: 'audio/wav' });
              const compressedSizeMB = getFileSizeMB(fileToTranscribe);
              toast.success(`Compressed to ${compressedSizeMB.toFixed(1)}MB`);
            } catch (compressionError) {
              console.error("Audio compression failed:", compressionError);
              toast.warning("Compression failed, attempting with original file...");
            }
          }
          
          // Create FormData for ElevenLabs
          const formData = new FormData();
          formData.append("file", fileToTranscribe);
          formData.append("model_id", "scribe_v1");
          
          // Get the Convex site URL - it should be in format https://xxxxx.convex.site
          const convexUrl = import.meta.env.VITE_CONVEX_URL;
          let siteUrl = '';
          if (convexUrl) {
            // Extract the deployment name from the URL
            const match = convexUrl.match(/https:\/\/([^.]+)\.convex\.cloud/);
            if (match) {
              siteUrl = `https://${match[1]}.convex.site`;
            }
          }
          const transcribeUrl = `${siteUrl}/api/transcribe`;
          
          if (!siteUrl) {
            throw new Error("Could not determine Convex site URL. Please check your environment configuration.");
          }
          
          // Call our proxy endpoint
          const transcriptionResponse = await fetch(transcribeUrl, {
            method: "POST",
            body: formData,
          });
          
          if (!transcriptionResponse.ok) {
            const errorText = await transcriptionResponse.text();
            throw new Error(`Transcription failed: ${errorText}`);
          }
          
          const transcriptionResult = await transcriptionResponse.json();
          
          // Check if ElevenLabs couldn't detect speech
          if (transcriptionResult.text === "We couldn't transcribe the audio. The video might be silent or in an unsupported language.") {
            throw new Error("No speech detected. The video might be silent, have no audio track, or use an unsupported language.");
          }
          
          // Update the video with transcription
          if (transcriptionResult.text && transcriptionResult.text.trim().length > 0) {
            await updateVideo({
              id: videoId as any,
              transcription: transcriptionResult.text,
            });
            
            // Update node to show transcription complete
            setNodes((nds: any) =>
              nds.map((node: any) =>
                node.id === `video_${videoId}`
                  ? {
                      ...node,
                      data: {
                        ...node.data,
                        isTranscribing: false,
                        hasTranscription: true,
                        transcriptionError: null,
                      },
                    }
                  : node
              )
            );
            
            toast.success("Transcription completed!");
          } else {
            throw new Error("No transcription text received. The video might not contain any speech.");
          }
        } catch (error: any) {
          console.error("Transcription error:", error);
          // Update node to show error
          setNodes((nds: any) =>
            nds.map((node: any) =>
              node.id === `video_${videoId}`
                ? {
                    ...node,
                    data: {
                      ...node.data,
                      isTranscribing: false,
                      hasTranscription: false,
                      transcriptionError: error.message,
                    },
                  }
                : node
            )
          );
          throw error;
        }
      } else {
        toast.error("Cannot retry: No video URL found");
        return;
      }
    } catch (error: any) {
      console.error("Retry transcription error:", error);
      handleVideoError(error, 'Transcription Retry');
      
      // Reset node state
      setNodes((nds: any) =>
        nds.map((node: any) =>
          node.id === `video_${videoId}`
            ? {
                ...node,
                data: {
                  ...node.data,
                  isTranscribing: false,
                  transcriptionError: error.message,
                },
              }
            : node
        )
      );
    }
  };

  const onDragOver = useCallback((event: DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
  }, []);

  const onDrop = useCallback(
    (event: DragEvent) => {
      event.preventDefault();

      const type = event.dataTransfer.getData("application/reactflow");
      
      // Handle video file drop
      if (event.dataTransfer.files.length > 0) {
        const file = event.dataTransfer.files[0];
        if (file.type.startsWith("video/")) {
          if (!reactFlowInstance) return;
          
          const desiredPosition = reactFlowInstance.screenToFlowPosition({
            x: event.clientX,
            y: event.clientY,
          });
          
          const position = findNonOverlappingPosition(desiredPosition, 'video');

          // Show file size info
          const fileSizeMB = (file.size / (1024 * 1024)).toFixed(1);
          const MAX_FILE_SIZE = 25 * 1024 * 1024;
          
          if (file.size > MAX_FILE_SIZE) {
            toast.info(`Video is ${fileSizeMB}MB. Audio will be extracted for transcription (supports up to ~25 min videos).`);
          } else {
            toast.info(`Video is ${fileSizeMB}MB. Will transcribe directly.`);
          }

          // Upload video to Convex
          handleVideoUpload(file, position);
          return;
        }
      }

      // Handle node type drop
      if (!type || !reactFlowInstance) {
        return;
      }

      const desiredPosition = reactFlowInstance.screenToFlowPosition({
        x: event.clientX,
        y: event.clientY,
      });
      
      const position = findNonOverlappingPosition(desiredPosition, type);

      // Find the first video node to associate with this agent
      const videoNode = nodes.find((n: any) => n.type === 'video' && n.data.videoId);
      if (!videoNode) {
        toast.error("Please add a video first before adding agents");
        return;
      }

      // Create agent in database
      createAgent({
        videoId: videoNode.data.videoId as Id<"videos">,
        type: type as "title" | "description" | "thumbnail" | "tweets",
        canvasPosition: position,
      }).then((agentId) => {
        const nodeId = `agent_${type}_${agentId}`;
        const newNode: Node = {
          id: nodeId,
          type: "agent",
          position,
          data: {
            agentId, // Store the database ID
            type,
            draft: "",
            status: "idle",
            connections: [],
            onGenerate: () => handleGenerate(nodeId),
            onChat: () => handleChatButtonClick(nodeId),
            onView: () => setSelectedNodeForModal(nodeId),
            onRegenerate: () => handleRegenerateClick(nodeId),
            onViewPrompt: () => {
              const node = nodesRef.current.find((n: any) => n.id === nodeId);
              if (node?.data?.lastPrompt) {
                setSelectedPrompt({ agentType: node.data.type, prompt: node.data.lastPrompt });
                setPromptModalOpen(true);
              }
            },
          },
        };

        setNodes((nds: any) => nds.concat(newNode));
        
        // Automatically create edge from video to agent
        const edgeId = `e${videoNode.id}-${nodeId}`;
        const newEdge: Edge = {
          id: edgeId,
          source: videoNode.id,
          target: nodeId,
          animated: enableEdgeAnimations && !isDragging,
        };
        setEdges((eds: any) => [...eds, newEdge]);
        
        // Update agent's connections in database
        updateAgentConnections({
          id: agentId,
          connections: [videoNode.data.videoId as string],
        }).catch((error) => {
          console.error("Failed to update agent connections:", error);
        });
        
        toast.success(`${type} agent added and connected to video`);
        
        // Just inform about transcription status, don't auto-generate
        if (videoNode.data.isTranscribing) {
          toast.info("Video is still being transcribed. Generate once complete.");
        } else if (videoNode.data.hasTranscription) {
          toast.info("Ready to generate content - click Generate on the agent node");
        } else {
          toast.warning("No transcription available - content will be less accurate");
        }
      }).catch((error) => {
        console.error("Failed to create agent:", error);
        toast.error("Failed to create agent");
      });
    },
    [reactFlowInstance, setNodes, setEdges, handleVideoUpload, handleGenerate, nodes, createAgent, projectId, updateAgentConnections, handleChatButtonClick, handleRegenerateClick]
  );

  // Load existing videos and agents from the project
  useEffect(() => {
    if (!hasLoadedFromDB && projectVideos !== undefined && projectAgents !== undefined) {
      const videoNodes: Node[] = projectVideos.map((video) => ({
        id: `video_${video._id}`,
        type: "video",
        position: video.canvasPosition,
        data: {
          videoId: video._id,
          title: video.title,
          videoUrl: video.videoUrl,
          storageId: video.fileId,
          duration: video.duration,
          fileSize: video.fileSize,
          // Transcription flow: idle -> processing -> completed (with transcription text)
          // Sometimes status is "completed" but transcription text hasn't propagated yet
          hasTranscription: !!video.transcription,
          isTranscribing: video.transcriptionStatus === "processing" || (video.transcriptionStatus === "completed" && !video.transcription),
          transcriptionError: video.transcriptionStatus === "failed" ? video.transcriptionError : null,
          transcriptionProgress: video.transcriptionProgress || null,
          onVideoClick: () => handleVideoClick({
            url: video.videoUrl!,
            title: video.title || "Untitled Video",
            duration: video.duration,
            fileSize: video.fileSize,
          }),
          onRetryTranscription: () => retryTranscription(video._id),
        },
      }));

      const agentNodes: Node[] = projectAgents.map((agent) => ({
        id: `agent_${agent.type}_${agent._id}`,
        type: "agent",
        position: agent.canvasPosition,
        data: {
          agentId: agent._id, // Store the database ID
          type: agent.type,
          draft: agent.draft,
          thumbnailUrl: agent.thumbnailUrl,
          status: agent.status,
          connections: agent.connections,
          onGenerate: () => handleGenerate(`agent_${agent.type}_${agent._id}`),
          onChat: () => handleChatButtonClick(`agent_${agent.type}_${agent._id}`),
          onView: () => setSelectedNodeForModal(`agent_${agent.type}_${agent._id}`),
          onRegenerate: () => handleRegenerateClick(`agent_${agent.type}_${agent._id}`),
          onViewPrompt: () => {
            const node = nodesRef.current.find((n: any) => n.id === `agent_${agent.type}_${agent._id}`);
            if (node?.data?.lastPrompt) {
              setSelectedPrompt({ agentType: node.data.type, prompt: node.data.lastPrompt });
              setPromptModalOpen(true);
            }
          },
        },
      }));

      setNodes([...videoNodes, ...agentNodes]);
      
      // Load chat history from agents
      const allMessages: typeof chatMessages = [];
      projectAgents.forEach((agent) => {
        if (agent.chatHistory && agent.chatHistory.length > 0) {
          const agentMessages = agent.chatHistory.map((msg, idx) => ({
            id: `msg-${agent._id}-${idx}`,
            role: msg.role,
            content: msg.message,
            timestamp: msg.timestamp,
            agentId: `agent_${agent.type}_${agent._id}`,
          }));
          allMessages.push(...agentMessages);
        }
      });
      // Sort messages by timestamp
      allMessages.sort((a: any, b: any) => a.timestamp - b.timestamp);
      setChatMessages(allMessages);
      
      // Reconstruct edges based on agent connections
      const edges: Edge[] = [];
      projectAgents.forEach((agent) => {
        agent.connections.forEach((connectionId: string) => {
          // Find the source node by its data ID
          let sourceNodeId: string | null = null;
          
          // Check if it's a video ID
          const videoNode = videoNodes.find(vn => vn.data.videoId === connectionId);
          if (videoNode) {
            sourceNodeId = videoNode.id;
          } else {
            // Check if it's an agent ID
            const agentNode = agentNodes.find(an => an.data.agentId === connectionId);
            if (agentNode) {
              sourceNodeId = agentNode.id;
            }
          }
          
          if (sourceNodeId) {
            edges.push({
              id: `e${sourceNodeId}-agent_${agent.type}_${agent._id}`,
              source: sourceNodeId,
              target: `agent_${agent.type}_${agent._id}`,
              animated: enableEdgeAnimations && !isDragging,
            });
          }
        });
      });
      
      setEdges(edges);
      setHasLoadedFromDB(true);
    }
  }, [projectVideos, projectAgents, hasLoadedFromDB, setNodes, setEdges, handleGenerate, handleChatButtonClick]);
  
  // Load canvas viewport state - only run once when everything is ready
  useEffect(() => {
    if (!reactFlowInstance || !hasLoadedFromDB || hasInitializedViewport) return;
    
    // If we have a saved canvas state with viewport
    if (canvasState?.viewport) {
      const { x, y, zoom } = canvasState.viewport;
      // Apply saved viewport with minimal validation
      if (typeof x === 'number' && typeof y === 'number' && typeof zoom === 'number' && zoom > 0) {
        console.log("Restoring saved viewport:", { x, y, zoom });
        // Small delay to ensure React Flow is ready
        setTimeout(() => {
          reactFlowInstance.setViewport({ x, y, zoom });
          viewportRef.current = { x, y, zoom };
          setHasInitializedViewport(true);
        }, 50);
      } else {
        setHasInitializedViewport(true);
      }
    } else if (nodes.length > 0) {
      // Only fit view on first load when there's no saved state
      console.log("No saved viewport, fitting view to nodes");
      setTimeout(() => {
        reactFlowInstance.fitView({ 
          padding: 0.2, 
          maxZoom: 1.5,
          duration: 800 
        });
        setHasInitializedViewport(true);
      }, 100);
    } else {
      // No nodes and no saved state, just mark as initialized
      setHasInitializedViewport(true);
    }
  }, [canvasState?.viewport, reactFlowInstance, hasLoadedFromDB, hasInitializedViewport, nodes.length]);
  
  // Debug: Log when nodes change to see selection state
  useEffect(() => {
    const selectedNodes = nodes.filter((node: any) => node.selected);
    if (selectedNodes.length > 0) {
      console.log("üìç Selected nodes:", selectedNodes.map((n: any) => ({ id: n.id, type: n.type, selected: n.selected })));
    }
  }, [nodes]);

  // Periodically check for transcription updates
  useEffect(() => {
    const interval = setInterval(() => {
      // Update nodes with current transcription status from database
      if (projectVideos && projectVideos.length > 0) {
        setNodes((nds: any) =>
          nds.map((node: any) => {
            if (node.type === 'video') {
              const video = projectVideos.find((v: any) => `video_${v._id}` === node.id);
              if (video) {
                // Only update if status has changed
                const newHasTranscription = !!video.transcription || video.transcriptionStatus === "completed";
                const newIsTranscribing = video.transcriptionStatus === "processing";
                const newTranscriptionError = video.transcriptionStatus === "failed" ? video.transcriptionError : null;
                
                if (node.data.hasTranscription !== newHasTranscription ||
                    node.data.isTranscribing !== newIsTranscribing ||
                    node.data.transcriptionError !== newTranscriptionError) {
                  console.log(`Updating video ${video._id} transcription status:`, {
                    status: video.transcriptionStatus,
                    hasTranscription: newHasTranscription,
                    isTranscribing: newIsTranscribing,
                    error: newTranscriptionError
                  });
                  
                  // Show toast when transcription completes
                  if (!node.data.hasTranscription && newHasTranscription) {
                    toast.success("Video transcription completed!");
                  } else if (!node.data.transcriptionError && newTranscriptionError) {
                    toast.error(`Transcription failed: ${newTranscriptionError}`);
                  }
                  
                  return {
                    ...node,
                    data: {
                      ...node.data,
                      videoUrl: video.videoUrl || node.data.videoUrl, // Update URL if available
                      hasTranscription: newHasTranscription,
                      isTranscribing: newIsTranscribing,
                      transcriptionError: newTranscriptionError,
                      onRetryTranscription: newTranscriptionError ? () => retryTranscription(video._id) : undefined,
                      onVideoClick: video.videoUrl ? () => handleVideoClick({
                        url: video.videoUrl!,
                        title: video.title || "Untitled Video",
                        duration: video.duration,
                        fileSize: video.fileSize,
                      }) : node.data.onVideoClick,
                    },
                  };
                }
              }
            }
            return node;
          })
        );
      }
    }, 3000); // Check every 3 seconds
    
    return () => clearInterval(interval);
  }, [projectVideos, setNodes]);

  // Auto-save canvas state
  useEffect(() => {
    if (!projectId || !hasLoadedFromDB || !hasInitializedViewport) return;
    
    const saveTimeout = setTimeout(() => {
      // Use the viewport from ref or get current viewport
      const viewport = viewportRef.current || reactFlowInstance?.getViewport();
      
      // Basic viewport validation
      if (!viewport || typeof viewport.zoom !== 'number' || viewport.zoom <= 0) {
        console.warn("Invalid viewport, skipping save");
        return;
      }
      
      console.log("Saving canvas state with viewport:", viewport);
      
      // Filter out function properties from node data
      const serializableNodes = nodes.map((node: any) => ({
        id: node.id,
        type: node.type,
        position: node.position,
        data: Object.fromEntries(
          Object.entries(node.data).filter(([, value]) => {
            // Filter out functions and undefined values
            return typeof value !== 'function' && value !== undefined;
          })
        ),
      }));
      
      saveCanvasState({
        projectId,
        nodes: serializableNodes,
        edges: edges.map((edge: any) => ({
          id: edge.id,
          source: edge.source,
          target: edge.target,
          sourceHandle: edge.sourceHandle || undefined,
          targetHandle: edge.targetHandle || undefined,
        })),
        viewport: {
          x: viewport.x,
          y: viewport.y,
          zoom: viewport.zoom,
        },
      }).catch((error) => {
        console.error("Failed to save canvas state:", error);
      });
    }, 2000); // Save after 2 seconds of inactivity
    
    return () => clearTimeout(saveTimeout);
  }, [nodes, edges, reactFlowInstance, projectId, saveCanvasState, hasLoadedFromDB, hasInitializedViewport]);

  return (
    <ReactFlowProvider>
      <div className="flex h-[calc(100vh-var(--header-height))]">
        {/* Sidebar with draggable agent nodes */}
        <aside className={`${isSidebarCollapsed ? "w-20" : "w-72"} bg-gradient-to-b from-background via-background to-background/95 border-r border-border/50 transition-all duration-300 flex flex-col backdrop-blur-sm`}>
          <div className={`flex-1 ${isSidebarCollapsed ? "p-3" : "p-6"} overflow-y-auto`}>
            {/* Header */}
            <div className={`flex items-center ${isSidebarCollapsed ? "justify-center mb-6" : "justify-between mb-8"}`}>
              {!isSidebarCollapsed && (
                <div className="flex items-center gap-2">
                  <div className="p-2 rounded-lg bg-primary/10">
                    <Bot className="h-5 w-5 text-primary" />
                  </div>
                  <div>
                    <h2 className="text-lg font-semibold">AI Agents</h2>
                    <p className="text-xs text-muted-foreground">Drag to canvas</p>
                  </div>
                </div>
              )}
              <Button
                variant="ghost"
                size="icon"
                onClick={() => setIsSidebarCollapsed(!isSidebarCollapsed)}
                className={`h-9 w-9 hover:bg-primary/10 ${isSidebarCollapsed ? "" : "ml-auto"}`}
              >
                {isSidebarCollapsed ? <ChevronRight className="h-4 w-4" /> : <ChevronLeft className="h-4 w-4" />}
              </Button>
            </div>
            
            {/* Agents Section */}
            <div className="space-y-3">
              {!isSidebarCollapsed && (
                <div className="flex items-center gap-2 mb-4">
                  <Layers className="h-4 w-4 text-muted-foreground" />
                  <span className="text-xs font-medium text-muted-foreground uppercase tracking-wider">Content Agents</span>
                </div>
              )}
              
              <DraggableNode 
                type="title" 
                label={isSidebarCollapsed ? "" : "Title Generator"} 
                description={isSidebarCollapsed ? "" : "Create engaging video titles"}
                icon={<Hash className="h-5 w-5" />}
                collapsed={isSidebarCollapsed}
                color="blue"
              />
              <DraggableNode 
                type="description" 
                label={isSidebarCollapsed ? "" : "Description Writer"} 
                description={isSidebarCollapsed ? "" : "Write SEO-optimized descriptions"}
                icon={<FileText className="h-5 w-5" />}
                collapsed={isSidebarCollapsed}
                color="green"
              />
              <DraggableNode 
                type="thumbnail" 
                label={isSidebarCollapsed ? "" : "Thumbnail Designer"} 
                description={isSidebarCollapsed ? "" : "Design eye-catching thumbnails"}
                icon={<Palette className="h-5 w-5" />}
                collapsed={isSidebarCollapsed}
                color="purple"
              />
              <DraggableNode 
                type="tweets" 
                label={isSidebarCollapsed ? "" : "Social Media"} 
                description={isSidebarCollapsed ? "" : "Create viral tweets & posts"}
                icon={<Zap className="h-5 w-5" />}
                collapsed={isSidebarCollapsed}
                color="yellow"
              />
            </div>
            
            {!isSidebarCollapsed && (
              <div className="mt-8 space-y-4">
                <div className="relative">
                  <div className="absolute inset-0 bg-gradient-to-r from-primary/20 to-purple-500/20 rounded-xl blur-xl" />
                  <div className="relative rounded-xl bg-gradient-to-r from-primary/10 to-purple-500/10 border border-primary/20 p-4 space-y-3">
                    <div className="flex items-center gap-2">
                      <Video className="h-5 w-5 text-primary" />
                      <span className="text-sm font-medium">Quick Start</span>
                    </div>
                    <p className="text-xs text-muted-foreground leading-relaxed">
                      Drag a video file directly onto the canvas to begin
                    </p>
                    <Button
                      onClick={() => fileInputRef.current?.click()}
                      variant="secondary"
                      size="sm"
                      className="w-full"
                    >
                      <Upload className="h-4 w-4 mr-2" />
                      Upload Video
                    </Button>
                  </div>
                </div>
              </div>
            )}
            
            {isSidebarCollapsed && (
              <div className="mt-8 space-y-2">
                <Button
                  onClick={() => fileInputRef.current?.click()}
                  size="icon"
                  variant="secondary"
                  className="w-full hover:bg-primary/10"
                  title="Upload Video"
                >
                  <Upload className="h-5 w-5" />
                </Button>
              </div>
            )}
          </div>

          {/* Bottom Actions */}
          <div className={`${isSidebarCollapsed ? "p-3" : "p-6"} border-t border-border/50 space-y-3 bg-gradient-to-t from-background/80 to-background backdrop-blur-sm`}>
            <Button 
              onClick={handleGenerateAll} 
              disabled={isGeneratingAll}
              className={`w-full bg-gradient-to-r from-primary to-primary/80 hover:from-primary/90 hover:to-primary/70 shadow-lg shadow-primary/20 ${isSidebarCollapsed ? "" : "h-11"}`}
              size={isSidebarCollapsed ? "icon" : "default"}
              title={isSidebarCollapsed ? "Generate All Content" : undefined}
            >
              <Sparkles className={`${isSidebarCollapsed ? "h-5 w-5" : "mr-2 h-5 w-5"} ${isGeneratingAll ? "animate-pulse" : ""}`} />
              {!isSidebarCollapsed && (isGeneratingAll 
                ? `Generating ${generationProgress.current}/${generationProgress.total}...`
                : "Generate All Content"
              )}
            </Button>
            
            <Button 
              onClick={() => setPreviewModalOpen(true)}
              className={`w-full ${isSidebarCollapsed ? "" : "h-11"}`}
              variant="secondary"
              size={isSidebarCollapsed ? "icon" : "default"}
              title={isSidebarCollapsed ? "Preview Content" : undefined}
            >
              <Eye className={isSidebarCollapsed ? "h-5 w-5" : "mr-2 h-5 w-5"} />
              {!isSidebarCollapsed && "Preview Content"}
            </Button>
            
            {!isSidebarCollapsed && (
              <div className="space-y-4 pt-2">
                <div className="space-y-3 rounded-lg bg-muted/50 p-3">
                  <div className="flex items-center gap-2">
                    <Settings2 className="h-4 w-4 text-muted-foreground" />
                    <span className="text-xs font-medium text-muted-foreground uppercase tracking-wider">Canvas Settings</span>
                  </div>
                  
                  <div className="space-y-3">
                    
                    <div className="flex items-center justify-between">
                      <span className="text-sm">Mini-map</span>
                      <button
                        onClick={() => setShowMiniMap(!showMiniMap)}
                        className={`relative inline-flex h-6 w-11 items-center rounded-full transition-all ${
                          showMiniMap ? 'bg-primary' : 'bg-muted'
                        }`}
                      >
                        <span
                          className={`inline-block h-4 w-4 transform rounded-full bg-white shadow-sm transition-transform ${
                            showMiniMap ? 'translate-x-6' : 'translate-x-1'
                          }`}
                        />
                      </button>
                    </div>
                    
                    {/* Share button */}
                    <div className="pt-3 border-t border-border/50">
                      <Button
                        onClick={handleShare}
                        variant="outline"
                        size="sm"
                        className="w-full justify-start gap-2"
                      >
                        {copiedShareLink ? (
                          <>
                            <Check className="h-4 w-4 text-green-500" />
                            <span>Copied!</span>
                          </>
                        ) : (
                          <>
                            <Share2 className="h-4 w-4" />
                            <span>Share Canvas</span>
                          </>
                        )}
                      </Button>
                      {getShareLink && (
                        <p className="text-xs text-muted-foreground mt-2">
                          Share link already exists
                        </p>
                      )}
                    </div>
                  </div>
                </div>
                
                <VideoProcessingHelp />
              </div>
            )}
            
            {isSidebarCollapsed && (
              <div className="flex flex-col gap-2">
                <Button 
                  onClick={() => setShowMiniMap(!showMiniMap)}
                  variant={showMiniMap ? "secondary" : "ghost"}
                  size="icon"
                  title="Toggle Mini-map"
                  className="w-full"
                >
                  <Map className="h-5 w-5" />
                </Button>
                <Button 
                  onClick={() => setEnableEdgeAnimations(!enableEdgeAnimations)}
                  variant={enableEdgeAnimations ? "secondary" : "ghost"}
                  size="icon"
                  title="Toggle Animations"
                  className="w-full"
                >
                  <Settings2 className="h-5 w-5" />
                </Button>
                <Button 
                  onClick={handleShare}
                  variant="ghost"
                  size="icon"
                  title="Share Canvas"
                  className="w-full relative"
                >
                  {copiedShareLink ? (
                    <Check className="h-5 w-5 text-green-500" />
                  ) : (
                    <Share2 className="h-5 w-5" />
                  )}
                </Button>
              </div>
            )}
          </div>
        </aside>

        {/* Canvas */}
        <div className="flex-1 relative" ref={reactFlowWrapper}>
          <ReactFlow
            nodes={nodes}
            edges={edges.map((edge: any) => ({
              ...edge,
              animated: enableEdgeAnimations && !isDragging,
              style: { 
                stroke: '#6366f1',
                strokeWidth: 2,
                strokeOpacity: 0.5
              },
              markerEnd: {
                type: 'arrowclosed',
                color: '#6366f1',
                width: 20,
                height: 20,
              }
            }))}
            onNodesChange={onNodesChange}
            onNodeDragStart={() => setIsDragging(true)}
            onNodeDragStop={async (_event: any, node: any) => {
              console.log("Node dragged:", node.id, "to position:", node.position);
              setIsDragging(false);
              
              // Update position in database
              if (node.type === 'video' && node.data.videoId) {
                try {
                  await updateVideo({
                    id: node.data.videoId as Id<"videos">,
                    canvasPosition: node.position,
                  });
                } catch (error) {
                  console.error("Failed to update video position:", error);
                }
              } else if (node.type === 'agent' && node.data.agentId) {
                try {
                  await updateAgentPosition({
                    id: node.data.agentId as Id<"agents">,
                    canvasPosition: node.position,
                  });
                } catch (error) {
                  console.error("Failed to update agent position:", error);
                }
              }
            }}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onNodesDelete={onNodesDelete}
            onInit={setReactFlowInstance}
            onDrop={onDrop}
            onDragOver={onDragOver}
            onViewportChange={onViewportChange}
            nodeTypes={nodeTypes}
            deleteKeyCode={["Backspace", "Delete"]}
            selectionOnDrag={false}
            selectNodesOnDrag={false}
            fitView={false}
            minZoom={0.1}
            maxZoom={2}
            preventScrolling={false}
          >
            <Background 
              variant="dots" 
              gap={16} 
              size={1}
              color="#94a3b8"
              style={{ opacity: 0.4 }}
            />
            <Controls 
              className="!shadow-xl !border !border-border/50 !bg-background/95 !backdrop-blur-sm"
              showZoom={true}
              showFitView={true}
              showInteractive={true}
            />
            {showMiniMap && (
              <MiniMap 
                className="!shadow-xl !border !border-border/50 !bg-background/95 !backdrop-blur-sm"
                nodeColor={(node: any) => {
                  if (node.type === 'video') return '#3b82f6';
                  if (node.type === 'agent') {
                    const agentType = node.data?.type;
                    if (agentType === 'title') return '#3b82f6';
                    if (agentType === 'description') return '#10b981';
                    if (agentType === 'thumbnail') return '#a855f7';
                    if (agentType === 'tweets') return '#eab308';
                  }
                  return '#6b7280';
                }}
                nodeStrokeWidth={3}
                nodeStrokeColor="#000"
                pannable
                zoomable
              />
            )}
          </ReactFlow>
        </div>
        
        {/* Content Modal */}
        <ContentModal
          isOpen={!!selectedNodeForModal}
          onClose={() => setSelectedNodeForModal(null)}
          nodeData={selectedNodeForModal ? 
            nodes.find((n: any) => n.id === selectedNodeForModal)?.data as { type: string; draft: string; thumbnailUrl?: string } | undefined || null 
            : null}
          onUpdate={(newContent) => {
            if (selectedNodeForModal) {
              handleContentUpdate(selectedNodeForModal, newContent);
            }
          }}
          videoData={(() => {
            // Find connected video node
            const agentNode = nodes.find((n: any) => n.id === selectedNodeForModal);
            if (!agentNode || agentNode.type !== 'agent') return undefined;
            
            const videoEdge = edges.find((e: any) => e.target === selectedNodeForModal && e.source?.includes('video'));
            if (!videoEdge) return undefined;
            
            const videoNode = nodes.find((n: any) => n.id === videoEdge.source);
            if (!videoNode) return undefined;
            
            const video = projectVideos?.find((v: any) => v._id === videoNode.data.videoId);
            
            return {
              title: videoNode.data.title || video?.title,
              thumbnailUrl: video?.thumbnailUrl || videoNode.data.thumbnail,
              duration: videoNode.data.duration || video?.duration,
            };
          })()}
          channelData={userProfile ? {
            channelName: userProfile.channelName,
            channelAvatar: undefined, // Could add avatar URL to profile
            subscriberCount: "1.2K", // Could add to profile
          } : undefined}
        />
        
        {/* Thumbnail Upload Modal */}
        <ThumbnailUploadModal
          isOpen={thumbnailModalOpen}
          onClose={() => {
            setThumbnailModalOpen(false);
            setPendingThumbnailNode(null);
          }}
          onUpload={handleThumbnailUpload}
          isGenerating={false}
        />
        
        {/* Video Player Modal */}
        {selectedVideo && (
          <VideoPlayerModal
            isOpen={videoModalOpen}
            onClose={() => {
              setVideoModalOpen(false);
              setSelectedVideo(null);
            }}
            videoUrl={selectedVideo.url}
            title={selectedVideo.title}
            duration={selectedVideo.duration}
            fileSize={selectedVideo.fileSize}
          />
        )}
        
        {/* Prompt Modal */}
        {selectedPrompt && (
          <PromptModal
            open={promptModalOpen}
            onOpenChange={setPromptModalOpen}
            agentType={selectedPrompt.agentType}
            prompt={selectedPrompt.prompt}
          />
        )}
        
        {/* Floating Chat - Always Visible */}
        <FloatingChat
          agents={nodes
            .filter((n: any) => n.type === 'agent')
            .map((n: any) => ({
              id: n.id,
              type: n.data.type as string,
              draft: n.data.draft as string,
            }))}
          messages={chatMessages}
          onSendMessage={handleChatMessage}
          isGenerating={isChatGenerating}
          initialInputValue={chatInput}
        />
        
        {/* Hidden file input for video upload */}
        <input
          ref={fileInputRef}
          type="file"
          accept="video/*"
          style={{ display: 'none' }}
          onChange={async (e) => {
            const file = e.target.files?.[0];
            if (file && reactFlowInstance) {
              // Get the center of the current viewport
              const bounds = reactFlowWrapper.current?.getBoundingClientRect();
              if (bounds) {
                const centerX = bounds.width / 2;
                const centerY = bounds.height / 2;
                const position = reactFlowInstance.screenToFlowPosition({
                  x: centerX,
                  y: centerY,
                });
                await handleVideoUpload(file, position);
              }
            }
            // Reset the input
            e.target.value = '';
          }}
        />
        
        {/* Preview Modal */}
        <PreviewModal
          isOpen={previewModalOpen}
          onClose={() => setPreviewModalOpen(false)}
          title={nodes.find((n: any) => n.type === 'agent' && n.data.type === 'title')?.data.draft || ''}
          description={nodes.find((n: any) => n.type === 'agent' && n.data.type === 'description')?.data.draft || ''}
          tweets={nodes.find((n: any) => n.type === 'agent' && n.data.type === 'tweets')?.data.draft || ''}
          thumbnailUrl={nodes.find((n: any) => n.type === 'agent' && n.data.type === 'thumbnail')?.data.thumbnailUrl}
          videoUrl={nodes.find((n: any) => n.type === 'video')?.data.videoUrl}
          duration={nodes.find((n: any) => n.type === 'video')?.data.duration}
          channelName={userProfile?.channelName}
          subscriberCount="1.2K"
        />
        
        {/* Delete Confirmation Dialog */}
        <DeleteConfirmationDialog
          open={deleteDialogOpen}
          onOpenChange={setDeleteDialogOpen}
          onConfirm={handleDeleteConfirm}
          title="Delete Content?"
          description={
            nodesToDelete.some((n: any) => n.type === 'video')
              ? "This will permanently delete the video and all associated content. This action cannot be undone."
              : "This will permanently delete the selected content. This action cannot be undone."
          }
        />
        
      </div>
    </ReactFlowProvider>
  );
}

function DraggableNode({ 
  type, 
  label, 
  description,
  icon, 
  collapsed,
  color = "blue"
}: { 
  type: string; 
  label: string; 
  description?: string;
  icon?: React.ReactNode;
  collapsed?: boolean;
  color?: "blue" | "green" | "purple" | "yellow";
}) {
  const onDragStart = (event: React.DragEvent) => {
    event.dataTransfer.setData("application/reactflow", type);
    event.dataTransfer.effectAllowed = "move";
  };

  const colorClasses = {
    blue: "from-blue-500/20 to-blue-600/20 hover:from-blue-500/30 hover:to-blue-600/30 border-blue-500/30 text-blue-500",
    green: "from-green-500/20 to-green-600/20 hover:from-green-500/30 hover:to-green-600/30 border-green-500/30 text-green-500",
    purple: "from-purple-500/20 to-purple-600/20 hover:from-purple-500/30 hover:to-purple-600/30 border-purple-500/30 text-purple-500",
    yellow: "from-yellow-500/20 to-yellow-600/20 hover:from-yellow-500/30 hover:to-yellow-600/30 border-yellow-500/30 text-yellow-500",
  };

  if (collapsed) {
    return (
      <div
        className={`cursor-move rounded-xl bg-gradient-to-br ${colorClasses[color]} border backdrop-blur-sm p-3 transition-all hover:scale-105 hover:shadow-lg flex items-center justify-center group`}
        onDragStart={onDragStart}
        draggable
        title={label}
        style={{ opacity: 1 }}
      >
        <div className="text-foreground">
          {icon}
        </div>
      </div>
    );
  }

  return (
    <div
      className={`cursor-move rounded-xl bg-gradient-to-br ${colorClasses[color]} border backdrop-blur-sm p-4 transition-all hover:scale-[1.02] hover:shadow-lg group`}
      onDragStart={onDragStart}
      draggable
      style={{ opacity: 1 }}
    >
      <div className="space-y-2">
        <div className="flex items-center gap-3">
          <div className="text-foreground">
            {icon}
          </div>
          <div className="flex-1">
            <h3 className="font-medium text-foreground">{label}</h3>
            {description && (
              <p className="text-xs text-muted-foreground mt-0.5">{description}</p>
            )}
          </div>
          <GripVertical className="h-4 w-4 text-muted-foreground/50 group-hover:text-muted-foreground" />
        </div>
      </div>
    </div>
  );
}

function Canvas({ projectId }: { projectId: Id<"projects"> }) {
  return <CanvasContent projectId={projectId} />;
}

export default Canvas;


================================================
FILE: app/components/canvas/CanvasWrapper.tsx
================================================
import { lazy, Suspense } from "react";
import type { Id } from "convex/_generated/dataModel";

// Lazy load the Canvas component to avoid SSR issues
const Canvas = lazy(() => import("./Canvas"));

export function CanvasWrapper({ projectId }: { projectId: Id<"projects"> }) {
  return (
    <Suspense fallback={
      <div className="flex h-[calc(100vh-var(--header-height))] items-center justify-center">
        <p className="text-muted-foreground">Loading canvas...</p>
      </div>
    }>
      <Canvas projectId={projectId} />
    </Suspense>
  );
}


================================================
FILE: app/components/canvas/ClientCanvas.tsx
================================================
// Client-only Canvas component
import { useEffect, useState } from "react";
import type { Id } from "convex/_generated/dataModel";

export default function ClientCanvas({ projectId }: { projectId: Id<"projects"> }) {
  const [CanvasComponent, setCanvasComponent] = useState<any>(null);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    // First ensure React Flow styles are loaded
    import("@xyflow/react/dist/style.css").then(() => {
      // Then dynamically import the Canvas component
      return import("./Canvas");
    }).then((module) => {
      setCanvasComponent(() => module.default);
    }).catch((err) => {
      console.error("Failed to load Canvas component:", err);
      setError(err.message);
    });
  }, []);
  
  if (error) {
    return (
      <div className="flex h-[calc(100vh-var(--header-height))] items-center justify-center">
        <div className="text-center">
          <p className="text-destructive mb-2">Failed to load canvas</p>
          <p className="text-sm text-muted-foreground">{error}</p>
        </div>
      </div>
    );
  }
  
  if (!CanvasComponent) {
    return (
      <div className="flex h-[calc(100vh-var(--header-height))] items-center justify-center">
        <p className="text-muted-foreground">Loading canvas...</p>
      </div>
    );
  }
  
  return <CanvasComponent projectId={projectId} />;
}


================================================
FILE: app/components/canvas/ContentModal.tsx
================================================
import React, { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "~/components/ui/dialog";
import { Button } from "~/components/ui/button";
import { Textarea } from "~/components/ui/textarea";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "~/components/ui/tabs";
import { Copy, Check, Eye, Edit3, Youtube, Twitter, Sparkles, FileText, Image } from "lucide-react";
import { toast } from "sonner";
import { Card } from "~/components/ui/card";
import { YouTubePreview } from "~/components/preview/YouTubePreview";
import { TwitterThreadPreview } from "~/components/preview/TwitterThreadPreview";
import { cn } from "~/lib/utils";

interface ContentModalProps {
  isOpen: boolean;
  onClose: () => void;
  nodeData: {
    type: string;
    draft: string;
    thumbnailUrl?: string;
  } | null;
  onUpdate?: (newContent: string) => void;
  videoData?: {
    title?: string;
    thumbnailUrl?: string;
    duration?: number;
  };
  channelData?: {
    channelName?: string;
    channelAvatar?: string;
    subscriberCount?: string;
  };
}

export function ContentModal({ isOpen, onClose, nodeData, onUpdate, videoData, channelData }: ContentModalProps) {
  const [content, setContent] = useState("");
  const [copied, setCopied] = useState(false);
  const [activeTab, setActiveTab] = useState<"edit" | "preview">("edit");

  // Update content when nodeData changes
  React.useEffect(() => {
    if (nodeData) {
      setContent(nodeData.draft || "");
    }
  }, [nodeData]);

  const handleCopy = async () => {
    await navigator.clipboard.writeText(content);
    setCopied(true);
    toast.success("Copied to clipboard!");
    setTimeout(() => setCopied(false), 2000);
  };

  const handleSave = () => {
    if (onUpdate) {
      onUpdate(content);
    }
    onClose();
  };

  if (!nodeData) return null;

  const titles = {
    title: "Video Title",
    description: "Video Description",
    thumbnail: "Thumbnail Concept",
    tweets: "Twitter/X Thread",
  };

  const icons = {
    title: <FileText className="h-5 w-5" />,
    description: <FileText className="h-5 w-5" />,
    thumbnail: <Image className="h-5 w-5" />,
    tweets: <Twitter className="h-5 w-5" />,
  };

  const showPreview = nodeData.type === "title" || nodeData.type === "description" || nodeData.type === "tweets";

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-hidden p-0">
        <DialogHeader className="px-6 pt-6 pb-4 border-b">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <div className={cn(
                "p-2 rounded-lg",
                nodeData.type === "title" ? "bg-blue-100 text-blue-600 dark:bg-blue-900/20 dark:text-blue-400" :
                nodeData.type === "description" ? "bg-purple-100 text-purple-600 dark:bg-purple-900/20 dark:text-purple-400" :
                nodeData.type === "thumbnail" ? "bg-green-100 text-green-600 dark:bg-green-900/20 dark:text-green-400" :
                "bg-orange-100 text-orange-600 dark:bg-orange-900/20 dark:text-orange-400"
              )}>
                {icons[nodeData.type as keyof typeof icons]}
              </div>
              <div>
                <DialogTitle className="text-xl">{titles[nodeData.type as keyof typeof titles]}</DialogTitle>
                <p className="text-sm text-muted-foreground mt-0.5">
                  {nodeData.type === "thumbnail" 
                    ? "AI-generated thumbnail concept and image"
                    : "View, edit, and preview your AI-generated content"
                  }
                </p>
              </div>
            </div>
            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={handleCopy}
                className="gap-2"
              >
                {copied ? (
                  <>
                    <Check className="h-4 w-4" />
                    Copied
                  </>
                ) : (
                  <>
                    <Copy className="h-4 w-4" />
                    Copy
                  </>
                )}
              </Button>
            </div>
          </div>
        </DialogHeader>
        
        <div className="flex-1 overflow-hidden">
          {showPreview ? (
            <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as "edit" | "preview")} className="h-full">
              <div className="px-6 pt-4">
                <TabsList className="grid w-fit grid-cols-2">
                  <TabsTrigger value="edit" className="gap-2">
                    <Edit3 className="h-4 w-4" />
                    Edit
                  </TabsTrigger>
                  <TabsTrigger value="preview" className="gap-2">
                    <Eye className="h-4 w-4" />
                    Preview
                  </TabsTrigger>
                </TabsList>
              </div>
              
              <div className="overflow-y-auto max-h-[calc(90vh-200px)]">
                <TabsContent value="edit" className="p-6 pt-4 m-0">
                  <Textarea
                    value={content}
                    onChange={(e) => setContent(e.target.value)}
                    className={cn(
                      "font-mono text-sm resize-none",
                      nodeData.type === "tweets" ? "min-h-[400px]" : "min-h-[300px]"
                    )}
                    placeholder="No content generated yet..."
                  />
                </TabsContent>
                
                <TabsContent value="preview" className="p-6 pt-4 m-0">
                  {(nodeData.type === "title" || nodeData.type === "description") && (
                    <YouTubePreview
                      title={nodeData.type === "title" ? content : (videoData?.title || "Video Title")}
                      description={nodeData.type === "description" ? content : ""}
                      thumbnailUrl={nodeData.thumbnailUrl || videoData?.thumbnailUrl}
                      duration={videoData?.duration}
                      channelName={channelData?.channelName}
                      channelAvatar={channelData?.channelAvatar}
                      subscriberCount={channelData?.subscriberCount}
                    />
                  )}
                  
                  {nodeData.type === "tweets" && (
                    <TwitterThreadPreview
                      tweets={content}
                      username={channelData?.channelName?.toLowerCase().replace(/\s+/g, '') || "yourhandle"}
                      displayName={channelData?.channelName || "Your Channel"}
                      profileImage={channelData?.channelAvatar}
                      media={nodeData.thumbnailUrl ? [nodeData.thumbnailUrl] : []}
                    />
                  )}
                </TabsContent>
              </div>
            </Tabs>
          ) : (
            <div className="p-6 space-y-4 overflow-y-auto max-h-[calc(90vh-200px)]">
              {nodeData.type === "thumbnail" && nodeData.thumbnailUrl && (
                <Card className="relative overflow-hidden bg-gradient-to-br from-background to-muted/20">
                  <div className="absolute inset-0 bg-gradient-to-br from-primary/5 to-transparent" />
                  <div className="relative p-6">
                    <div className="aspect-video relative rounded-lg overflow-hidden shadow-2xl">
                      <img 
                        src={nodeData.thumbnailUrl} 
                        alt="Generated thumbnail" 
                        className="w-full h-full object-cover"
                      />
                      <div className="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent" />
                    </div>
                    <div className="mt-4 flex items-center gap-2 text-sm text-muted-foreground">
                      <Sparkles className="h-4 w-4" />
                      <span>AI-generated YouTube thumbnail</span>
                    </div>
                  </div>
                </Card>
              )}
              
              <div>
                <label className="text-sm font-medium mb-2 block">
                  {nodeData.type === "thumbnail" ? "Thumbnail Concept & Prompt" : "Content"}
                </label>
                <Textarea
                  value={content}
                  onChange={(e) => setContent(e.target.value)}
                  className={cn(
                    "font-mono text-sm resize-none",
                    nodeData.type === "thumbnail" ? "min-h-[150px]" : "min-h-[300px]"
                  )}
                  placeholder="No content generated yet..."
                />
              </div>
            </div>
          )}
        </div>
        
        <div className="flex justify-between items-center px-6 py-4 border-t bg-muted/50">
          <div className="text-sm text-muted-foreground">
            {content.length} characters ‚Ä¢ {content.split(/\s+/).filter(w => w).length} words
          </div>
          <div className="flex gap-2">
            <Button variant="outline" onClick={onClose}>
              Cancel
            </Button>
            <Button onClick={handleSave} className="gap-2">
              <Check className="h-4 w-4" />
              Save Changes
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}


================================================
FILE: app/components/canvas/DeleteConfirmationDialog.tsx
================================================
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "~/components/ui/alert-dialog";
import { Trash2 } from "lucide-react";

interface DeleteConfirmationDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onConfirm: () => void;
  title: string;
  description: string;
}

export function DeleteConfirmationDialog({
  open,
  onOpenChange,
  onConfirm,
  title,
  description,
}: DeleteConfirmationDialogProps) {
  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 rounded-full bg-destructive/10 flex items-center justify-center">
              <Trash2 className="h-5 w-5 text-destructive" />
            </div>
            <AlertDialogTitle>{title}</AlertDialogTitle>
          </div>
          <AlertDialogDescription className="mt-3">
            {description}
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={onConfirm}
            className="bg-destructive text-white hover:bg-destructive/90"
          >
            Delete
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}


================================================
FILE: app/components/canvas/FloatingChat.tsx
================================================
import React, { useState, useRef, useEffect } from "react";
import { Card } from "~/components/ui/card";
import { Button } from "~/components/ui/button";
import { Input } from "~/components/ui/input";
import { ScrollArea } from "~/components/ui/scroll-area";
import { 
  X, 
  Send, 
  MessageSquare, 
  Minimize2, 
  Maximize2,
  Bot,
  User,
  AtSign
} from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { toast } from "sonner";
import { MentionAutocomplete } from "./MentionAutocomplete";

interface Message {
  id: string;
  role: "user" | "ai";
  content: string;
  timestamp: number;
  agentId?: string;
}

interface FloatingChatProps {
  agents: Array<{
    id: string;
    type: string;
    draft: string;
  }>;
  messages: Message[];
  onSendMessage: (message: string) => Promise<void>;
  isGenerating?: boolean;
  initialInputValue?: string;
}

const agentLabels = {
  title: "Title Agent",
  description: "Description Agent",
  thumbnail: "Thumbnail Agent",
  tweets: "Tweets Agent",
};

export function FloatingChat({ 
  agents,
  messages,
  onSendMessage,
  isGenerating = false,
  initialInputValue = ""
}: FloatingChatProps) {
  const [input, setInput] = useState("");
  const [isMinimized, setIsMinimized] = useState(true);
  const [showMentionDropdown, setShowMentionDropdown] = useState(false);
  const [mentionSearchTerm, setMentionSearchTerm] = useState("");
  const [mentionStartIndex, setMentionStartIndex] = useState(-1);
  const [selectedMentionIndex, setSelectedMentionIndex] = useState(0);
  const scrollAreaRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  
  // Available mention options for keyboard navigation
  const mentionOptions = [
    { value: "TITLE_AGENT", label: "Title Agent" },
    { value: "DESCRIPTION_AGENT", label: "Description Agent" },
    { value: "THUMBNAIL_AGENT", label: "Thumbnail Agent" },
    { value: "TWEETS_AGENT", label: "Tweets Agent" },
  ];
  
  const filteredMentions = mentionOptions.filter(option =>
    option.label.toLowerCase().includes(mentionSearchTerm.toLowerCase()) ||
    option.value.toLowerCase().includes(mentionSearchTerm.toLowerCase())
  );
  
  // Handle initial value from parent (like @mentions)
  useEffect(() => {
    if (initialInputValue) {
      setInput(initialInputValue);
      
      // Auto-expand if initial value contains @mention
      if (initialInputValue.includes('@')) {
        setIsMinimized(false);
        
        // Focus the input after expansion
        setTimeout(() => {
          inputRef.current?.focus();
          // Move cursor to end
          const len = initialInputValue.length;
          inputRef.current?.setSelectionRange(len, len);
        }, 150);
      }
    }
  }, [initialInputValue]);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    if (scrollAreaRef.current) {
      const scrollContainer = scrollAreaRef.current.querySelector('[data-radix-scroll-area-viewport]');
      if (scrollContainer) {
        scrollContainer.scrollTop = scrollContainer.scrollHeight;
      }
    }
  }, [messages]);

  // Focus input when chat opens
  useEffect(() => {
    if (!isMinimized) {
      // Small delay to ensure the input is rendered
      setTimeout(() => {
        inputRef.current?.focus();
      }, 100);
    }
  }, [isMinimized]);

  const handleInputChange = (value: string) => {
    setInput(value);
    
    // Check for @ symbol to show mention dropdown
    const lastAtIndex = value.lastIndexOf('@');
    const textAfterAt = value.slice(lastAtIndex + 1);
    const hasSpaceAfterAt = textAfterAt.includes(' ');
    
    if (lastAtIndex !== -1 && !hasSpaceAfterAt) {
      // Show dropdown
      setShowMentionDropdown(true);
      setMentionSearchTerm(textAfterAt);
      setMentionStartIndex(lastAtIndex);
      setSelectedMentionIndex(0);
    } else {
      // Hide dropdown
      setShowMentionDropdown(false);
      setMentionSearchTerm("");
      setMentionStartIndex(-1);
    }
  };

  const handleSend = async () => {
    if (!input.trim() || isGenerating) return;
    
    const message = input.trim();
    handleInputChange("");
    
    try {
      await onSendMessage(message);
    } catch (error) {
      toast.error("Failed to send message");
      handleInputChange(message); // Restore input on error
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (showMentionDropdown) {
      if (e.key === "ArrowDown") {
        e.preventDefault();
        setSelectedMentionIndex(prev => 
          prev < filteredMentions.length - 1 ? prev + 1 : prev
        );
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        setSelectedMentionIndex(prev => prev > 0 ? prev - 1 : prev);
      } else if (e.key === "Enter") {
        e.preventDefault();
        if (filteredMentions[selectedMentionIndex]) {
          handleMentionSelect(filteredMentions[selectedMentionIndex].value);
        }
      } else if (e.key === "Escape") {
        e.preventDefault();
        setShowMentionDropdown(false);
      } else if (e.key === "Tab") {
        e.preventDefault();
        if (filteredMentions[selectedMentionIndex]) {
          handleMentionSelect(filteredMentions[selectedMentionIndex].value);
        }
      }
    } else if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };
  
  const handleMentionSelect = (mention: string) => {
    if (mentionStartIndex !== -1) {
      const beforeMention = input.slice(0, mentionStartIndex);
      const afterMention = input.slice(mentionStartIndex + mentionSearchTerm.length + 1);
      const newValue = `${beforeMention}@${mention} ${afterMention}`;
      handleInputChange(newValue);
      setShowMentionDropdown(false);
      
      // Focus input and move cursor to end of mention
      setTimeout(() => {
        if (inputRef.current) {
          inputRef.current.focus();
          const cursorPosition = beforeMention.length + mention.length + 2;
          inputRef.current.setSelectionRange(cursorPosition, cursorPosition);
        }
      }, 0);
    }
  };

  // Extract agent mentions from message
  const extractAgentMention = (content: string) => {
    const mentionRegex = /@(\w+_AGENT)/gi;
    const match = content.match(mentionRegex);
    if (match) {
      const agentType = match[0].replace("@", "").replace("_AGENT", "").toLowerCase();
      const agent = agents.find(a => a.type === agentType);
      return agent;
    }
    return null;
  };

  // Render message with highlighted mentions
  const renderMessageContent = (content: string) => {
    const mentionRegex = /@(\w+_AGENT)/gi;
    const parts = content.split(mentionRegex);
    
    return parts.map((part, index) => {
      if (part.endsWith("_AGENT")) {
        const agentType = part.replace("_AGENT", "").toLowerCase();
        const label = agentLabels[agentType as keyof typeof agentLabels];
        return (
          <span key={index} className="text-white underline font-medium">
            @{label || part}
          </span>
        );
      }
      return part;
    });
  };

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.95, y: 20 }}
      animate={{ opacity: 1, scale: 1, y: 0 }}
      transition={{ duration: 0.2 }}
      className="fixed bottom-4 right-4 z-50"
      style={{ width: isMinimized ? "auto" : "384px" }}
    >
      <Card className={`shadow-lg ${isMinimized ? "p-2" : "py-0"}`}>
        {/* Header */}
        <div className={`flex items-center justify-between ${!isMinimized ? "p-4 border-b" : ""}`}>
          {!isMinimized && (
            <div className="flex items-center gap-2">
              <MessageSquare className="h-5 w-5 text-primary" />
              <h3 className="font-semibold">AI Assistant</h3>
            </div>
          )}
          <div className="flex items-center gap-1">
            <Button
              size="icon"
              variant="ghost"
              className="h-8 w-8"
              onClick={() => setIsMinimized(!isMinimized)}
            >
              {isMinimized ? (
                <Maximize2 className="h-4 w-4" />
              ) : (
                <Minimize2 className="h-4 w-4" />
              )}
            </Button>
          </div>
        </div>

        {/* Chat Content */}
        {!isMinimized && (
          <>

            {/* Messages */}
            <ScrollArea className="h-[300px]" ref={scrollAreaRef}>
              <div className="p-4 space-y-4">
                {messages.length === 0 ? (
                  <div className="text-center text-muted-foreground text-sm py-8">
                    <MessageSquare className="h-8 w-8 mx-auto mb-2 opacity-50" />
                    <p>Start a conversation with your AI agents</p>
                    <p className="text-xs mt-2">Click "Chat" on any agent node to mention them</p>
                  </div>
                ) : (
                  messages.map((message) => {
                    const mentionedAgent = message.agentId ? 
                      agents.find(a => a.id === message.agentId) : 
                      extractAgentMention(message.content);
                    
                    return (
                      <div
                        key={message.id}
                        className={`flex gap-3 ${
                          message.role === "user" ? "justify-end" : "justify-start"
                        }`}
                      >
                        {message.role === "ai" && (
                          <div className="flex-shrink-0 w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center">
                            <Bot className="h-4 w-4 text-primary" />
                          </div>
                        )}
                        <div
                          className={`max-w-[80%] ${
                            message.role === "user"
                              ? ""
                              : ""
                          }`}
                        >
                          {mentionedAgent && message.role === "ai" && (
                            <div className="flex items-center gap-1 text-xs text-muted-foreground mb-1">
                              <AtSign className="h-3 w-3" />
                              <span>{agentLabels[mentionedAgent.type as keyof typeof agentLabels]}</span>
                            </div>
                          )}
                          <div
                            className={`rounded-lg px-3 py-2 ${
                              message.role === "user"
                                ? "bg-primary text-primary-foreground"
                                : "bg-muted"
                            }`}
                          >
                            <p className="text-sm whitespace-pre-wrap">
                              {message.role === "user" ? renderMessageContent(message.content) : message.content}
                            </p>
                          </div>
                          <p className={`text-xs mt-1 ${
                            message.role === "user" 
                              ? "text-right text-muted-foreground" 
                              : "text-muted-foreground"
                          }`}>
                            {new Date(message.timestamp).toLocaleTimeString()}
                          </p>
                        </div>
                        {message.role === "user" && (
                          <div className="flex-shrink-0 w-8 h-8 rounded-full bg-primary flex items-center justify-center">
                            <User className="h-4 w-4 text-primary-foreground" />
                          </div>
                        )}
                      </div>
                    );
                  })
                )}
                {isGenerating && (
                  <div className="flex gap-3 justify-start">
                    <div className="flex-shrink-0 w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center">
                      <Bot className="h-4 w-4 text-primary animate-pulse" />
                    </div>
                    <div className="bg-muted rounded-lg px-3 py-2">
                      <div className="flex gap-1">
                        <span className="w-2 h-2 bg-primary/50 rounded-full animate-bounce" />
                        <span className="w-2 h-2 bg-primary/50 rounded-full animate-bounce delay-100" />
                        <span className="w-2 h-2 bg-primary/50 rounded-full animate-bounce delay-200" />
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </ScrollArea>

            {/* Input */}
            <div className="p-4 border-t">
              <div className="relative">
                <MentionAutocomplete
                  isOpen={showMentionDropdown}
                  searchTerm={mentionSearchTerm}
                  onSelect={handleMentionSelect}
                  selectedIndex={selectedMentionIndex}
                />
                <div className="flex gap-2">
                <Input
                  ref={inputRef}
                  value={input}
                  onChange={(e) => handleInputChange(e.target.value)}
                  onKeyDown={handleKeyPress}
                  placeholder="Ask a question or @mention an agent..."
                  disabled={isGenerating}
                  className="flex-1"
                />
                <Button
                  size="icon"
                  onClick={handleSend}
                  disabled={!input.trim() || isGenerating}
                >
                  <Send className="h-4 w-4" />
                </Button>
                </div>
              </div>
            </div>
          </>
        )}
      </Card>
    </motion.div>
  );
}


================================================
FILE: app/components/canvas/MentionAutocomplete.tsx
================================================
import React, { useRef } from "react";
import { FileText, Image, Twitter } from "lucide-react";
import { Card } from "~/components/ui/card";

interface MentionOption {
  value: string;
  label: string;
  icon: React.ComponentType<{ className?: string }>;
  color: string;
}

const mentionOptions: MentionOption[] = [
  {
    value: "TITLE_AGENT",
    label: "Title Agent",
    icon: FileText,
    color: "text-blue-500",
  },
  {
    value: "DESCRIPTION_AGENT",
    label: "Description Agent",
    icon: FileText,
    color: "text-green-500",
  },
  {
    value: "THUMBNAIL_AGENT",
    label: "Thumbnail Agent",
    icon: Image,
    color: "text-purple-500",
  },
  {
    value: "TWEETS_AGENT",
    label: "Tweets Agent",
    icon: Twitter,
    color: "text-sky-500",
  },
];

interface MentionAutocompleteProps {
  isOpen: boolean;
  searchTerm: string;
  onSelect: (value: string) => void;
  selectedIndex?: number;
}

export function MentionAutocomplete({ 
  isOpen, 
  searchTerm, 
  onSelect,
  selectedIndex = 0
}: MentionAutocompleteProps) {
  const dropdownRef = useRef<HTMLDivElement>(null);
  
  if (!isOpen) return null;
  
  const filteredOptions = mentionOptions.filter(option =>
    option.label.toLowerCase().includes(searchTerm.toLowerCase()) ||
    option.value.toLowerCase().includes(searchTerm.toLowerCase())
  );
  
  return (
    <div 
      ref={dropdownRef}
      className="absolute bottom-full mb-2 left-0 right-0 z-[60]"
    >
      <Card className="p-1 shadow-lg bg-background border">
        {filteredOptions.length === 0 ? (
          <div className="px-3 py-2 text-sm text-muted-foreground">
            No agents found
          </div>
        ) : (
          <div className="max-h-48 overflow-y-auto">
            <div className="px-2 py-1.5 text-xs font-medium text-muted-foreground">
              Available Agents
            </div>
            {filteredOptions.map((option, index) => {
              const Icon = option.icon;
              const isSelected = index === selectedIndex;
              return (
                <div
                  key={option.value}
                  onClick={() => onSelect(option.value)}
                  className={`flex items-center gap-2 px-2 py-1.5 cursor-pointer rounded-sm transition-colors ${
                    isSelected ? 'bg-accent text-accent-foreground' : 'hover:bg-accent hover:text-accent-foreground'
                  }`}
                >
                  <Icon className={`h-4 w-4 ${option.color}`} />
                  <span className="text-sm">{option.label}</span>
                  <span className="ml-auto text-xs text-muted-foreground">
                    @{option.value}
                  </span>
                </div>
              );
            })}
          </div>
        )}
      </Card>
    </div>
  );
}


================================================
FILE: app/components/canvas/PromptModal.tsx
================================================
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "~/components/ui/dialog";
import { ScrollArea } from "~/components/ui/scroll-area";
import { Brain, Copy, CheckCircle } from "lucide-react";
import { Button } from "~/components/ui/button";
import { useState } from "react";
import { toast } from "sonner";

interface PromptModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  agentType: string;
  prompt: string;
}

const agentLabels = {
  title: "Title Generator",
  description: "Description Writer",
  thumbnail: "Thumbnail Designer",
  tweets: "Social Media Agent",
};

export function PromptModal({ open, onOpenChange, agentType, prompt }: PromptModalProps) {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(prompt);
      setCopied(true);
      toast.success("Prompt copied to clipboard!");
      setTimeout(() => setCopied(false), 2000);
    } catch (error) {
      toast.error("Failed to copy prompt");
    }
  };

  // Format the prompt for better readability
  const formatPrompt = (text: string) => {
    return text
      .split('\n')
      .map((line, index) => {
        // Highlight headers (lines with emojis or all caps)
        if (line.match(/^[üéØüìäüé®‚úÖüí°]/)) {
          return <div key={index} className="font-semibold text-primary mt-4 mb-2">{line}</div>;
        }
        // Highlight section headers
        if (line.match(/^[A-Z\s]+:$/)) {
          return <div key={index} className="font-semibold mt-3 mb-1">{line}</div>;
        }
        // Regular lines
        if (line.trim()) {
          return <div key={index} className="mb-1">{line}</div>;
        }
        // Empty lines
        return <div key={index} className="h-2" />;
      });
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-3xl max-h-[80vh]">
        <DialogHeader className="space-y-3">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Brain className="h-5 w-5 text-primary" />
              <DialogTitle className="text-xl">
                Generation Prompt - {agentLabels[agentType as keyof typeof agentLabels]}
              </DialogTitle>
            </div>
            <Button
              size="sm"
              variant="outline"
              onClick={handleCopy}
              className="gap-2"
            >
              {copied ? (
                <>
                  <CheckCircle className="h-4 w-4 text-green-500" />
                  Copied!
                </>
              ) : (
                <>
                  <Copy className="h-4 w-4" />
                  Copy
                </>
              )}
            </Button>
          </div>
          <p className="text-sm text-muted-foreground">
            This is the exact prompt that was sent to the AI model to generate your content.
          </p>
        </DialogHeader>
        
        <ScrollArea className="h-[60vh] w-full rounded-md border p-4 bg-muted/20">
          <div className="font-mono text-sm text-foreground/90 whitespace-pre-wrap">
            {formatPrompt(prompt)}
          </div>
        </ScrollArea>
      </DialogContent>
    </Dialog>
  );
}


================================================
FILE: app/components/canvas/ReactFlowComponents.tsx
================================================
// Re-export everything from React Flow
// This file is only imported on the client side via dynamic import
export {
  ReactFlow,
  ReactFlowProvider,
  Background,
  Controls,
  MiniMap,
  Handle,
  Position,
  useNodesState,
  useEdgesState,
  addEdge,
  type NodeProps,
  type EdgeProps,
  type Node,
  type Edge,
  type OnConnect,
  type NodeTypes,
  type ReactFlowProps,
  type ReactFlowInstance,
} from "@xyflow/react";


================================================
FILE: app/components/canvas/ReactFlowWrapper.tsx
================================================
import { useEffect, useState } from "react";
import type { ReactNode } from "react";

interface ReactFlowWrapperProps {
  children: (components: {
    ReactFlow: any;
    ReactFlowProvider: any;
    Background: any;
    Controls: any;
    MiniMap: any;
    useNodesState: any;
    useEdgesState: any;
    addEdge: any;
  }) => ReactNode;
}

export function ReactFlowWrapper({ children }: ReactFlowWrapperProps) {
  const [components, setComponents] = useState<any>(null);

  useEffect(() => {
    // Only import ReactFlow on the client side
    if (typeof window !== "undefined") {
      Promise.all([
        import("@xyflow/react"),
        import("@xyflow/react/dist/style.css"),
      ]).then(([reactFlowModule]) => {
        setComponents({
          ReactFlow: reactFlowModule.ReactFlow,
          ReactFlowProvider: reactFlowModule.ReactFlowProvider,
          Background: reactFlowModule.Background,
          Controls: reactFlowModule.Controls,
          MiniMap: reactFlowModule.MiniMap,
          useNodesState: reactFlowModule.useNodesState,
          useEdgesState: reactFlowModule.useEdgesState,
          addEdge: reactFlowModule.addEdge,
        });
      });
    }
  }, []);

  if (!components) {
    return (
      <div className="flex h-[calc(100vh-var(--header-height))] items-center justify-center">
        <p className="text-muted-foreground">Loading canvas...</p>
      </div>
    );
  }

  return <>{children(components)}</>;
}


================================================
FILE: app/components/canvas/SharedCanvas.tsx
================================================
import { useCallback, useState, useEffect } from "react";
import { ReactFlowWrapper } from "./ReactFlowWrapper";
import { VideoNode } from "./VideoNode";
import { AgentNode } from "./AgentNode";
import type { NodeTypes } from "./ReactFlowComponents";
import { Button } from "~/components/ui/button";
import { ArrowLeft, Eye } from "lucide-react";
import { Link } from "react-router";
import { PreviewModal } from "~/components/preview/PreviewModal";

const nodeTypes: NodeTypes = {
  video: VideoNode,
  agent: AgentNode,
};

interface SharedCanvasProps {
  data: {
    share: {
      shareId: string;
      canvasState: {
        nodes: any[];
        edges: any[];
        viewport?: {
          x: number;
          y: number;
          zoom: number;
        };
      };
      viewCount: number;
    };
    project: {
      name: string;
      thumbnail?: string;
    };
    video: {
      _id: string;
      title: string;
      url: string;
      duration: number;
      fileSize: number;
      transcription?: string;
    };
    agents: Array<{
      _id: string;
      type: string;
      draft: string;
      thumbnailUrl?: string;
      status: string;
    }>;
  };
}

export function SharedCanvas({ data }: SharedCanvasProps) {
  const { share, project, video, agents } = data;
  const [previewOpen, setPreviewOpen] = useState(true); // Open by default

  // Prepare content for preview
  const previewContent = {
    title: agents.find(a => a.type === 'title')?.draft || '',
    description: agents.find(a => a.type === 'description')?.draft || '',
    thumbnailUrl: agents.find(a => a.type === 'thumbnail')?.thumbnailUrl || '',
    tweets: agents.find(a => a.type === 'tweets')?.draft || '',
    videoUrl: video.url,
    videoTitle: video.title,
    channelName: project.name,
  };

  // Create node data with read-only handlers
  const preparedNodes = share.canvasState.nodes.map(node => {
    if (node.type === 'video') {
      return {
        ...node,
        data: {
          ...node.data,
          title: video.title,
          videoUrl: video.url,
          duration: video.duration,
          fileSize: video.fileSize,
          hasTranscription: !!video.transcription,
          onView: () => {}, // No-op for read-only view
        }
      };
    } else if (node.type === 'agent') {
      const agent = agents.find(a => node.data.agentId === a._id);
      return {
        ...node,
        data: {
          ...node.data,
          draft: agent?.draft || node.data.draft,
          thumbnailUrl: agent?.thumbnailUrl || node.data.thumbnailUrl,
          status: agent?.status || node.data.status,
          onGenerate: () => {}, // No-op
          onRegenerate: () => {}, // No-op
          onChat: () => {}, // No-op
          onView: () => {}, // No-op
        }
      };
    }
    return node;
  });

  return (
    <ReactFlowWrapper>
      {({ ReactFlow, ReactFlowProvider, Background, Controls, MiniMap }) => (
        <ReactFlowProvider>
          <div className="h-full w-full relative">
            {/* Header */}
            <div className="absolute top-0 left-0 right-0 z-10 bg-background/95 backdrop-blur-sm border-b">
              <div className="flex items-center justify-between p-4">
                <div className="flex items-center gap-4">
                  <Link to="/">
                    <Button variant="ghost" size="sm">
                      <ArrowLeft className="h-4 w-4 mr-2" />
                      Back to App
                    </Button>
                  </Link>
                  <div>
                    <h1 className="text-lg font-semibold">{project.name}</h1>
                    <p className="text-sm text-muted-foreground">Read-only view</p>
                  </div>
                </div>
                <div className="flex items-center gap-4">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setPreviewOpen(true)}
                  >
                    <Eye className="h-4 w-4 mr-2" />
                    View Preview
                  </Button>
                  <div className="flex items-center gap-2 text-sm text-muted-foreground">
                    <Eye className="h-4 w-4" />
                    <span>{share.viewCount} views</span>
                  </div>
                </div>
              </div>
            </div>

            {/* Canvas */}
            <div className="h-full pt-16">
              <ReactFlow
                nodes={preparedNodes}
                edges={share.canvasState.edges}
                nodeTypes={nodeTypes}
                defaultViewport={share.canvasState.viewport}
                fitView
                nodesDraggable={false}
                nodesConnectable={false}
                elementsSelectable={false}
                zoomOnScroll={true}
                zoomOnPinch={true}
                panOnScroll={true}
                panOnDrag={true}
              >
                <Background 
                  variant="dots" 
                  gap={20} 
                  size={1} 
                  color="#888"
                  className="opacity-[0.03]"
                />
                <Controls 
                  showInteractive={false}
                  className="!bottom-4 !left-4"
                />
                <MiniMap 
                  className="!bottom-4 !right-4 !shadow-xl !border !border-border/50 !bg-background/95 !backdrop-blur-sm"
                  nodeColor={(node: any) => {
                    if (node.type === 'video') return '#3b82f6';
                    if (node.type === 'agent') {
                      const agentType = node.data?.type;
                      if (agentType === 'title') return '#3b82f6';
                      if (agentType === 'description') return '#10b981';
                      if (agentType === 'thumbnail') return '#a855f7';
                      if (agentType === 'tweets') return '#eab308';
                    }
                    return '#888';
                  }}
                />
              </ReactFlow>
            </div>
          </div>
          
          {/* Preview Modal - Open by default for shared views */}
          <PreviewModal
            isOpen={previewOpen}
            onClose={() => setPreviewOpen(false)}
            title={previewContent.title}
            description={previewContent.description}
            thumbnailUrl={previewContent.thumbnailUrl}
            tweets={previewContent.tweets}
            videoUrl={previewContent.videoUrl}
            duration={video.duration}
            channelName={previewContent.channelName}
          />
        </ReactFlowProvider>
      )}
    </ReactFlowWrapper>
  );
}


================================================
FILE: app/components/canvas/ThumbnailUploadModal.tsx
================================================
import { useState, useRef } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "~/components/ui/dialog";
import { Button } from "~/components/ui/button";
import { Upload, X, Image as ImageIcon } from "lucide-react";
import { cn } from "~/lib/utils";

interface ThumbnailUploadModalProps {
  isOpen: boolean;
  onClose: () => void;
  onUpload: (images: File[]) => void;
  isGenerating?: boolean;
}

export function ThumbnailUploadModal({ isOpen, onClose, onUpload, isGenerating }: ThumbnailUploadModalProps) {
  const [selectedImages, setSelectedImages] = useState<File[]>([]);
  const [previewUrls, setPreviewUrls] = useState<string[]>([]);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files || []);
    if (files.length === 0) return;

    // Filter only image files
    const imageFiles = files.filter(file => file.type.startsWith('image/'));
    
    // Limit to 3 images
    const newImages = [...selectedImages, ...imageFiles].slice(0, 3);
    setSelectedImages(newImages);

    // Create preview URLs
    const newPreviewUrls = newImages.map(file => URL.createObjectURL(file));
    // Clean up old URLs
    previewUrls.forEach(url => URL.revokeObjectURL(url));
    setPreviewUrls(newPreviewUrls);
  };

  const removeImage = (index: number) => {
    const newImages = selectedImages.filter((_, i) => i !== index);
    setSelectedImages(newImages);
    
    // Clean up URL
    URL.revokeObjectURL(previewUrls[index]);
    const newPreviewUrls = previewUrls.filter((_, i) => i !== index);
    setPreviewUrls(newPreviewUrls);
  };

  const handleSubmit = () => {
    if (selectedImages.length === 0) return;
    onUpload(selectedImages);
  };

  const handleClose = () => {
    // Clean up URLs
    previewUrls.forEach(url => URL.revokeObjectURL(url));
    setSelectedImages([]);
    setPreviewUrls([]);
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>Upload Images for Thumbnail</DialogTitle>
          <DialogDescription>
            Upload 1-3 images that will be used to generate a YouTube thumbnail. 
            The AI will analyze your images and create a professional thumbnail based on them with text overlays.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4">
          {/* Upload Area */}
          <div
            className={cn(
              "border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition-colors",
              "hover:border-primary hover:bg-muted/50",
              selectedImages.length >= 3 && "opacity-50 cursor-not-allowed"
            )}
            onClick={() => selectedImages.length < 3 && fileInputRef.current?.click()}
          >
            <input
              ref={fileInputRef}
              type="file"
              multiple
              accept="image/*"
              onChange={handleFileSelect}
              className="hidden"
              disabled={selectedImages.length >= 3}
            />
            <Upload className="h-10 w-10 mx-auto mb-3 text-muted-foreground" />
            <p className="text-sm font-medium mb-1">
              {selectedImages.length === 0 
                ? "Click to upload images" 
                : selectedImages.length >= 3 
                ? "Maximum 3 images allowed" 
                : `Add more images (${3 - selectedImages.length} remaining)`}
            </p>
            <p className="text-xs text-muted-foreground">
              PNG, JPG, WEBP up to 10MB each
            </p>
          </div>

          {/* Preview Grid */}
          {selectedImages.length > 0 && (
            <div className="grid grid-cols-3 gap-3">
              {previewUrls.map((url, index) => (
                <div key={index} className="relative group">
                  <img
                    src={url}
                    alt={`Preview ${index + 1}`}
                    className="w-full h-32 object-cover rounded-lg border"
                  />
                  <button
                    onClick={() => removeImage(index)}
                    className="absolute top-2 right-2 p-1 bg-red-500 text-white rounded-full opacity-0 group-hover:opacity-100 transition-opacity"
                  >
                    <X className="h-4 w-4" />
                  </button>
                  <div className="absolute bottom-2 left-2 bg-black/70 text-white text-xs px-2 py-1 rounded">
                    Image {index + 1}
                  </div>
                </div>
              ))}
              {/* Empty slots */}
              {Array.from({ length: 3 - selectedImages.length }).map((_, index) => (
                <div
                  key={`empty-${index}`}
                  className="h-32 border-2 border-dashed border-muted-foreground/25 rounded-lg flex items-center justify-center"
                >
                  <ImageIcon className="h-8 w-8 text-muted-foreground/25" />
                </div>
              ))}
            </div>
          )}

          <div className="text-sm text-muted-foreground">
            <p className="font-medium mb-1">Tips for best results:</p>
            <ul className="list-disc list-inside space-y-1 text-xs">
              <li>Upload images that represent your video content</li>
              <li>The AI will analyze and recreate them as a professional thumbnail</li>
              <li>Text overlays will be added automatically</li>
              <li>The final thumbnail will be optimized for YouTube</li>
            </ul>
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={handleClose} disabled={isGenerating}>
            Cancel
          </Button>
          <Button 
            onClick={handleSubmit} 
            disabled={selectedImages.length === 0 || isGenerating}
          >
            {isGenerating ? "Generating..." : `Generate Thumbnail (${selectedImages.length} image${selectedImages.length !== 1 ? 's' : ''})`}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


================================================
FILE: app/components/canvas/VideoNode.tsx
================================================
import { memo, useState, useRef, useEffect } from "react";
import { Handle, Position, type NodeProps } from "./ReactFlowComponents";
import { Play, Film, Loader2, FileText, AlertCircle, RefreshCw, Sparkles, Clock, HardDrive } from "lucide-react";
import { Card } from "~/components/ui/card";
import { Button } from "~/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "~/components/ui/tooltip";

export interface VideoNodeData {
  title?: string;
  videoUrl?: string;
  fileId?: string;
  storageId?: string;
  thumbnail?: string;
  duration?: number; // in seconds
  fileSize?: number; // in bytes
  isUploading?: boolean;
  isTranscribing?: boolean;
  hasTranscription?: boolean;
  isExtracting?: boolean;
  extractionProgress?: number;
  transcriptionError?: string | null;
  transcriptionProgress?: string | null;
  onVideoClick?: () => void;
  onRetryTranscription?: () => void;
}

export const VideoNode = memo(({ data, selected }: NodeProps) => {
  const videoData = data as VideoNodeData;
  const [isHovering, setIsHovering] = useState(false);
  const [showPreview, setShowPreview] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const hoverTimeoutRef = useRef<NodeJS.Timeout>();
  
  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
    };
  }, []);
  
  // Format duration from seconds to mm:ss
  const formatDuration = (seconds?: number) => {
    if (!seconds) return null;
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };
  
  // Format file size
  const formatFileSize = (bytes?: number) => {
    if (!bytes) return null;
    const mb = bytes / (1024 * 1024);
    return `${mb.toFixed(1)} MB`;
  };
  return (
    <div className={`relative group ${selected ? "scale-105" : ""} transition-transform duration-200`}>
      {/* Glow effect when selected */}
      {selected && (
        <div className="absolute -inset-1 bg-gradient-to-r from-primary/20 via-purple-500/20 to-primary/20 rounded-2xl blur-lg animate-pulse" />
      )}
      
      <Card className={`relative w-80 p-5 border-muted/50 shadow-xl bg-gradient-to-b from-background to-background/90 backdrop-blur-sm transition-all duration-300 hover:shadow-2xl ${selected ? "border-primary/50" : ""}`}>
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center gap-3">
            <div className="p-2 rounded-lg bg-gradient-to-br from-blue-500/20 to-cyan-500/20 backdrop-blur-sm">
              <Film className="h-5 w-5 text-blue-500" />
            </div>
            <div>
              <h3 className="font-semibold text-foreground">Video Source</h3>
              <p className="text-xs text-muted-foreground">Input media</p>
            </div>
          </div>
          <Sparkles className="h-4 w-4 text-muted-foreground/50" />
        </div>
      
      {videoData.isUploading ? (
        <div className="mb-3 aspect-video bg-gradient-to-br from-muted/50 to-muted/30 rounded-xl flex items-center justify-center">
          <div className="text-center">
            <div className="relative">
              <div className="absolute inset-0 bg-primary/20 rounded-full blur-xl animate-pulse" />
              <Loader2 className="relative h-10 w-10 text-primary animate-spin mx-auto mb-3" />
            </div>
            <p className="text-sm font-medium">Uploading video...</p>
            <p className="text-xs text-muted-foreground mt-1">Please wait</p>
          </div>
        </div>
      ) : videoData.videoUrl ? (
        <div 
          className="relative mb-3 aspect-video bg-black rounded-xl overflow-hidden cursor-pointer group/video shadow-lg"
          onClick={() => {
            if (videoData.onVideoClick) {
              videoData.onVideoClick();
            }
          }}
          onMouseEnter={() => {
            setIsHovering(true);
            // Delay preview to avoid flickering on quick hovers
            hoverTimeoutRef.current = setTimeout(() => {
              setShowPreview(true);
              if (videoRef.current) {
                videoRef.current.currentTime = 0;
                videoRef.current.play().catch(() => {
                  // Ignore autoplay errors
                });
              }
            }, 300);
          }}
          onMouseLeave={() => {
            setIsHovering(false);
            setShowPreview(false);
            if (hoverTimeoutRef.current) {
              clearTimeout(hoverTimeoutRef.current);
            }
            if (videoRef.current) {
              videoRef.current.pause();
              videoRef.current.currentTime = 0;
            }
          }}
        >
          {/* Thumbnail/Static view */}
          {!showPreview && (
            <>
              <video
                src={videoData.videoUrl}
                className="w-full h-full object-cover"
                preload="metadata"
                muted
              />
              <div className="absolute inset-0 flex items-center justify-center bg-gradient-to-t from-black/50 via-black/20 to-transparent transition-all duration-300 group-hover/video:bg-black/40">
                <div className="relative">
                  <div className="absolute inset-0 bg-white rounded-full blur-xl opacity-50 group-hover/video:opacity-70 transition-opacity" />
                  <div className="relative bg-white rounded-full p-4 shadow-2xl transform transition-all duration-300 group-hover/video:scale-110">
                    <Play className="h-6 w-6 text-black ml-0.5" />
                  </div>
                </div>
              </div>
              {/* Duration badge */}
              {formatDuration(videoData.duration) && (
                <div className="absolute bottom-2 right-2 bg-black/70 text-white text-xs px-2 py-0.5 rounded">
                  {formatDuration(videoData.duration)}
                </div>
              )}
            </>
          )}
          
          {/* Preview video */}
          {showPreview && (
            <video
              ref={videoRef}
              src={videoData.videoUrl}
              className="w-full h-full object-cover"
              muted
              loop
              playsInline
              preload="metadata"
            >
              Your browser does not support the video tag.
            </video>
          )}
          
          {/* Hover indicator */}
          {isHovering && !showPreview && (
            <div className="absolute top-2 right-2 bg-black/70 text-white text-xs px-2 py-1 rounded animate-pulse">
              Loading preview...
            </div>
          )}
          
          {/* Preview indicator */}
          {showPreview && (
            <div className="absolute bottom-2 left-2 bg-black/70 text-white text-xs px-2 py-1 rounded flex items-center gap-1">
              <div className="w-2 h-2 bg-red-500 rounded-full animate-pulse" />
              Preview
            </div>
          )}
        </div>
      ) : videoData.thumbnail ? (
        <div className="relative mb-3 aspect-video bg-black rounded-xl overflow-hidden shadow-lg">
          <img 
            src={videoData.thumbnail} 
            alt={videoData.title || "Video thumbnail"} 
            className="w-full h-full object-cover"
          />
          <div className="absolute inset-0 flex items-center justify-center bg-gradient-to-t from-black/50 via-black/20 to-transparent">
            <div className="bg-white/90 rounded-full p-3 shadow-lg">
              <Play className="h-6 w-6 text-gray-800 ml-0.5" />
            </div>
          </div>
        </div>
      ) : (
        <div className="mb-3 aspect-video bg-gradient-to-br from-muted/50 to-muted/30 rounded-xl flex items-center justify-center border border-dashed border-muted-foreground/20">
          <div className="text-center">
            <Film className="h-10 w-10 text-muted-foreground/50 mx-auto mb-2" />
            <p className="text-xs text-muted-foreground">No video loaded</p>
          </div>
        </div>
      )}
      
      <div className="space-y-3">
        <div>
          <p className="text-sm font-semibold text-foreground truncate">
            {videoData.title || "Untitled Video"}
          </p>
          
          {/* File info with icons */}
          {(videoData.duration || videoData.fileSize) && (
            <div className="flex items-center gap-3 mt-2">
              {formatDuration(videoData.duration) && (
                <div className="flex items-center gap-1.5 text-xs text-muted-foreground">
                  <Clock className="h-3 w-3" />
                  <span>{formatDuration(videoData.duration)}</span>
                </div>
              )}
              {formatFileSize(videoData.fileSize) && (
                <div className="flex items-center gap-1.5 text-xs text-muted-foreground">
                  <HardDrive className="h-3 w-3" />
                  <span>{formatFileSize(videoData.fileSize)}</span>
                </div>
              )}
            </div>
          )}
        </div>
        
        {/* Transcription status card */}
        <div className="rounded-lg bg-muted/50 p-3 border border-border/50">
          {videoData.isExtracting && (
            <div className="flex items-center gap-2">
              <div className="relative">
                <div className="absolute inset-0 bg-blue-500/20 rounded-full blur animate-pulse" />
                <Loader2 className="relative h-4 w-4 animate-spin text-blue-500" />
              </div>
              <div className="flex-1">
                <p className="text-xs font-medium">Extracting audio...</p>
                {videoData.transcriptionProgress && (
                  <p className="text-[10px] text-muted-foreground mt-0.5">{videoData.transcriptionProgress}</p>
                )}
              </div>
            </div>
          )}
          {!videoData.isExtracting && videoData.isTranscribing && (
            <div className="flex items-center gap-2">
              <div className="relative">
                <div className="absolute inset-0 bg-primary/20 rounded-full blur animate-pulse" />
                <Loader2 className="relative h-4 w-4 animate-spin text-primary" />
              </div>
              <div className="flex-1">
                <p className="text-xs font-medium">Transcribing video...</p>
                {videoData.transcriptionProgress && (
                  <p className="text-[10px] text-muted-foreground mt-0.5">{videoData.transcriptionProgress}</p>
                )}
              </div>
            </div>
          )}
          {!videoData.isExtracting && !videoData.isTranscribing && videoData.hasTranscription && (
            <div className="flex items-center justify-between gap-2">
              <div className="flex items-center gap-2">
                <div className="p-1 rounded-full bg-green-500/10">
                  <FileText className="h-3.5 w-3.5 text-green-500" />
                </div>
                <p className="text-xs font-medium text-green-600">Transcription ready</p>
              </div>
              {videoData.onRetryTranscription && (
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button
                        size="icon"
                        variant="ghost"
                        className="h-6 w-6 hover:bg-primary/10"
                        onClick={videoData.onRetryTranscription}
                      >
                        <RefreshCw className="h-3 w-3" />
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      <p className="text-xs">Re-transcribe video</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              )}
            </div>
          )}
          {!videoData.isExtracting && !videoData.isTranscribing && videoData.hasTranscription === false && (
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <div className="space-y-1.5 cursor-help">
                    <div className="flex items-center gap-2">
                      <div className="p-1 rounded-full bg-yellow-500/10">
                        <AlertCircle className="h-3.5 w-3.5 text-yellow-600" />
                      </div>
                      <p className="text-xs font-medium text-yellow-600">
                        {videoData.transcriptionError ? "Transcription failed" : "No transcription"}
                      </p>
                    </div>
                    {videoData.transcriptionError && (
                      <p className="text-[10px] text-muted-foreground pl-7 break-words">
                        {videoData.transcriptionError}
                      </p>
                    )}
                  </div>
                </TooltipTrigger>
                {videoData.transcriptionError && (
                  <TooltipContent className="max-w-xs">
                    <p className="text-sm">{videoData.transcriptionError}</p>
                    <p className="text-xs text-muted-foreground mt-1">The video was uploaded successfully.</p>
                  </TooltipContent>
                )}
              </Tooltip>
            </TooltipProvider>
          )}
        </div>
      </div>
      
      {/* Error action button */}
      {!videoData.isUploading && !videoData.isTranscribing && !videoData.isExtracting && 
       videoData.transcriptionError && videoData.onRetryTranscription && (
        <Button
          variant="outline"
          size="sm"
          className="mt-2 w-full hover:bg-primary/10 hover:border-primary/50 transition-all"
          onClick={videoData.onRetryTranscription}
        >
          <RefreshCw className="h-3 w-3 mr-1.5" />
          Retry Transcription
        </Button>
      )}
      
      <Handle
        type="source"
        position={Position.Right}
        id="video-output"
        className="!w-3 !h-3 !bg-gradient-to-r !from-blue-500 !to-cyan-500 !border-2 !border-background"
        style={{ top: '50%' }}
      />
    </Card>
    </div>
  );
});

VideoNode.displayName = "VideoNode";


================================================
FILE: app/components/canvas/VideoPlayerModal.tsx
================================================
import { Dialog, DialogContent } from "~/components/ui/dialog";
import { Button } from "~/components/ui/button";
import { X, Download, Maximize2, Play, Pause, Volume2, VolumeX, Loader2 } from "lucide-react";
import { useState, useRef, useEffect } from "react";
import { cn } from "~/lib/utils";

interface VideoPlayerModalProps {
  isOpen: boolean;
  onClose: () => void;
  videoUrl: string;
  title: string;
  duration?: number;
  fileSize?: number;
}

export function VideoPlayerModal({ 
  isOpen, 
  onClose, 
  videoUrl, 
  title,
  duration,
  fileSize
}: VideoPlayerModalProps) {
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [isMuted, setIsMuted] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [showControls, setShowControls] = useState(true);
  const [videoDuration, setVideoDuration] = useState(0);
  const videoRef = useRef<HTMLVideoElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const controlsTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Format duration
  const formatDuration = (seconds?: number) => {
    if (!seconds && seconds !== 0) return "0:00";
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  // Format file size
  const formatFileSize = (bytes?: number) => {
    if (!bytes) return null;
    const mb = bytes / (1024 * 1024);
    return `${mb.toFixed(1)} MB`;
  };

  // Show controls temporarily
  const showControlsTemporarily = () => {
    setShowControls(true);
    if (controlsTimeoutRef.current) {
      clearTimeout(controlsTimeoutRef.current);
    }
    if (isPlaying) {
      controlsTimeoutRef.current = setTimeout(() => {
        setShowControls(false);
      }, 3000);
    }
  };

  // Handle play/pause
  const togglePlayPause = () => {
    if (!videoRef.current) return;
    
    if (videoRef.current.paused) {
      videoRef.current.play()
        .then(() => setIsPlaying(true))
        .catch(() => setIsPlaying(false));
    } else {
      videoRef.current.pause();
      setIsPlaying(false);
    }
  };

  // Handle fullscreen
  const toggleFullscreen = async () => {
    try {
      if (!document.fullscreenElement) {
        // Try to fullscreen the dialog content element
        const dialogElement = containerRef.current?.closest('[role="dialog"]');
        if (dialogElement) {
          await dialogElement.requestFullscreen();
          setIsFullscreen(true);
        }
      } else {
        await document.exitFullscreen();
        setIsFullscreen(false);
      }
    } catch (error) {
      console.error('Fullscreen error:', error);
    }
  };

  // Handle download
  const handleDownload = () => {
    const link = document.createElement('a');
    link.href = videoUrl;
    link.download = title || 'video.mp4';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Update video state
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    // Sync initial state
    setIsPlaying(!video.paused);
    setCurrentTime(video.currentTime || 0);
    if (video.duration && !isNaN(video.duration)) {
      setVideoDuration(video.duration);
    }

    const updateTime = () => {
      if (video.currentTime !== undefined && !isNaN(video.currentTime)) {
        setCurrentTime(video.currentTime);
        // Also check if we need to update duration
        if (!videoDuration && video.duration && !isNaN(video.duration) && isFinite(video.duration)) {
          setVideoDuration(video.duration);
        }
      }
    };
    const updatePlayState = () => {
      setIsPlaying(!video.paused);
      showControlsTemporarily();
    };
    const handleLoadStart = () => {
      // Only show loading if the video hasn't loaded metadata yet
      if (video.readyState < 3) {
        setIsLoading(true);
      }
    };
    const handleLoadedData = () => {
      setIsLoading(false);
      setIsPlaying(!video.paused);
    };
    const handleLoadedMetadata = () => {
      if (video.duration && !isNaN(video.duration) && isFinite(video.duration)) {
        setVideoDuration(video.duration);
      }
    };
    const handleDurationChange = () => {
      if (video.duration && !isNaN(video.duration)) {
        setVideoDuration(video.duration);
      }
    };
    const handleWaiting = () => {
      // Only show loading if we're actually waiting for data
      if (video.readyState < 3) {
        setIsLoading(true);
      }
    };
    const handleCanPlay = () => setIsLoading(false);
    const handlePlaying = () => {
      setIsLoading(false);
      setIsPlaying(true);
    };
    const handleError = () => setIsLoading(false);

    video.addEventListener('loadstart', handleLoadStart);
    video.addEventListener('timeupdate', updateTime);
    video.addEventListener('play', updatePlayState);
    video.addEventListener('pause', updatePlayState);
    video.addEventListener('loadeddata', handleLoadedData);
    video.addEventListener('loadedmetadata', handleLoadedMetadata);
    video.addEventListener('durationchange', handleDurationChange);
    video.addEventListener('waiting', handleWaiting);
    video.addEventListener('canplay', handleCanPlay);
    video.addEventListener('playing', handlePlaying);
    video.addEventListener('error', handleError);

    return () => {
      video.removeEventListener('loadstart', handleLoadStart);
      video.removeEventListener('timeupdate', updateTime);
      video.removeEventListener('play', updatePlayState);
      video.removeEventListener('pause', updatePlayState);
      video.removeEventListener('loadeddata', handleLoadedData);
      video.removeEventListener('loadedmetadata', handleLoadedMetadata);
      video.removeEventListener('durationchange', handleDurationChange);
      video.removeEventListener('waiting', handleWaiting);
      video.removeEventListener('canplay', handleCanPlay);
      video.removeEventListener('playing', handlePlaying);
      video.removeEventListener('error', handleError);
    };
  }, [videoDuration]);

  // Auto-play when modal opens
  useEffect(() => {
    if (isOpen && videoRef.current) {
      // Don't set loading here - let the video events handle it
      videoRef.current.play()
        .then(() => {
          setIsPlaying(true);
        })
        .catch(() => {
          // Handle autoplay errors
          setIsPlaying(false);
        });
    } else if (!isOpen) {
      // Reset states when modal closes
      setIsPlaying(false);
      setCurrentTime(0);
      setIsLoading(false);
      setVideoDuration(0);
    }
  }, [isOpen]);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (controlsTimeoutRef.current) {
        clearTimeout(controlsTimeoutRef.current);
      }
    };
  }, []);

  // Handle mouse movement
  useEffect(() => {
    showControlsTemporarily();
  }, [isPlaying]);

  // Ensure play state is synced
  useEffect(() => {
    if (!isOpen || !videoRef.current) return;

    const checkPlayState = () => {
      if (videoRef.current && !videoRef.current.paused && !isPlaying) {
        setIsPlaying(true);
      } else if (videoRef.current && videoRef.current.paused && isPlaying) {
        setIsPlaying(false);
      }
    };

    // Check immediately
    checkPlayState();

    // Check periodically to ensure sync
    const interval = setInterval(checkPlayState, 100);

    return () => clearInterval(interval);
  }, [isOpen, isPlaying]);

  // Handle fullscreen changes
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    document.addEventListener('MSFullscreenChange', handleFullscreenChange);

    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
      document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
      document.removeEventListener('mozfullscreenchange', handleFullscreenChange);
      document.removeEventListener('MSFullscreenChange', handleFullscreenChange);
    };
  }, []);

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent 
        className="max-w-5xl p-0 overflow-hidden bg-black rounded-xl"
        ref={containerRef}
      >
        <div 
          className="relative w-full h-full rounded-xl"
          onMouseMove={showControlsTemporarily}
          onMouseLeave={() => isPlaying && setShowControls(false)}
        >
          {/* Header */}
          <div className={cn(
            "absolute top-0 left-0 right-0 z-20 p-4 bg-gradient-to-b from-black/90 to-transparent transition-opacity duration-300 rounded-t-xl",
            showControls ? "opacity-100" : "opacity-0"
          )}>
            <div className="flex items-start justify-between">
              <div className="flex-1 mr-4">
                <h2 className="text-white font-semibold text-lg truncate">
                  {title || "Video Player"}
                </h2>
                <div className="flex items-center gap-3 text-white/70 text-sm mt-1">
                  {(videoDuration || duration) && (
                    <span>Duration: {formatDuration(videoDuration || duration)}</span>
                  )}
                  {fileSize && (
                    <>
                      <span>‚Ä¢</span>
                      <span>{formatFileSize(fileSize)}</span>
                    </>
                  )}
                </div>
              </div>
              <Button
                variant="ghost"
                size="icon"
                onClick={onClose}
                className="text-white hover:bg-white/20"
              >
                <X className="h-5 w-5" />
              </Button>
            </div>
          </div>

          {/* Video */}
          <div className="relative flex items-center justify-center bg-black rounded-xl" style={{ minHeight: "400px" }}>
            <video
              ref={videoRef}
              src={videoUrl}
              className="w-full h-full max-h-[80vh] cursor-pointer rounded-xl"
              muted={isMuted}
              onClick={togglePlayPause}
              playsInline
            >
              Your browser does not support the video tag.
            </video>

            {/* Loading indicator */}
            {isLoading && (
              <div className="absolute inset-0 flex items-center justify-center bg-black/50">
                <Loader2 className="h-12 w-12 text-white animate-spin" />
              </div>
            )}

            {/* Play/Pause overlay - only show when paused */}
            {!isPlaying && !isLoading && (
              <div 
                className="absolute inset-0 flex items-center justify-center pointer-events-none"
                key={isPlaying ? 'playing' : 'paused'}
              >
                <div className="bg-black/50 rounded-full p-6 backdrop-blur-sm">
                  <Play className="h-16 w-16 text-white ml-2" />
                </div>
              </div>
            )}
          </div>

          {/* Bottom controls */}
          <div className={cn(
            "absolute bottom-0 left-0 right-0 z-20 bg-gradient-to-t from-black/90 to-transparent transition-opacity duration-300 rounded-b-xl",
            showControls ? "opacity-100" : "opacity-0"
          )}>
            {/* Progress bar */}
            <div className="px-4 pb-2">
              <div 
                className="relative h-2 bg-white/20 rounded-full overflow-hidden cursor-pointer group hover:h-3 transition-all"
                onClick={(e) => {
                  const rect = e.currentTarget.getBoundingClientRect();
                  const x = e.clientX - rect.left;
                  const percentage = x / rect.width;
                  const time = percentage * (videoDuration || duration || 0);
                  if (videoRef.current && !isNaN(time)) {
                    videoRef.current.currentTime = time;
                    setCurrentTime(time);
                  }
                }}
              >
                <div 
                  className="absolute left-0 top-0 h-full bg-primary rounded-full transition-all"
                  style={{ width: `${(currentTime / (videoDuration || duration || 1)) * 100}%` }}
                />
                <div 
                  className="absolute top-1/2 -translate-y-1/2 w-3 h-3 bg-white rounded-full shadow-lg transition-all opacity-0 group-hover:opacity-100"
                  style={{ left: `${(currentTime / (videoDuration || duration || 1)) * 100}%`, transform: 'translateX(-50%) translateY(-50%)' }}
                />
              </div>
            </div>

            {/* Control buttons */}
            <div className="px-4 pb-4 flex items-center justify-between">
              <div className="flex items-center gap-3">
                {/* Play/Pause */}
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={togglePlayPause}
                  className="text-white hover:bg-white/20"
                >
                  {isPlaying ? <Pause className="h-5 w-5" /> : <Play className="h-5 w-5 ml-0.5" />}
                </Button>

                {/* Volume */}
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={() => {
                    setIsMuted(!isMuted);
                    if (videoRef.current) {
                      videoRef.current.muted = !isMuted;
                    }
                  }}
                  className="text-white hover:bg-white/20"
                >
                  {isMuted ? <VolumeX className="h-5 w-5" /> : <Volume2 className="h-5 w-5" />}
                </Button>

                {/* Time display */}
                <span className="text-white text-sm font-mono">
                  {formatDuration(currentTime)} / {formatDuration(videoDuration || duration || 0)}
                </span>
              </div>

              <div className="flex items-center gap-2">
                {/* Download */}
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={handleDownload}
                  className="text-white hover:bg-white/20"
                >
                  <Download className="h-5 w-5" />
                </Button>

                {/* Fullscreen */}
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={toggleFullscreen}
                  className="text-white hover:bg-white/20"
                >
                  <Maximize2 className="h-5 w-5" />
                </Button>
              </div>
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}


================================================
FILE: app/components/dashboard/app-sidebar.tsx
================================================
import { IconDashboard, IconSettings, IconPalette } from "@tabler/icons-react";
import { MessageCircle, Twitter, Youtube } from "lucide-react";
import { Link } from "react-router";
import { NavMain } from "./nav-main";
import { NavSecondary } from "./nav-secondary";
import { NavUser } from "./nav-user";
import {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarHeader,
  SidebarMenu,
  SidebarMenuItem,
  SidebarGroup,
  SidebarGroupContent,
  SidebarMenuButton,
  SidebarGroupLabel,
} from "~/components/ui/sidebar";

const data = {
  navMain: [
    {
      title: "Projects",
      url: "/dashboard",
      icon: IconDashboard,
    },
  ],
  navSecondary: [
    {
      title: "Settings",
      url: "/dashboard/settings",
      icon: IconSettings,
    },
  ],
};

export function AppSidebar({
  variant,
  user,
}: {
  variant: "sidebar" | "floating" | "inset";
  user: any;
}) {
  return (
    <Sidebar collapsible="offcanvas" variant={variant}>
      <SidebarHeader>
        <SidebarMenu>
          <SidebarMenuItem>
            <Link to="/" prefetch="viewport">
              <span className="text-base font-semibold">YouPac AI</span>
            </Link>
          </SidebarMenuItem>
        </SidebarMenu>
      </SidebarHeader>
      <SidebarContent>
        <NavMain items={data.navMain} />
        
        {/* Social Links */}
        <SidebarGroup className="mt-auto">
          <SidebarGroupLabel>Connect</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              <SidebarMenuItem>
                <SidebarMenuButton asChild>
                  <a 
                    href="https://x.com/rasmickyy" 
                    target="_blank" 
                    rel="noopener noreferrer"
                    className="flex items-center"
                  >
                    <Twitter className="h-4 w-4" />
                    <span>@rasmickyy</span>
                  </a>
                </SidebarMenuButton>
              </SidebarMenuItem>
              <SidebarMenuItem>
                <SidebarMenuButton asChild>
                  <a 
                    href="https://youtube.com/@rasmic" 
                    target="_blank" 
                    rel="noopener noreferrer"
                    className="flex items-center"
                  >
                    <Youtube className="h-4 w-4" />
                    <span>@rasmic</span>
                  </a>
                </SidebarMenuButton>
              </SidebarMenuItem>
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
        
        <NavSecondary items={data.navSecondary} className="mt-2" />
      </SidebarContent>
      <SidebarFooter>{user && <NavUser user={user} />}</SidebarFooter>
    </Sidebar>
  );
}



================================================
FILE: app/components/dashboard/chart-area-interactive.tsx
================================================
"use client"

import * as React from "react"
import { Area, AreaChart, CartesianGrid, XAxis } from "recharts"

import { useIsMobile } from "~/hooks/use-mobile"
import {
  Card,
  CardAction,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card"
import {
  type ChartConfig,
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
} from "~/components/ui/chart"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select"
import {
  ToggleGroup,
  ToggleGroupItem,
} from "~/components/ui/toggle-group"

export const description = "An interactive area chart"

const chartData = [
  { date: "2024-04-01", desktop: 222, mobile: 150 },
  { date: "2024-04-02", desktop: 97, mobile: 180 },
  { date: "2024-04-03", desktop: 167, mobile: 120 },
  { date: "2024-04-04", desktop: 242, mobile: 260 },
  { date: "2024-04-05", desktop: 373, mobile: 290 },
  { date: "2024-04-06", desktop: 301, mobile: 340 },
  { date: "2024-04-07", desktop: 245, mobile: 180 },
  { date: "2024-04-08", desktop: 409, mobile: 320 },
  { date: "2024-04-09", desktop: 59, mobile: 110 },
  { date: "2024-04-10", desktop: 261, mobile: 190 },
  { date: "2024-04-11", desktop: 327, mobile: 350 },
  { date: "2024-04-12", desktop: 292, mobile: 210 },
  { date: "2024-04-13", desktop: 342, mobile: 380 },
  { date: "2024-04-14", desktop: 137, mobile: 220 },
  { date: "2024-04-15", desktop: 120, mobile: 170 },
  { date: "2024-04-16", desktop: 138, mobile: 190 },
  { date: "2024-04-17", desktop: 446, mobile: 360 },
  { date: "2024-04-18", desktop: 364, mobile: 410 },
  { date: "2024-04-19", desktop: 243, mobile: 180 },
  { date: "2024-04-20", desktop: 89, mobile: 150 },
  { date: "2024-04-21", desktop: 137, mobile: 200 },
  { date: "2024-04-22", desktop: 224, mobile: 170 },
  { date: "2024-04-23", desktop: 138, mobile: 230 },
  { date: "2024-04-24", desktop: 387, mobile: 290 },
  { date: "2024-04-25", desktop: 215, mobile: 250 },
  { date: "2024-04-26", desktop: 75, mobile: 130 },
  { date: "2024-04-27", desktop: 383, mobile: 420 },
  { date: "2024-04-28", desktop: 122, mobile: 180 },
  { date: "2024-04-29", desktop: 315, mobile: 240 },
  { date: "2024-04-30", desktop: 454, mobile: 380 },
  { date: "2024-05-01", desktop: 165, mobile: 220 },
  { date: "2024-05-02", desktop: 293, mobile: 310 },
  { date: "2024-05-03", desktop: 247, mobile: 190 },
  { date: "2024-05-04", desktop: 385, mobile: 420 },
  { date: "2024-05-05", desktop: 481, mobile: 390 },
  { date: "2024-05-06", desktop: 498, mobile: 520 },
  { date: "2024-05-07", desktop: 388, mobile: 300 },
  { date: "2024-05-08", desktop: 149, mobile: 210 },
  { date: "2024-05-09", desktop: 227, mobile: 180 },
  { date: "2024-05-10", desktop: 293, mobile: 330 },
  { date: "2024-05-11", desktop: 335, mobile: 270 },
  { date: "2024-05-12", desktop: 197, mobile: 240 },
  { date: "2024-05-13", desktop: 197, mobile: 160 },
  { date: "2024-05-14", desktop: 448, mobile: 490 },
  { date: "2024-05-15", desktop: 473, mobile: 380 },
  { date: "2024-05-16", desktop: 338, mobile: 400 },
  { date: "2024-05-17", desktop: 499, mobile: 420 },
  { date: "2024-05-18", desktop: 315, mobile: 350 },
  { date: "2024-05-19", desktop: 235, mobile: 180 },
  { date: "2024-05-20", desktop: 177, mobile: 230 },
  { date: "2024-05-21", desktop: 82, mobile: 140 },
  { date: "2024-05-22", desktop: 81, mobile: 120 },
  { date: "2024-05-23", desktop: 252, mobile: 290 },
  { date: "2024-05-24", desktop: 294, mobile: 220 },
  { date: "2024-05-25", desktop: 201, mobile: 250 },
  { date: "2024-05-26", desktop: 213, mobile: 170 },
  { date: "2024-05-27", desktop: 420, mobile: 460 },
  { date: "2024-05-28", desktop: 233, mobile: 190 },
  { date: "2024-05-29", desktop: 78, mobile: 130 },
  { date: "2024-05-30", desktop: 340, mobile: 280 },
  { date: "2024-05-31", desktop: 178, mobile: 230 },
  { date: "2024-06-01", desktop: 178, mobile: 200 },
  { date: "2024-06-02", desktop: 470, mobile: 410 },
  { date: "2024-06-03", desktop: 103, mobile: 160 },
  { date: "2024-06-04", desktop: 439, mobile: 380 },
  { date: "2024-06-05", desktop: 88, mobile: 140 },
  { date: "2024-06-06", desktop: 294, mobile: 250 },
  { date: "2024-06-07", desktop: 323, mobile: 370 },
  { date: "2024-06-08", desktop: 385, mobile: 320 },
  { date: "2024-06-09", desktop: 438, mobile: 480 },
  { date: "2024-06-10", desktop: 155, mobile: 200 },
  { date: "2024-06-11", desktop: 92, mobile: 150 },
  { date: "2024-06-12", desktop: 492, mobile: 420 },
  { date: "2024-06-13", desktop: 81, mobile: 130 },
  { date: "2024-06-14", desktop: 426, mobile: 380 },
  { date: "2024-06-15", desktop: 307, mobile: 350 },
  { date: "2024-06-16", desktop: 371, mobile: 310 },
  { date: "2024-06-17", desktop: 475, mobile: 520 },
  { date: "2024-06-18", desktop: 107, mobile: 170 },
  { date: "2024-06-19", desktop: 341, mobile: 290 },
  { date: "2024-06-20", desktop: 408, mobile: 450 },
  { date: "2024-06-21", desktop: 169, mobile: 210 },
  { date: "2024-06-22", desktop: 317, mobile: 270 },
  { date: "2024-06-23", desktop: 480, mobile: 530 },
  { date: "2024-06-24", desktop: 132, mobile: 180 },
  { date: "2024-06-25", desktop: 141, mobile: 190 },
  { date: "2024-06-26", desktop: 434, mobile: 380 },
  { date: "2024-06-27", desktop: 448, mobile: 490 },
  { date: "2024-06-28", desktop: 149, mobile: 200 },
  { date: "2024-06-29", desktop: 103, mobile: 160 },
  { date: "2024-06-30", desktop: 446, mobile: 400 },
]

const chartConfig = {
  visitors: {
    label: "Visitors",
  },
  desktop: {
    label: "Desktop",
    color: "var(--primary)",
  },
  mobile: {
    label: "Mobile",
    color: "var(--primary)",
  },
} satisfies ChartConfig

export function ChartAreaInteractive() {
  const isMobile = useIsMobile()
  const [timeRange, setTimeRange] = React.useState("90d")

  React.useEffect(() => {
    if (isMobile) {
      setTimeRange("7d")
    }
  }, [isMobile])

  const filteredData = chartData.filter((item) => {
    const date = new Date(item.date)
    const referenceDate = new Date("2024-06-30")
    let daysToSubtract = 90
    if (timeRange === "30d") {
      daysToSubtract = 30
    } else if (timeRange === "7d") {
      daysToSubtract = 7
    }
    const startDate = new Date(referenceDate)
    startDate.setDate(startDate.getDate() - daysToSubtract)
    return date >= startDate
  })

  return (
    <Card className="@container/card">
      <CardHeader>
        <CardTitle>Total Visitors</CardTitle>
        <CardDescription>
          <span className="hidden @[540px]/card:block">
            Total for the last 3 months
          </span>
          <span className="@[540px]/card:hidden">Last 3 months</span>
        </CardDescription>
        <CardAction>
          <ToggleGroup
            type="single"
            value={timeRange}
            onValueChange={setTimeRange}
            variant="outline"
            className="hidden *:data-[slot=toggle-group-item]:!px-4 @[767px]/card:flex"
          >
            <ToggleGroupItem value="90d">Last 3 months</ToggleGroupItem>
            <ToggleGroupItem value="30d">Last 30 days</ToggleGroupItem>
            <ToggleGroupItem value="7d">Last 7 days</ToggleGroupItem>
          </ToggleGroup>
          <Select value={timeRange} onValueChange={setTimeRange}>
            <SelectTrigger
              className="flex w-40 **:data-[slot=select-value]:block **:data-[slot=select-value]:truncate @[767px]/card:hidden"
              size="sm"
              aria-label="Select a value"
            >
              <SelectValue placeholder="Last 3 months" />
            </SelectTrigger>
            <SelectContent className="rounded-xl">
              <SelectItem value="90d" className="rounded-lg">
                Last 3 months
              </SelectItem>
              <SelectItem value="30d" className="rounded-lg">
                Last 30 days
              </SelectItem>
              <SelectItem value="7d" className="rounded-lg">
                Last 7 days
              </SelectItem>
            </SelectContent>
          </Select>
        </CardAction>
      </CardHeader>
      <CardContent className="px-2 pt-4 sm:px-6 sm:pt-6">
        <ChartContainer
          config={chartConfig}
          className="aspect-auto h-[250px] w-full"
        >
          <AreaChart data={filteredData}>
            <defs>
              <linearGradient id="fillDesktop" x1="0" y1="0" x2="0" y2="1">
                <stop
                  offset="5%"
                  stopColor="var(--color-desktop)"
                  stopOpacity={1.0}
                />
                <stop
                  offset="95%"
                  stopColor="var(--color-desktop)"
                  stopOpacity={0.1}
                />
              </linearGradient>
              <linearGradient id="fillMobile" x1="0" y1="0" x2="0" y2="1">
                <stop
                  offset="5%"
                  stopColor="var(--color-mobile)"
                  stopOpacity={0.8}
                />
                <stop
                  offset="95%"
                  stopColor="var(--color-mobile)"
                  stopOpacity={0.1}
                />
              </linearGradient>
            </defs>
            <CartesianGrid vertical={false} />
            <XAxis
              dataKey="date"
              tickLine={false}
              axisLine={false}
              tickMargin={8}
              minTickGap={32}
              tickFormatter={(value) => {
                const date = new Date(value)
                return date.toLocaleDateString("en-US", {
                  month: "short",
                  day: "numeric",
                })
              }}
            />
            <ChartTooltip
              cursor={false}
              defaultIndex={isMobile ? -1 : 10}
              content={
                <ChartTooltipContent
                  labelFormatter={(value) => {
                    return new Date(value).toLocaleDateString("en-US", {
                      month: "short",
                      day: "numeric",
                    })
                  }}
                  indicator="dot"
                />
              }
            />
            <Area
              dataKey="mobile"
              type="natural"
              fill="url(#fillMobile)"
              stroke="var(--color-mobile)"
              stackId="a"
            />
            <Area
              dataKey="desktop"
              type="natural"
              fill="url(#fillDesktop)"
              stroke="var(--color-desktop)"
              stackId="a"
            />
          </AreaChart>
        </ChartContainer>
      </CardContent>
    </Card>
  )
}



================================================
FILE: app/components/dashboard/nav-main.tsx
================================================
import { memo, useMemo } from "react";
import { type Icon } from "@tabler/icons-react";

import { Link, useLocation } from "react-router";
import {
  SidebarGroup,
  SidebarGroupContent,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "~/components/ui/sidebar";

export const NavMain = memo(({
  items,
}: {
  items: {
    title: string;
    url: string;
    icon?: Icon;
  }[];
}) => {
  const location = useLocation();

  const navItems = useMemo(() => 
    items.map((item) => ({
      ...item,
      isActive: location.pathname === item.url,
    })), 
    [items, location.pathname]
  );

  return (
    <SidebarGroup>
      <SidebarGroupContent className="flex flex-col gap-2">
        <SidebarMenu>
          {navItems.map((item) => (
            <SidebarMenuItem key={item.title}>
              <SidebarMenuButton
                tooltip={item.title}
                isActive={item.isActive}
                asChild
              >
                <Link to={item.url} prefetch="intent">
                  {item.icon && <item.icon />}
                  <span>{item.title}</span>
                </Link>
              </SidebarMenuButton>
            </SidebarMenuItem>
          ))}
        </SidebarMenu>
      </SidebarGroupContent>
    </SidebarGroup>
  );
});



================================================
FILE: app/components/dashboard/nav-secondary.tsx
================================================
"use client"

import * as React from "react"
import { type Icon } from "@tabler/icons-react"
import { Link, useLocation } from "react-router"

import {
  SidebarGroup,
  SidebarGroupContent,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "~/components/ui/sidebar"

export function NavSecondary({
  items,
  ...props
}: {
  items: {
    title: string
    url: string
    icon: Icon
  }[]
} & React.ComponentPropsWithoutRef<typeof SidebarGroup>) {
  const location = useLocation();

  return (
    <SidebarGroup {...props}>
      <SidebarGroupContent>
        <SidebarMenu>
          {items.map((item) => {
            const isActive = location.pathname === item.url ||
                           (item.url.startsWith("/dashboard") && location.pathname.startsWith(item.url));
            const isImplemented = item.url !== "#";
            
            return (
              <SidebarMenuItem key={item.title}>
                {isImplemented ? (
                  <SidebarMenuButton isActive={isActive} asChild>
                    <Link to={item.url} prefetch="intent">
                      <item.icon />
                      <span>{item.title}</span>
                    </Link>
                  </SidebarMenuButton>
                ) : (
                  <SidebarMenuButton disabled>
                    <item.icon />
                    <span>{item.title}</span>
                  </SidebarMenuButton>
                )}
              </SidebarMenuItem>
            );
          })}
        </SidebarMenu>
      </SidebarGroupContent>
    </SidebarGroup>
  )
}



================================================
FILE: app/components/dashboard/nav-user.tsx
================================================
import { SignOutButton } from "@clerk/react-router";
import {
  IconDotsVertical,
  IconLogout,
  IconUserCircle,
} from "@tabler/icons-react";
import { SettingsIcon } from "lucide-react";
import { Avatar, AvatarFallback, AvatarImage } from "~/components/ui/avatar";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "~/components/ui/dropdown-menu";
import {
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
  useSidebar,
} from "~/components/ui/sidebar";
import { useClerk } from "@clerk/react-router";

export function NavUser({ user }: any) {
  const { isMobile } = useSidebar();
  const userFullName = user.firstName + " " + user.lastName;
  const userEmail = user.emailAddresses[0].emailAddress;
  const userInitials =
    (user?.firstName?.charAt(0) || "").toUpperCase() +
    (user?.lastName?.charAt(0) || "").toUpperCase();
  const userProfile = user.imageUrl;
  const { signOut } = useClerk();

  return (
    <SidebarMenu>
      <SidebarMenuItem>
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <SidebarMenuButton
              size="lg"
              className="data-[state=open]:bg-sidebar-accent data-[state=open]:text-sidebar-accent-foreground"
            >
              <Avatar className="h-8 w-8 rounded-lg">
                <AvatarImage src={userProfile} alt={userFullName} />
                <AvatarFallback className="rounded-lg">
                  {userInitials}
                </AvatarFallback>
              </Avatar>
              <div className="grid flex-1 text-left text-sm leading-tight">
                <span className="truncate font-medium">{userFullName}</span>
                <span className="text-muted-foreground truncate text-xs">
                  {userEmail}
                </span>
              </div>
              <IconDotsVertical className="ml-auto size-4" />
            </SidebarMenuButton>
          </DropdownMenuTrigger>
          <DropdownMenuContent
            className="w-(--radix-dropdown-menu-trigger-width) min-w-56 rounded-lg"
            side={isMobile ? "bottom" : "right"}
            align="end"
            sideOffset={4}
          >
            <DropdownMenuLabel className="p-0 font-normal">
              <div className="flex items-center gap-2 px-1 py-1.5 text-left text-sm">
                <Avatar className="h-8 w-8 rounded-lg">
                  <AvatarImage src={userProfile} alt={userFullName} />
                  <AvatarFallback className="rounded-lg">
                    {userInitials}
                  </AvatarFallback>
                </Avatar>
                <div className="grid flex-1 text-left text-sm leading-tight">
                  <span className="truncate font-medium">{userFullName}</span>
                  <span className="text-muted-foreground truncate text-xs">
                    {userEmail}
                  </span>
                </div>
              </div>
            </DropdownMenuLabel>
            <DropdownMenuSeparator />
            <DropdownMenuGroup>
              <DropdownMenuItem>
                <IconUserCircle />
                Account
              </DropdownMenuItem>
              <DropdownMenuItem>
                <SettingsIcon />
                Settings
              </DropdownMenuItem>
            </DropdownMenuGroup>
            <DropdownMenuSeparator />
            <DropdownMenuItem onClick={() => signOut({ redirectUrl: "/" })}>
              <IconLogout />
              Sign Out
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </SidebarMenuItem>
    </SidebarMenu>
  );
}



================================================
FILE: app/components/dashboard/section-cards.tsx
================================================
import { IconTrendingDown, IconTrendingUp } from "@tabler/icons-react"

import { Badge } from "~/components/ui/badge"
import {
  Card,
  CardAction,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "~/components/ui/card"

export function SectionCards() {
  return (
    <div className="*:data-[slot=card]:from-primary/5 *:data-[slot=card]:to-card dark:*:data-[slot=card]:bg-card grid grid-cols-1 gap-4 px-4 *:data-[slot=card]:bg-gradient-to-t *:data-[slot=card]:shadow-xs lg:px-6 @xl/main:grid-cols-2 @5xl/main:grid-cols-4">
      <Card className="@container/card">
        <CardHeader>
          <CardDescription>Total Revenue</CardDescription>
          <CardTitle className="text-2xl font-semibold tabular-nums @[250px]/card:text-3xl">
            $1,250.00
          </CardTitle>
          <CardAction>
            <Badge variant="outline">
              <IconTrendingUp />
              +12.5%
            </Badge>
          </CardAction>
        </CardHeader>
        <CardFooter className="flex-col items-start gap-1.5 text-sm">
          <div className="line-clamp-1 flex gap-2 font-medium">
            Trending up this month <IconTrendingUp className="size-4" />
          </div>
          <div className="text-muted-foreground">
            Visitors for the last 6 months
          </div>
        </CardFooter>
      </Card>
      <Card className="@container/card">
        <CardHeader>
          <CardDescription>New Customers</CardDescription>
          <CardTitle className="text-2xl font-semibold tabular-nums @[250px]/card:text-3xl">
            1,234
          </CardTitle>
          <CardAction>
            <Badge variant="outline">
              <IconTrendingDown />
              -20%
            </Badge>
          </CardAction>
        </CardHeader>
        <CardFooter className="flex-col items-start gap-1.5 text-sm">
          <div className="line-clamp-1 flex gap-2 font-medium">
            Down 20% this period <IconTrendingDown className="size-4" />
          </div>
          <div className="text-muted-foreground">
            Acquisition needs attention
          </div>
        </CardFooter>
      </Card>
      <Card className="@container/card">
        <CardHeader>
          <CardDescription>Active Accounts</CardDescription>
          <CardTitle className="text-2xl font-semibold tabular-nums @[250px]/card:text-3xl">
            45,678
          </CardTitle>
          <CardAction>
            <Badge variant="outline">
              <IconTrendingUp />
              +12.5%
            </Badge>
          </CardAction>
        </CardHeader>
        <CardFooter className="flex-col items-start gap-1.5 text-sm">
          <div className="line-clamp-1 flex gap-2 font-medium">
            Strong user retention <IconTrendingUp className="size-4" />
          </div>
          <div className="text-muted-foreground">Engagement exceed targets</div>
        </CardFooter>
      </Card>
      <Card className="@container/card">
        <CardHeader>
          <CardDescription>Growth Rate</CardDescription>
          <CardTitle className="text-2xl font-semibold tabular-nums @[250px]/card:text-3xl">
            4.5%
          </CardTitle>
          <CardAction>
            <Badge variant="outline">
              <IconTrendingUp />
              +4.5%
            </Badge>
          </CardAction>
        </CardHeader>
        <CardFooter className="flex-col items-start gap-1.5 text-sm">
          <div className="line-clamp-1 flex gap-2 font-medium">
            Steady performance increase <IconTrendingUp className="size-4" />
          </div>
          <div className="text-muted-foreground">Meets growth projections</div>
        </CardFooter>
      </Card>
    </div>
  )
}



================================================
FILE: app/components/dashboard/site-header.tsx
================================================
import { Button } from "~/components/ui/button";
import { Separator } from "~/components/ui/separator";
import { SidebarTrigger } from "~/components/ui/sidebar";

export function SiteHeader() {
  return (
    <header className="flex h-(--header-height) shrink-0 items-center gap-2 border-b transition-[width,height] ease-linear group-has-data-[collapsible=icon]/sidebar-wrapper:h-(--header-height)">
      <div className="flex w-full items-center gap-1 px-4 lg:gap-2 lg:px-6">
        <SidebarTrigger className="-ml-1" />
        <Separator
          orientation="vertical"
          className="mx-2 data-[orientation=vertical]:h-4"
        />
        <div className="ml-auto flex items-center gap-2">
          <Button variant="ghost" asChild size="sm" className="hidden sm:flex">
            <a
              href="https://github.com/michaelshimeles/youpac-ai"
              rel="noopener noreferrer"
              target="_blank"
              className="dark:text-foreground"
            >
              GitHub
            </a>
          </Button>
        </div>
      </div>
    </header>
  );
}



================================================
FILE: app/components/homepage/content.tsx
================================================
import { Button } from "~/components/ui/button";
import { 
  ChevronRight, 
  Palette, 
  MessageSquare, 
  Sparkles,
  Video,
  FileText,
  Share2,
  Zap,
  Eye,
  TrendingUp
} from "lucide-react";
import { Link } from "react-router";
import { cn } from "~/lib/utils";

export default function ContentSection() {
  return (
    <>
      <section id="features" className="relative py-24 md:py-32 overflow-hidden">
        {/* Background gradient */}
        <div className="absolute inset-0 bg-gradient-to-b from-background via-primary/5 to-background" />
        
        {/* Animated gradient orb */}
        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 h-96 w-96 rounded-full bg-gradient-to-br from-blue-500/20 to-primary/20 blur-3xl animate-pulse" />
        
        <div className="relative mx-auto max-w-7xl px-6 lg:px-8">
          <div className="grid gap-12 lg:grid-cols-2 lg:gap-16 items-center">
            <div className="space-y-8">
              {/* Badge */}
              <div className="inline-flex items-center gap-2 rounded-full bg-primary/10 px-4 py-1.5 text-sm font-medium text-primary ring-1 ring-inset ring-primary/20">
                <Zap className="h-4 w-4" />
                <span>Supercharge Your Workflow</span>
              </div>
              
              <h2 className="text-4xl font-bold tracking-tight sm:text-5xl">
                AI-Powered Content Creation for{" "}
                <span className="bg-gradient-to-r from-primary to-blue-500 bg-clip-text text-transparent">
                  YouTube Creators
                </span>
              </h2>
              
              <div className="space-y-6 text-lg text-muted-foreground">
                <p>
                  Transform your video content workflow with our intelligent AI assistant.
                  Upload your video and watch as our advanced AI generates optimized
                  titles, compelling descriptions, eye-catching thumbnail concepts,
                  and engaging social media posts - all tailored to your channel's unique voice.
                </p>
                <p>
                  <span className="font-semibold text-foreground">Save hours on every video</span>{" "}
                  with automatic transcription, visual canvas for organizing content,
                  and AI agents that understand your niche and audience. Perfect for
                  creators who want to focus on making great videos while AI handles
                  the optimization.
                </p>
              </div>
              
              <div className="flex items-center gap-4">
                <Button
                  asChild
                  size="lg"
                  className="group"
                >
                  <Link to="/sign-up">
                    <span>Start Creating</span>
                    <ChevronRight className="ml-2 h-4 w-4 transition-transform group-hover:translate-x-1" />
                  </Link>
                </Button>
                <Button
                  asChild
                  variant="outline"
                  size="lg"
                >
                  <Link to="#demo">
                    <Eye className="mr-2 h-4 w-4" />
                    <span>Watch Demo</span>
                  </Link>
                </Button>
              </div>
            </div>
            
            {/* Visual representation */}
            <div className="relative">
              <div className="absolute inset-0 bg-gradient-to-r from-primary/20 to-blue-500/20 blur-3xl" />
              <div className="relative grid grid-cols-2 gap-4">
                <FeaturePreviewCard
                  icon={Video}
                  title="Video Analysis"
                  description="AI understands your content"
                  className="translate-y-4"
                />
                <FeaturePreviewCard
                  icon={FileText}
                  title="Smart Titles"
                  description="SEO-optimized suggestions"
                  className="-translate-y-4"
                />
                <FeaturePreviewCard
                  icon={Palette}
                  title="Thumbnails"
                  description="Eye-catching designs"
                  className="translate-y-4"
                />
                <FeaturePreviewCard
                  icon={Share2}
                  title="Social Posts"
                  description="Viral-ready content"
                  className="-translate-y-4"
                />
              </div>
            </div>
          </div>
        </div>
      </section>
      
      <section className="relative py-24 md:py-32 bg-muted/30">
        <div className="absolute inset-0 bg-gradient-to-br from-primary/5 via-transparent to-blue-500/5" />
        
        <div className="relative mx-auto max-w-7xl px-6 lg:px-8">
          {/* Section header */}
          <div className="mx-auto max-w-2xl text-center mb-16">
            <div className="inline-flex items-center gap-2 rounded-full bg-primary/10 px-4 py-1.5 text-sm font-medium text-primary ring-1 ring-inset ring-primary/20 mb-6">
              <Sparkles className="h-4 w-4" />
              <span>Powerful Features</span>
            </div>
            <h3 className="text-3xl font-bold tracking-tight sm:text-4xl">
              Everything You Need to{" "}
              <span className="bg-gradient-to-r from-primary to-blue-500 bg-clip-text text-transparent">
                Create Better Content
              </span>
            </h3>
            <p className="mt-4 text-lg text-muted-foreground">
              Our comprehensive suite of AI tools helps you optimize every aspect of your YouTube content
            </p>
          </div>
          
          {/* Feature grid */}
          <div className="grid gap-8 md:grid-cols-3">
            <FeatureCard
              icon={Palette}
              title="Visual Canvas"
              description="Drag-and-drop interface to organize your content creation workflow. Connect video nodes to AI agents and visualize your entire process."
              gradient="from-blue-500/10 to-cyan-500/10"
            />
            
            <FeatureCard
              icon={Sparkles}
              title="Smart AI Agents"
              description="Specialized agents for titles, descriptions, thumbnails, and social posts. Each agent understands your content and channel style."
              gradient="from-primary/10 to-purple-500/10"
            />
            
            <FeatureCard
              icon={MessageSquare}
              title="Interactive Chat"
              description="Chat with AI agents to refine content. Use @mentions to direct questions and get instant suggestions for improvements."
              gradient="from-purple-500/10 to-pink-500/10"
            />
          </div>
          
          {/* Stats section */}
          <div className="mt-20 grid grid-cols-2 gap-8 border-t border-border/50 pt-12 sm:grid-cols-4">
            <StatCard number="10x" label="Faster Content Creation" />
            <StatCard number="50%" label="More Engagement" />
            <StatCard number="100+" label="AI Models Available" />
            <StatCard number="24/7" label="Support Available" />
          </div>
        </div>
      </section>
    </>
  );
}

// Feature preview card for the hero section visual
const FeaturePreviewCard = ({ 
  icon: Icon, 
  title, 
  description, 
  className 
}: { 
  icon: any; 
  title: string; 
  description: string; 
  className?: string;
}) => {
  return (
    <div className={cn(
      "group relative rounded-2xl border border-border/50 bg-card/50 backdrop-blur-sm p-6 hover:border-primary/50 transition-all hover:shadow-xl hover:shadow-primary/10",
      className
    )}>
      <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-primary/5 to-transparent opacity-0 group-hover:opacity-100 transition-opacity" />
      <Icon className="relative h-8 w-8 text-primary mb-3" />
      <h4 className="relative text-sm font-semibold mb-1">{title}</h4>
      <p className="relative text-xs text-muted-foreground">{description}</p>
    </div>
  );
};

// Feature card for the features section
const FeatureCard = ({ 
  icon: Icon, 
  title, 
  description, 
  gradient 
}: { 
  icon: any; 
  title: string; 
  description: string; 
  gradient: string;
}) => {
  return (
    <div className="group relative">
      <div className={cn(
        "absolute inset-0 rounded-2xl bg-gradient-to-br opacity-0 group-hover:opacity-100 transition-all duration-300 blur-xl",
        gradient
      )} />
      <div className="relative rounded-2xl border border-border/50 bg-card/50 backdrop-blur-sm p-8 hover:border-primary/50 transition-all hover:shadow-lg">
        <div className={cn(
          "inline-flex rounded-xl bg-gradient-to-br p-3 mb-5",
          gradient
        )}>
          <Icon className="h-6 w-6 text-foreground" />
        </div>
        <h4 className="text-xl font-semibold mb-3">{title}</h4>
        <p className="text-muted-foreground leading-relaxed">{description}</p>
      </div>
    </div>
  );
};

// Stat card component
const StatCard = ({ number, label }: { number: string; label: string }) => {
  return (
    <div className="text-center">
      <p className="text-3xl font-bold bg-gradient-to-r from-primary to-blue-500 bg-clip-text text-transparent">
        {number}
      </p>
      <p className="mt-1 text-sm text-muted-foreground">{label}</p>
    </div>
  );
};



================================================
FILE: app/components/homepage/footer.tsx
================================================
import { Link } from "react-router";

export default function FooterSection() {
  return (
    <footer className="py-16">
      <div className="mx-auto max-w-5xl px-6">
        <div className="my-8 flex flex-wrap justify-center gap-6 text-sm">
          <Link
            to="https://x.com/rasmickyy"
            target="_blank"
            rel="noopener noreferrer"
            aria-label="X/Twitter"
            className="text-muted-foreground hover:text-primary block"
          >
            <svg
              className="size-6"
              xmlns="http://www.w3.org/2000/svg"
              width="1em"
              height="1em"
              viewBox="0 0 24 24"
            >
              <path
                fill="currentColor"
                d="M10.488 14.651L15.25 21h7l-7.858-10.478L20.93 3h-2.65l-5.117 5.886L8.75 3h-7l7.51 10.015L2.32 21h2.65zM16.25 19L5.75 5h2l10.5 14z"
              ></path>
            </svg>
          </Link>
        </div>
        <span className="text-muted-foreground block text-center text-sm">
          {" "}
          ¬© {new Date().getFullYear()} YouPac AI, All rights reserved
        </span>
      </div>
    </footer>
  );
}



================================================
FILE: app/components/homepage/hero.tsx
================================================
"use client";

// this is a client component
import { useEffect } from "react";
import { Link } from "react-router";
import { renderCanvas, ShineBorder, TypeWriter } from "~/components/ui/hero-designali";
import { Plus } from "lucide-react"; 
import { Button } from "~/components/ui/button"; 
import { Navbar } from "./navbar";

export default function Hero({
  loaderData,
}: {
  loaderData?: { isSignedIn: boolean };
}) {
  const talkAbout = [
    "Video Titles",
    "Descriptions",
    "Thumbnails",
    "Social Posts",
    "SEO Content",
    "AI Magic",
    "YouTube Growth",
  ];

  useEffect(() => {
    renderCanvas();
  }, []);

  return (
    <main className="overflow-hidden">
    <section id="home">
      <Navbar loaderData={loaderData} />
   <div className="absolute inset-0 max-md:hidden top-[400px] -z-10 h-[400px] w-full bg-transparent bg-[linear-gradient(to_right,#57534e_1px,transparent_1px),linear-gradient(to_bottom,#57534e_1px,transparent_1px)] bg-[size:3rem_3rem] opacity-20 [mask-image:radial-gradient(ellipse_80%_50%_at_50%_0%,#000_70%,transparent_110%)] dark:bg-[linear-gradient(to_right,#a8a29e_1px,transparent_1px),linear-gradient(to_bottom,#a8a29e_1px,transparent_1px)]"></div>
      <div className="flex flex-col items-center justify-center px-6 text-center">
        <div className="mb-6 mt-10 sm:justify-center md:mb-4 md:mt-40">
          <div className="relative flex items-center rounded-full border bg-popover px-3 py-1 text-xs text-primary/60">
            Introducing YouPac AI.
            <Link
              to="/dashboard"
              rel="noreferrer"
              className="ml-1 flex items-center font-semibold"
            >
              <div
                className="absolute inset-0 hover:font-semibold hover:text-primary flex"
                aria-hidden="true"
              />
              Explore <span aria-hidden="true"></span>
            </Link>
          </div>
        </div>

        <div className="mx-auto max-w-5xl">
                     <div className="border-text-primary relative mx-auto h-full bg-background border py-12 p-6 [mask-image:radial-gradient(800rem_96rem_at_center,white,transparent)]">

            <h1 className="flex flex-col text-center text-5xl font-semibold leading-none tracking-tight md:flex-col md:text-8xl lg:flex-row lg:text-8xl">
              <Plus
                strokeWidth={4}
                className="text-primary absolute -left-5 -top-5 h-10 w-10"
              />
              <Plus
                strokeWidth={4}
                className="text-primary absolute -bottom-5 -left-5 h-10 w-10"
              />
              <Plus
                strokeWidth={4}
                className="text-primary absolute -right-5 -top-5 h-10 w-10"
              />
              <Plus
                strokeWidth={4}
                className="text-primary absolute -bottom-5 -right-5 h-10 w-10"
              />
              <span>
                Package Your YouTube Content Better With{" "}
                <span className="bg-gradient-to-r from-blue-500 via-primary to-cyan-500 bg-clip-text text-transparent">AI</span>
              </span>
            </h1>
            <div className="flex items-center mt-4 justify-center gap-1">
              <span className="relative flex h-3 w-3 items-center justify-center">
                <span className="absolute inline-flex h-full w-full animate-ping rounded-full bg-green-500 opacity-75"></span>
                <span className="relative inline-flex h-2 w-2 rounded-full bg-green-500"></span>
              </span>
              <p className="text-xs text-green-500">Available Now</p>
            </div>
          </div>

          <h1 className="mt-8 text-2xl md:text-2xl">
            Generate compelling titles, descriptions, stunning thumbnails, and viral social media posts.
          </h1>

          <p className="text-primary/60 py-4">
            All powered by cutting-edge AI, designed for YouTube creators.
          </p>
          <div className="flex items-center justify-center gap-2">
            <Link to={loaderData?.isSignedIn ? "/dashboard" : "/sign-up"}>
              <ShineBorder
                borderWidth={3}
                className="border cursor-pointer h-auto w-auto p-2 bg-white/5 backdrop-blur-md dark:bg-black/5"
                color={["#FF007F", "#39FF14", "#00FFFF"]}
              >
                <Button className="w-full rounded-xl" >
                  Start Creating
                </Button>
              </ShineBorder>
            </Link> 
            <Link to={"https://github.com/michaelshimeles/youpac-ai"} target="_blank">
              <Button className="rounded-xl" variant="outline">View on GitHub</Button>
            </Link>
          </div>
        </div>
      </div>
      <canvas
        className="pointer-events-none absolute inset-0 mx-auto"
        id="canvas"
      ></canvas>
    </section>
     <div
        className="absolute left-1/2 top-0 -z-10 -translate-x-1/2"
        style={{
          width: "1512px",
          height: "550px",
          background: "radial-gradient(ellipse at center, rgba(59, 130, 246, 0.15) 0%, transparent 50%)",
        }}
        role="presentation"
      />
     </main>
  );
};


================================================
FILE: app/components/homepage/navbar.tsx
================================================
"use client";
import { UserButton } from "@clerk/react-router";
import { Github, Menu, X } from "lucide-react";
import React, { useCallback } from "react";
import { Link } from "react-router";
import { Button } from "~/components/ui/button";
import { cn } from "~/lib/utils";

const menuItems = [
  { name: "Home", href: "#hero" },
  { name: "Features", href: "#features" },
];

export const Navbar = ({
  loaderData,
}: {
  loaderData?: { isSignedIn: boolean };
}) => {
  const [menuState, setMenuState] = React.useState(false);
  const [isScrolled, setIsScrolled] = React.useState(false);

  React.useEffect(() => {
    const handleScroll = () => {
      setIsScrolled(window.scrollY > 50);
    };
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  const handleNavClick = useCallback((href: string) => {
    if (href.startsWith("#")) {
      const element = document.querySelector(href);
      if (element) {
        element.scrollIntoView({
          behavior: "smooth",
          block: "start",
        });
      }
    }
    setMenuState(false); // Close mobile menu
  }, []);

  // Simple computations don't need useMemo
  const dashboardLink = !loaderData?.isSignedIn 
    ? "/sign-up" 
    : "/dashboard";

  const dashboardText = !loaderData?.isSignedIn 
    ? "Get Started (Demo)"
    : "Dashboard";
  return (
    <header>
      <nav
        data-state={menuState && "active"}
        className="fixed z-99 w-full px-2"
      >
        <div
          className={cn(
            "mx-auto mt-2 max-w-6xl px-6 transition-all duration-300 lg:px-12",
            isScrolled &&
              "bg-background/50 max-w-4xl rounded-2xl border backdrop-blur-lg lg:px-5"
          )}
        >
          <div className="relative flex flex-wrap items-center justify-between gap-6 py-3 lg:gap-0 lg:py-4">
            <div className="flex w-full justify-between lg:w-auto">
              <Link
                to="/"
                aria-label="home"
                className="flex items-center space-x-2 font-semibold text-xl"
                prefetch="viewport"
              >
                YouPac AI
              </Link>

              <button
                onClick={() => setMenuState(!menuState)}
                aria-label={menuState == true ? "Close Menu" : "Open Menu"}
                className="relative z-20 -m-2.5 -mr-4 block cursor-pointer p-2.5 lg:hidden"
              >
                <Menu className="in-data-[state=active]:rotate-180 in-data-[state=active]:scale-0 in-data-[state=active]:opacity-0 m-auto size-6 duration-200" />
                <X className="in-data-[state=active]:rotate-0 in-data-[state=active]:scale-100 in-data-[state=active]:opacity-100 absolute inset-0 m-auto size-6 -rotate-180 scale-0 opacity-0 duration-200" />
              </button>
            </div>

            <div className="bg-background in-data-[state=active]:block lg:in-data-[state=active]:flex mb-6 hidden w-full flex-wrap items-center justify-end space-y-8 rounded-3xl border p-6 shadow-2xl shadow-zinc-300/20 md:flex-nowrap lg:m-0 lg:flex lg:w-fit lg:gap-6 lg:space-y-0 lg:border-transparent lg:bg-transparent lg:p-0 lg:shadow-none dark:shadow-none dark:lg:bg-transparent">
              <div className="lg:hidden">
                <ul className="space-y-6 text-base">
                  {menuItems.map((item, index) => (
                    <li key={index}>
                      <button
                        onClick={() => handleNavClick(item.href)}
                        className="text-muted-foreground hover:cursor-pointer  block duration-150 transition-colors w-full text-left"
                      >
                        <span>{item.name}</span>
                      </button>
                    </li>
                  ))}
                </ul>
              </div>
              <div className="flex w-full flex-col space-y-3 sm:flex-row sm:gap-3 sm:space-y-0 md:w-fit">
                <Link
                  to="https://github.com/michaelshimeles/youpac-ai"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="flex items-center justify-center"
                >
                  <Github className="w-5 h-5" />
                </Link>
                {loaderData?.isSignedIn ? (
                  <div className="flex items-center gap-3">
                    <Button asChild size="sm">
                      <Link to={dashboardLink} prefetch="viewport">
                        <span>{dashboardText}</span>
                      </Link>
                    </Button>
                    <UserButton />
                  </div>
                ) : (
                  <>
                    <Button
                      asChild
                      variant="outline"
                      size="sm"
                      className={cn(isScrolled && "lg:hidden")}
                    >
                      <Link to="/sign-in" prefetch="viewport">
                        <span>Login</span>
                      </Link>
                    </Button>
                    <Button
                      asChild
                      size="sm"
                      className={cn(isScrolled && "lg:hidden")}
                    >
                      <Link to="/sign-up" prefetch="viewport">
                        <span>Sign Up</span>
                      </Link>
                    </Button>
                    <Button
                      asChild
                      size="sm"
                      className={cn(isScrolled ? "lg:inline-flex" : "hidden")}
                    >
                      <Link to="/sign-up" prefetch="viewport">
                        <span>{dashboardText}</span>
                      </Link>
                    </Button>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
      </nav>
    </header>
  );
};



================================================
FILE: app/components/homepage/team.tsx
================================================
const members = [
  {
    name: "Alex Chen",
    role: "Founder & CEO",
    avatar:
      "https://api.dicebear.com/7.x/avataaars/svg?seed=Alex&backgroundColor=b6e3f4",
  },
  {
    name: "Sarah Johnson",
    role: "Head of AI",
    avatar:
      "https://api.dicebear.com/7.x/avataaars/svg?seed=Sarah&backgroundColor=c0aede",
  },
  {
    name: "Marcus Rivera",
    role: "Lead Engineer",
    avatar:
      "https://api.dicebear.com/7.x/avataaars/svg?seed=Marcus&backgroundColor=d1d4f9",
  },
  {
    name: "Emily Zhang",
    role: "Product Designer",
    avatar:
      "https://api.dicebear.com/7.x/avataaars/svg?seed=Emily&backgroundColor=ffd5dc",
  },
];

export default function TeamSection() {
  return (
    <section id="team" className="py-12 md:py-32">
      <div className="mx-auto max-w-3xl px-8 lg:px-0">
        <h2 className="mb-8 text-4xl font-bold md:mb-16 lg:text-5xl">
          Built by Creators, for Creators
        </h2>

        <div>
          <h3 className="mb-6 text-lg font-medium">Leadership</h3>
          <div className="grid grid-cols-2 gap-4 border-t py-6 md:grid-cols-4">
            {members.map((member, index) => (
              <div key={index}>
                <div className="bg-background size-20 rounded-full border p-0.5 shadow shadow-zinc-950/5">
                  <img
                    className="aspect-square rounded-full object-cover"
                    src={member.avatar}
                    alt={member.name}
                    height="460"
                    width="460"
                    loading="lazy"
                  />
                </div>
                <span className="mt-2 block text-sm">{member.name}</span>
                <span className="text-muted-foreground block text-xs">
                  {member.role}
                </span>
              </div>
            ))}
          </div>
        </div>
      </div>
    </section>
  );
}



================================================
FILE: app/components/logos/ClerkIcon.tsx
================================================
export default function ClerkIcon() {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      className="h-8 w-8"
    >
      <path
        d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2z"
        fill="url(#clerk-gradient)"
      />
      <path
        d="M12 6.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM7.5 15.5a4.5 4.5 0 0 1 9 0v1a.5.5 0 0 1-.5.5H8a.5.5 0 0 1-.5-.5v-1z"
        fill="white"
      />
      <defs>
        <linearGradient
          id="clerk-gradient"
          x1="2"
          y1="2"
          x2="22"
          y2="22"
          gradientUnits="userSpaceOnUse"
        >
          <stop stopColor="#6C47FF" />
          <stop offset="1" stopColor="#4F29F0" />
        </linearGradient>
      </defs>
    </svg>
  );
}


================================================
FILE: app/components/logos/Convex.tsx
================================================
import { type SVGProps } from 'react'

export default function Convex(props: SVGProps<SVGSVGElement>) {
    return (
        <svg viewBox="28 28 128 132" xmlns="http://www.w3.org/2000/svg" fill="none"><path fill="#F3B01C" d="M108.092 130.021c18.166-2.018 35.293-11.698 44.723-27.854-4.466 39.961-48.162 65.218-83.83 49.711-3.286-1.425-6.115-3.796-8.056-6.844-8.016-12.586-10.65-28.601-6.865-43.135 10.817 18.668 32.81 30.111 54.028 28.122Z"/><path fill="#8D2676" d="M53.401 90.174c-7.364 17.017-7.682 36.94 1.345 53.336-31.77-23.902-31.423-75.052-.388-98.715 2.87-2.187 6.282-3.485 9.86-3.683 14.713-.776 29.662 4.91 40.146 15.507-21.3.212-42.046 13.857-50.963 33.555Z"/><path fill="#EE342F" d="M114.637 61.855C103.89 46.87 87.069 36.668 68.639 36.358c35.625-16.17 79.446 10.047 84.217 48.807.444 3.598-.139 7.267-1.734 10.512-6.656 13.518-18.998 24.002-33.42 27.882 10.567-19.599 9.263-43.544-3.065-61.704Z"/></svg>
    )
}



================================================
FILE: app/components/logos/index.ts
================================================
export { default as ReactRouter } from "./ReactRouter";
export { default as Convex } from "./Convex";
export { default as ReactIcon } from "./ReactIcon";
export { default as TailwindIcon } from "./TailwindIcon";
export { default as Typescript } from "./Typescript";
export { default as Polar } from "./Polar";
export { default as OpenAI } from "./OpenAI";
export { default as YouTube } from "./YouTube";
export { default as ClerkIcon } from "./ClerkIcon";



================================================
FILE: app/components/logos/OpenAI.tsx
================================================
export default function OpenAI() {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      className="h-8 w-8"
    >
      <path
        d="M22.2819 9.8211a5.9847 5.9847 0 0 0-.5157-4.9108 6.0462 6.0462 0 0 0-6.5098-2.9A6.0651 6.0651 0 0 0 4.9807 4.1818a5.9847 5.9847 0 0 0-3.9977 2.9 6.0462 6.0462 0 0 0 .7427 7.0966 5.98 5.98 0 0 0 .511 4.9107 6.051 6.051 0 0 0 6.5146 2.9001A5.9847 5.9847 0 0 0 13.2599 24a6.0557 6.0557 0 0 0 5.7718-4.2058 5.9894 5.9894 0 0 0 3.9977-2.9001 6.0557 6.0557 0 0 0-.7475-7.0729zm-9.022 12.6081a4.4755 4.4755 0 0 1-2.8764-1.0408l.1419-.0804 4.7783-2.7582a.7948.7948 0 0 0 .3927-.6813v-6.7369l2.02 1.1686a.071.071 0 0 1 .038.052v5.5826a4.504 4.504 0 0 1-4.4945 4.4944zm-9.6607-4.1254a4.4708 4.4708 0 0 1-.5346-3.0137l.142.0852 4.783 2.7582a.7712.7712 0 0 0 .7806 0l5.8428-3.3685v2.3324a.0804.0804 0 0 1-.0332.0615L9.74 19.9502a4.4992 4.4992 0 0 1-6.1408-1.6464zM2.3408 7.8956a4.485 4.485 0 0 1 2.3655-1.9728V11.6a.7664.7664 0 0 0 .3879.6765l5.8144 3.3543-2.0201 1.1685a.0757.0757 0 0 1-.071 0l-4.8303-2.7865A4.504 4.504 0 0 1 2.3408 7.872zm16.5963 3.8558L13.1038 8.364 15.1192 7.2a.0757.0757 0 0 1 .071 0l4.8303 2.7913a4.4944 4.4944 0 0 1-.6765 8.1042v-5.6772a.79.79 0 0 0-.407-.667zm2.0107-3.0231l-.142-.0852-4.7735-2.7818a.7759.7759 0 0 0-.7854 0L9.409 9.2297V6.8974a.0662.0662 0 0 1 .0284-.0615l4.8351-2.7866a4.4992 4.4992 0 0 1 6.6802 4.66zM8.3065 12.863l-2.02-1.1638a.0804.0804 0 0 1-.038-.0567V6.0742a4.4992 4.4992 0 0 1 7.3757-3.4537l-.142.0805L8.704 5.459a.7948.7948 0 0 0-.3927.6813zm1.0976-2.3654l2.602-1.4998 2.6069 1.4998v2.9994l-2.5974 1.4997-2.6067-1.4997Z"
        fill="currentColor"
      />
    </svg>
  );
}


================================================
FILE: app/components/logos/Polar.tsx
================================================
export default function Polar() {
  return <img src="/polar.svg" alt="Polar Logo" />;
}



================================================
FILE: app/components/logos/ReactIcon.tsx
================================================
import type { SVGProps } from 'react'

export default function ReactIcon(props: SVGProps<SVGSVGElement>) {
    return (
        <svg width="569px" height="512px" viewBox="0 0 569 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink">
            <g fill="none" fillRule="evenodd">
                <g transform="translate(-227, -256)" fill="#58C4DC" fillRule="nonzero">
                    <g transform="translate(227, 256)">
                        <path d="M285.5,201 C255.400481,201 231,225.400481 231,255.5 C231,285.599519 255.400481,310 285.5,310 C315.599519,310 340,285.599519 340,255.5 C340,225.400481 315.599519,201 285.5,201" id="Path"></path>
                        <path d="M568.959856,255.99437 C568.959856,213.207656 529.337802,175.68144 466.251623,150.985214 C467.094645,145.423543 467.85738,139.922107 468.399323,134.521063 C474.621631,73.0415145 459.808523,28.6686204 426.709856,9.5541429 C389.677085,-11.8291748 337.36955,3.69129898 284.479928,46.0162134 C231.590306,3.69129898 179.282771,-11.8291748 142.25,9.5541429 C109.151333,28.6686204 94.3382249,73.0415145 100.560533,134.521063 C101.102476,139.922107 101.845139,145.443621 102.708233,151.02537 C97.4493791,153.033193 92.2908847,155.161486 87.3331099,157.39017 C31.0111824,182.708821 0,217.765415 0,255.99437 C0,298.781084 39.6220545,336.307301 102.708233,361.003527 C101.845139,366.565197 101.102476,372.066633 100.560533,377.467678 C94.3382249,438.947226 109.151333,483.32012 142.25,502.434597 C153.629683,508.887578 166.52439,512.186771 179.603923,511.991836 C210.956328,511.991836 247.567589,495.487529 284.479928,465.972527 C321.372196,495.487529 358.003528,511.991836 389.396077,511.991836 C402.475265,512.183856 415.36922,508.884856 426.75,502.434597 C459.848667,483.32012 474.661775,438.947226 468.439467,377.467678 C467.897524,372.066633 467.134789,366.565197 466.291767,361.003527 C529.377946,336.347457 569,298.761006 569,255.99437 M389.155214,27.1025182 C397.565154,26.899606 405.877839,28.9368502 413.241569,33.0055186 C436.223966,46.2772304 446.540955,82.2775015 441.522965,131.770345 C441.181741,135.143488 440.780302,138.556788 440.298575,141.990165 C414.066922,134.08804 387.205771,128.452154 360.010724,125.144528 C343.525021,103.224055 325.192524,82.7564475 305.214266,63.9661533 C336.586743,39.7116483 366.032313,27.1025182 389.135142,27.1025182 M378.356498,310.205598 C368.204912,327.830733 357.150626,344.919965 345.237759,361.405091 C325.045049,363.479997 304.758818,364.51205 284.459856,364.497299 C264.167589,364.51136 243.888075,363.479308 223.702025,361.405091 C211.820914,344.919381 200.80007,327.83006 190.683646,310.205598 C180.532593,292.629285 171.306974,274.534187 163.044553,255.99437 C171.306974,237.454554 180.532593,219.359455 190.683646,201.783142 C200.784121,184.229367 211.770999,167.201087 223.601665,150.764353 C243.824636,148.63809 264.145559,147.579168 284.479928,147.591877 C304.772146,147.579725 325.051559,148.611772 345.237759,150.68404 C357.109048,167.14607 368.136094,184.201112 378.27621,201.783142 C388.419418,219.363718 397.644825,237.458403 405.915303,255.99437 C397.644825,274.530337 388.419418,292.625022 378.27621,310.205598 M419.724813,290.127366 C426.09516,307.503536 431.324985,325.277083 435.380944,343.334682 C417.779633,348.823635 399.836793,353.149774 381.668372,356.285142 C388.573127,345.871232 395.263781,335.035679 401.740334,323.778483 C408.143291,312.655143 414.144807,301.431411 419.805101,290.207679 M246.363271,390.377981 C258.848032,391.140954 271.593728,391.582675 284.5,391.582675 C297.406272,391.582675 310.232256,391.140954 322.737089,390.377981 C310.880643,404.583418 298.10766,417.997563 284.5,430.534446 C270.921643,417.999548 258.18192,404.585125 246.363271,390.377981 Z M187.311556,356.244986 C169.137286,353.123646 151.187726,348.810918 133.578912,343.334682 C137.618549,325.305649 142.828222,307.559058 149.174827,290.207679 C154.754833,301.431411 160.736278,312.655143 167.239594,323.778483 C173.74291,334.901824 180.467017,345.864539 187.311556,356.285142 M149.174827,221.760984 C142.850954,204.473938 137.654787,186.794745 133.619056,168.834762 C151.18418,163.352378 169.085653,159.013101 187.211197,155.844146 C180.346585,166.224592 173.622478,176.986525 167.139234,188.210257 C160.65599,199.433989 154.734761,210.517173 149.074467,221.760984 M322.616657,121.590681 C310.131896,120.827708 297.3862,120.385987 284.379568,120.385987 C271.479987,120.385987 258.767744,120.787552 246.242839,121.590681 C258.061488,107.383537 270.801211,93.9691137 284.379568,81.4342157 C297.99241,93.9658277 310.765727,107.380324 322.616657,121.590681 Z M401.70019,188.210257 C395.196875,176.939676 388.472767,166.09743 381.527868,155.68352 C399.744224,158.819049 417.734224,163.151949 435.380944,168.654058 C431.331963,186.680673 426.122466,204.426664 419.785029,221.781062 C414.205023,210.55733 408.203506,199.333598 401.720262,188.230335 M127.517179,131.790423 C122.438973,82.3176579 132.816178,46.2973086 155.778503,33.0255968 C163.144699,28.9632474 171.455651,26.9264282 179.864858,27.1225964 C202.967687,27.1225964 232.413257,39.7317265 263.785734,63.9862316 C243.794133,82.7898734 225.448298,103.270812 208.949132,125.204763 C181.761691,128.528025 154.90355,134.14313 128.661281,141.990165 C128.199626,138.556788 127.778115,135.163566 127.456963,131.790423 M98.4529773,182.106474 C101.54406,180.767925 104.695358,179.429376 107.906872,178.090828 C114.220532,204.735668 122.781793,230.7969 133.498624,255.99437 C122.761529,281.241316 114.193296,307.357063 107.8868,334.058539 C56.7434387,313.076786 27.0971497,284.003505 27.0971497,255.99437 C27.0971497,229.450947 53.1907013,202.526037 98.4529773,182.106474 Z M155.778503,478.963143 C132.816178,465.691432 122.438973,429.671082 127.517179,380.198317 C127.838331,376.825174 128.259842,373.431953 128.721497,369.978497 C154.953686,377.878517 181.814655,383.514365 209.009348,386.824134 C225.500295,408.752719 243.832321,429.233234 263.805806,448.042665 C220.069,481.834331 180.105722,492.97775 155.838719,478.963143 M441.502893,380.198317 C446.520883,429.691161 436.203894,465.691432 413.221497,478.963143 C388.974566,493.017906 348.991216,481.834331 305.274481,448.042665 C325.241364,429.232737 343.566681,408.752215 360.050868,386.824134 C387.245915,383.516508 414.107066,377.880622 440.338719,369.978497 C440.820446,373.431953 441.221885,376.825174 441.563109,380.198317 M461.193488,334.018382 C454.869166,307.332523 446.294494,281.231049 435.561592,255.99437 C446.289797,230.744081 454.857778,204.629101 461.173416,177.930202 C512.216417,198.911955 541.942994,227.985236 541.942994,255.99437 C541.942994,284.003505 512.296705,313.076786 461.153344,334.058539" id="Shape"></path>
                    </g>
                </g>
            </g>
        </svg>
        
    )
}



================================================
FILE: app/components/logos/ReactRouter.tsx
================================================
import { type SVGProps } from 'react'

export default function ReactRouter(props: SVGProps<SVGSVGElement>) {
    return (
        <svg width="94" height="61" viewBox="0 0 94 61" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M72.7315 20.9357C70.0548 20.0941 68.6725 20.3778 65.8649 20.071C61.5246 19.5976 59.7954 17.9013 59.0619 13.5356C58.6514 11.0985 59.1361 7.53022 58.0881 5.32106C56.0839 1.10875 51.3943 -0.780439 46.6828 0.297843C42.7049 1.20956 39.3951 5.18518 39.2117 9.266C39.0021 13.9254 41.657 17.901 46.2156 19.273C48.3814 19.9261 50.6825 20.2548 52.9444 20.4214C57.0925 20.7238 57.4113 23.0297 58.5335 24.9277C59.2409 26.1243 59.9264 27.3034 59.9264 30.8714C59.9264 34.4394 59.2365 35.6185 58.5335 36.8151C57.4113 38.7087 56.0271 39.9491 51.879 40.2559C49.6171 40.4225 47.3116 40.7513 45.1502 41.4044C40.5916 42.7807 37.9367 46.7519 38.1463 51.4113C38.3297 55.4921 41.6395 59.4678 45.6174 60.3795C50.3289 61.4621 55.0185 59.5686 57.0227 55.3563C58.075 53.1471 58.6514 50.6443 59.0619 48.2072C59.7998 43.8414 61.5289 42.1451 65.8649 41.6717C68.6725 41.3649 71.5783 41.6717 74.2093 40.177C76.9895 38.1456 79.4734 35.0968 79.4734 30.8714C79.4734 26.6459 76.7967 22.2156 72.7315 20.9357Z" fill="#F44250"/>
        <path d="M28.1997 40.7739C22.7285 40.7739 18.2656 36.3027 18.2656 30.8213C18.2656 25.3399 22.7285 20.8687 28.1997 20.8687C33.6709 20.8687 38.1338 25.3399 38.1338 30.8213C38.1338 36.2983 33.6665 40.7739 28.1997 40.7739Z" fill="#121212"/>
        <path d="M9.899 61C4.43661 60.9868 -0.0130938 56.498 2.89511e-05 51.0122C0.0132099 45.5353 4.4936 41.0773 9.96914 41.0948C15.4359 41.108 19.8856 45.5968 19.8681 51.0825C19.8549 56.5551 15.3745 61.0131 9.899 61Z" fill="#121212"/>
        <path d="M83.7137 60.9998C78.2339 61.0304 73.7361 56.5901 73.7052 51.122C73.6747 45.632 78.1068 41.1258 83.5646 41.0949C89.0444 41.0643 93.5423 45.5046 93.5731 50.9727C93.6036 56.4583 89.1716 60.9689 83.7137 60.9998Z" fill="#121212"/>
        </svg>
        
    )
}



================================================
FILE: app/components/logos/TailwindIcon.tsx
================================================
import { type SVGProps } from "react";

export default function TailwindIcon(props: SVGProps<SVGSVGElement>) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 54 33">
      <g clipPath="url(#a)">
        <path
          fill="#38bdf8"
          fillRule="evenodd"
          d="M27 0c-7.2 0-11.7 3.6-13.5 10.8 2.7-3.6 5.85-4.95 9.45-4.05 2.054.513 3.522 2.004 5.147 3.653C30.744 13.09 33.808 16.2 40.5 16.2c7.2 0 11.7-3.6 13.5-10.8-2.7 3.6-5.85 4.95-9.45 4.05-2.054-.513-3.522-2.004-5.147-3.653C36.756 3.11 33.692 0 27 0zM13.5 16.2C6.3 16.2 1.8 19.8 0 27c2.7-3.6 5.85-4.95 9.45-4.05 2.054.514 3.522 2.004 5.147 3.653C17.244 29.29 20.308 32.4 27 32.4c7.2 0 11.7-3.6 13.5-10.8-2.7 3.6-5.85 4.95-9.45 4.05-2.054-.513-3.522-2.004-5.147-3.653C23.256 19.31 20.192 16.2 13.5 16.2z"
          clipRule="evenodd"
        />
      </g>
      <defs>
        <clipPath id="a">
          <path fill="#fff" d="M0 0h54v32.4H0z" />
        </clipPath>
      </defs>
    </svg>
  );
}



================================================
FILE: app/components/logos/Typescript.tsx
================================================
import { type SVGProps } from 'react'

export default function TypeScript(props: SVGProps<SVGSVGElement>) {
    return (
<svg viewBox="0 0 256 256" width="256" height="256" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid"><path d="M20 0h216c11.046 0 20 8.954 20 20v216c0 11.046-8.954 20-20 20H20c-11.046 0-20-8.954-20-20V20C0 8.954 8.954 0 20 0Z" fill="#3178C6"/><path d="M150.518 200.475v27.62c4.492 2.302 9.805 4.028 15.938 5.179 6.133 1.151 12.597 1.726 19.393 1.726 6.622 0 12.914-.633 18.874-1.899 5.96-1.266 11.187-3.352 15.678-6.257 4.492-2.906 8.048-6.704 10.669-11.394 2.62-4.689 3.93-10.486 3.93-17.391 0-5.006-.749-9.394-2.246-13.163a30.748 30.748 0 0 0-6.479-10.055c-2.821-2.935-6.205-5.567-10.149-7.898-3.945-2.33-8.394-4.531-13.347-6.602-3.628-1.497-6.881-2.949-9.761-4.359-2.879-1.41-5.327-2.848-7.342-4.316-2.016-1.467-3.571-3.021-4.665-4.661-1.094-1.64-1.641-3.495-1.641-5.567 0-1.899.489-3.61 1.468-5.135s2.362-2.834 4.147-3.927c1.785-1.094 3.973-1.942 6.565-2.547 2.591-.604 5.471-.906 8.638-.906 2.304 0 4.737.173 7.299.518 2.563.345 5.14.877 7.732 1.597a53.669 53.669 0 0 1 7.558 2.719 41.7 41.7 0 0 1 6.781 3.797v-25.807c-4.204-1.611-8.797-2.805-13.778-3.582-4.981-.777-10.697-1.165-17.147-1.165-6.565 0-12.784.705-18.658 2.115-5.874 1.409-11.043 3.61-15.506 6.602-4.463 2.993-7.99 6.805-10.582 11.437-2.591 4.632-3.887 10.17-3.887 16.615 0 8.228 2.375 15.248 7.127 21.06 4.751 5.811 11.963 10.731 21.638 14.759a291.458 291.458 0 0 1 10.625 4.575c3.283 1.496 6.119 3.049 8.509 4.66 2.39 1.611 4.276 3.366 5.658 5.265 1.382 1.899 2.073 4.057 2.073 6.474a9.901 9.901 0 0 1-1.296 4.963c-.863 1.524-2.174 2.848-3.93 3.97-1.756 1.122-3.945 1.999-6.565 2.632-2.62.633-5.687.95-9.2.95-5.989 0-11.92-1.05-17.794-3.151-5.875-2.1-11.317-5.25-16.327-9.451Zm-46.036-68.733H140V109H41v22.742h35.345V233h28.137V131.742Z" fill="#FFF"/></svg>    )
}



================================================
FILE: app/components/logos/YouTube.tsx
================================================
export default function YouTube() {
  return (
    <svg
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      className="h-8 w-8"
    >
      <path
        d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"
        fill="#FF0000"
      />
    </svg>
  );
}


================================================
FILE: app/components/preview/PreviewModal.tsx
================================================
import { Sheet, SheetContent, SheetHeader, SheetTitle } from "~/components/ui/sheet";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "~/components/ui/tabs";
import { Button } from "~/components/ui/button";
import { YouTubePreview } from "./YouTubePreview";
import { TwitterThreadPreview } from "./TwitterThreadPreview";
import { Youtube, Twitter, Copy, Download, Eye, Sparkles, X, Check } from "lucide-react";
import { toast } from "sonner";
import { useState } from "react";
import { cn } from "~/lib/utils";

interface PreviewModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  description?: string;
  tweets?: string;
  thumbnailUrl?: string;
  videoUrl?: string;
  duration?: number;
  channelName?: string;
  channelAvatar?: string;
  subscriberCount?: string;
  username?: string;
  displayName?: string;
  profileImage?: string;
}

export function PreviewModal({
  isOpen,
  onClose,
  title = "",
  description = "",
  tweets = "",
  thumbnailUrl,
  videoUrl,
  duration,
  channelName,
  channelAvatar,
  subscriberCount,
  username,
  displayName,
  profileImage
}: PreviewModalProps) {
  const [copiedYouTube, setCopiedYouTube] = useState(false);
  const [copiedTwitter, setCopiedTwitter] = useState(false);
  const [activeTab, setActiveTab] = useState("youtube");

  const handleCopyYouTube = () => {
    const content = `Title: ${title}\n\nDescription:\n${description}`;
    navigator.clipboard.writeText(content);
    setCopiedYouTube(true);
    toast.success("YouTube content copied to clipboard!");
    setTimeout(() => setCopiedYouTube(false), 2000);
  };
  
  const handleCopyTwitter = () => {
    navigator.clipboard.writeText(tweets);
    setCopiedTwitter(true);
    toast.success("Twitter thread copied to clipboard!");
    setTimeout(() => setCopiedTwitter(false), 2000);
  };
  
  const handleExportYouTube = () => {
    const content = `# YouTube Video\n\n## Title\n${title}\n\n## Description\n${description}`;
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'youtube-content.md';
    a.click();
    URL.revokeObjectURL(url);
    toast.success("YouTube content exported!");
  };
  
  const handleExportTwitter = () => {
    const content = `# Twitter Thread\n\n${tweets.split('\n\n').map((tweet, i) => `## Tweet ${i + 1}\n${tweet}`).join('\n\n')}`;
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'twitter-thread.md';
    a.click();
    URL.revokeObjectURL(url);
    toast.success("Twitter thread exported!");
  };

  return (
    <Sheet open={isOpen} onOpenChange={onClose}>
      <SheetContent side="right" className="w-full sm:w-[900px] lg:w-[900px] xl:w-[800px] sm:max-w-[90vw] overflow-hidden p-0">
        {/* Decorative background elements */}
        <div className="absolute inset-0 overflow-hidden pointer-events-none">
          <div className="absolute -top-24 -right-24 w-96 h-96 bg-gradient-to-br from-primary/10 via-primary/5 to-transparent rounded-full blur-3xl" />
          <div className="absolute -bottom-24 -left-24 w-96 h-96 bg-gradient-to-tr from-primary/10 via-primary/5 to-transparent rounded-full blur-3xl" />
        </div>
        
        {/* Header */}
        
        <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1 relative">
          <div className="px-6 pt-4 pb-2 bg-background/50 backdrop-blur-sm">
            <TabsList className="grid w-full max-w-md grid-cols-2 h-12 p-1 bg-muted/50">
              <TabsTrigger 
                value="youtube" 
                className={cn(
                  "gap-2 data-[state=active]:shadow-sm transition-all",
                  "data-[state=active]:bg-background data-[state=active]:text-foreground"
                )}
              >
                <Youtube className="h-4 w-4" />
                YouTube
              </TabsTrigger>
              <TabsTrigger 
                value="twitter" 
                className={cn(
                  "gap-2 data-[state=active]:shadow-sm transition-all",
                  "data-[state=active]:bg-background data-[state=active]:text-foreground"
                )}
              >
                <Twitter className="h-4 w-4" />
                Twitter/X
              </TabsTrigger>
            </TabsList>
          </div>
          
          <div className="overflow-y-auto max-h-[100vh]">
            <TabsContent value="youtube" className="p-6 pt-4 m-0">
              <div className="space-y-6">
                {/* Preview container with background */}
                <div className="relative rounded-xl bg-gradient-to-br from-background to-muted/30 p-6 shadow-inner">
                  <div className="absolute inset-0 bg-grid-white/5 rounded-xl pointer-events-none" />
                  <div className="relative">
                    <YouTubePreview
                      title={title}
                      description={description}
                      thumbnailUrl={thumbnailUrl}
                      videoUrl={videoUrl}
                      duration={duration}
                      channelName={channelName}
                      channelAvatar={channelAvatar}
                      subscriberCount={subscriberCount}
                    />
                  </div>
                </div>
              </div>
            </TabsContent>
            
            <TabsContent value="twitter" className="p-6 pt-4 m-0">
              <div className="space-y-6">
                {/* Action buttons */}
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Sparkles className="h-4 w-4 text-muted-foreground" />
                    <span className="text-sm text-muted-foreground">AI-generated thread</span>
                  </div>
                  <div className="flex gap-2">
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={handleCopyTwitter}
                      className={cn(
                        "gap-2 transition-all",
                        copiedTwitter && "bg-green-500/10 text-green-600 border-green-500/20"
                      )}
                    >
                      {copiedTwitter ? (
                        <>
                          <Check className="h-4 w-4" />
                          Copied!
                        </>
                      ) : (
                        <>
                          <Copy className="h-4 w-4" />
                          Copy Thread
                        </>
                      )}
                    </Button>
                    <Button 
                      variant="outline" 
                      size="sm"
                      onClick={handleExportTwitter}
                      className="gap-2 hover:bg-primary/10 hover:text-primary hover:border-primary/20"
                    >
                      <Download className="h-4 w-4" />
                      Export
                    </Button>
                  </div>
                </div>
                
                {/* Preview container with background */}
                <div className="relative rounded-xl bg-gradient-to-br from-background to-muted/30 p-6 shadow-inner">
                  <div className="absolute inset-0 bg-grid-white/5 rounded-xl pointer-events-none" />
                  <div className="relative">
                    <TwitterThreadPreview
                      tweets={tweets}
                      username={username}
                      displayName={displayName || channelName}
                      profileImage={profileImage || channelAvatar}
                      media={thumbnailUrl ? [thumbnailUrl] : []}
                    />
                  </div>
                </div>
              </div>
            </TabsContent>
          </div>
        
        </Tabs>
      </SheetContent>
    </Sheet>
  );
}


================================================
FILE: app/components/preview/TwitterThreadPreview.tsx
================================================
import { useState } from "react";
import { Card } from "~/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "~/components/ui/avatar";
import { Button } from "~/components/ui/button";
import { 
  MessageCircle, 
  Repeat2, 
  Heart, 
  Share,
  MoreHorizontal,
  Bookmark,
  BarChart3,
  Image as ImageIcon
} from "lucide-react";

interface Tweet {
  id: string;
  content: string;
  media?: string[];
  timestamp?: Date;
}

interface TwitterThreadPreviewProps {
  tweets: string | string[]; // Can be a single string with line breaks or array
  username?: string;
  displayName?: string;
  profileImage?: string;
  verified?: boolean;
  media?: string[]; // Images/thumbnails to include in tweets
}

export function TwitterThreadPreview({
  tweets,
  username = "yourhandle",
  displayName = "Your Name",
  profileImage,
  verified = false,
  media = []
}: TwitterThreadPreviewProps) {
  const [likedTweets, setLikedTweets] = useState<Set<string>>(new Set());
  const [retweetedTweets, setRetweetedTweets] = useState<Set<string>>(new Set());
  const [bookmarkedTweets, setBookmarkedTweets] = useState<Set<string>>(new Set());
  
  // Parse tweets into array
  const tweetArray: Tweet[] = Array.isArray(tweets) 
    ? tweets.map((content, i) => ({ id: `tweet-${i}`, content }))
    : tweets.split('\n\n').filter(t => t.trim()).map((content, i) => ({ 
        id: `tweet-${i}`, 
        content: content.trim() 
      }));
  
  // Add media to first tweet if available
  if (media.length > 0 && tweetArray.length > 0) {
    tweetArray[0].media = media.slice(0, 4); // Max 4 images per tweet
  }
  
  // Format timestamp
  const formatTime = (date?: Date) => {
    const now = date || new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes();
    const ampm = hours >= 12 ? 'PM' : 'AM';
    const formattedHours = hours % 12 || 12;
    return `${formattedHours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
  };
  
  const formatDate = (date?: Date) => {
    const now = date || new Date();
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return `${months[now.getMonth()]} ${now.getDate()}, ${now.getFullYear()}`;
  };
  
  // Format numbers
  const formatNumber = (num: number) => {
    if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
    if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;
    return num.toString();
  };
  
  // Random engagement numbers for demo
  const getEngagement = (index: number) => ({
    replies: Math.floor(Math.random() * 50) + index * 5,
    retweets: Math.floor(Math.random() * 100) + index * 10,
    likes: Math.floor(Math.random() * 500) + index * 20,
    views: Math.floor(Math.random() * 5000) + index * 100
  });

  const handleLike = (tweetId: string) => {
    const newLikes = new Set(likedTweets);
    if (newLikes.has(tweetId)) {
      newLikes.delete(tweetId);
    } else {
      newLikes.add(tweetId);
    }
    setLikedTweets(newLikes);
  };
  
  const handleRetweet = (tweetId: string) => {
    const newRetweets = new Set(retweetedTweets);
    if (newRetweets.has(tweetId)) {
      newRetweets.delete(tweetId);
    } else {
      newRetweets.add(tweetId);
    }
    setRetweetedTweets(newRetweets);
  };
  
  const handleBookmark = (tweetId: string) => {
    const newBookmarks = new Set(bookmarkedTweets);
    if (newBookmarks.has(tweetId)) {
      newBookmarks.delete(tweetId);
    } else {
      newBookmarks.add(tweetId);
    }
    setBookmarkedTweets(newBookmarks);
  };

  return (
    <div className="w-full max-w-2xl mx-auto space-y-0">
      {tweetArray.map((tweet, index) => {
        const engagement = getEngagement(index);
        const isLiked = likedTweets.has(tweet.id);
        const isRetweeted = retweetedTweets.has(tweet.id);
        const isBookmarked = bookmarkedTweets.has(tweet.id);
        
        return (
          <div key={tweet.id} className="relative">
            {/* Thread line */}
            {index < tweetArray.length - 1 && (
              <div className="absolute left-[27px] top-[60px] bottom-0 w-[2px] bg-border" />
            )}
            
            <Card className="rounded-none border-x-0 border-t-0 p-4 hover:bg-secondary/10 transition-colors">
              <div className="flex gap-3">
                {/* Avatar */}
                <Avatar className="h-12 w-12 flex-shrink-0">
                  <AvatarImage src={profileImage} />
                  <AvatarFallback>{displayName.slice(0, 2).toUpperCase()}</AvatarFallback>
                </Avatar>
                
                {/* Content */}
                <div className="flex-1 space-y-1">
                  {/* Header */}
                  <div className="flex items-start justify-between">
                    <div className="flex items-center gap-1">
                      <p className="font-semibold">{displayName}</p>
                      {verified && (
                        <svg className="h-5 w-5 text-blue-500" viewBox="0 0 24 24" fill="currentColor">
                          <path d="M8.52 3.59a2.57 2.57 0 002.96 0l1.02-.633 1.02.633a2.57 2.57 0 002.96 0l.633-1.02.633 1.02a2.57 2.57 0 002.96 0L22 2.24a.75.75 0 00-.75-1.3l-1.02.633-1.02-.633a2.57 2.57 0 00-2.96 0l-.633 1.02-.633-1.02a2.57 2.57 0 00-2.96 0l-1.02.633-1.02-.633a2.57 2.57 0 00-2.96 0L6 2.24a.75.75 0 00.75 1.3l1.77-1.095zM12 7.5a4.5 4.5 0 110 9 4.5 4.5 0 010-9zm0 1.5a3 3 0 100 6 3 3 0 000-6zm-2.12 2.12a.75.75 0 011.06 0l.59.59 1.59-1.59a.75.75 0 111.06 1.06l-2.12 2.12a.75.75 0 01-1.06 0l-1.12-1.12a.75.75 0 010-1.06z"/>
                        </svg>
                      )}
                      <p className="text-muted-foreground">@{username}</p>
                      <span className="text-muted-foreground">¬∑</span>
                      <p className="text-muted-foreground">
                        {index === 0 ? 'now' : `${index}m`}
                      </p>
                    </div>
                    
                    <Button variant="ghost" size="icon" className="h-8 w-8 rounded-full">
                      <MoreHorizontal className="h-4 w-4" />
                    </Button>
                  </div>
                  
                  {/* Tweet content */}
                  <p className="text-[15px] leading-normal whitespace-pre-wrap">
                    {tweet.content}
                  </p>
                  
                  {/* Media */}
                  {tweet.media && tweet.media.length > 0 && (
                    <div className={`grid gap-0.5 rounded-2xl overflow-hidden mt-3 ${
                      tweet.media.length === 1 ? 'grid-cols-1' :
                      tweet.media.length === 2 ? 'grid-cols-2' :
                      tweet.media.length === 3 ? 'grid-cols-2' :
                      'grid-cols-2'
                    }`}>
                      {tweet.media.map((mediaUrl, i) => (
                        <div 
                          key={i} 
                          className={`relative bg-muted ${
                            tweet.media!.length === 3 && i === 0 ? 'row-span-2' : ''
                          }`}
                        >
                          <img
                            src={mediaUrl}
                            alt=""
                            className="w-full h-full object-cover"
                          />
                        </div>
                      ))}
                    </div>
                  )}
                  
                  {/* Actions */}
                  <div className="flex items-center justify-between pt-3 max-w-md">
                    <Button 
                      variant="ghost" 
                      size="sm" 
                      className="h-8 px-2 gap-2 text-muted-foreground hover:text-blue-500 hover:bg-blue-500/10"
                    >
                      <MessageCircle className="h-4 w-4" />
                      <span className="text-xs">{engagement.replies}</span>
                    </Button>
                    
                    <Button 
                      variant="ghost" 
                      size="sm" 
                      className={`h-8 px-2 gap-2 ${
                        isRetweeted 
                          ? 'text-green-500 hover:text-green-600' 
                          : 'text-muted-foreground hover:text-green-500'
                      } hover:bg-green-500/10`}
                      onClick={() => handleRetweet(tweet.id)}
                    >
                      <Repeat2 className="h-4 w-4" />
                      <span className="text-xs">{engagement.retweets}</span>
                    </Button>
                    
                    <Button 
                      variant="ghost" 
                      size="sm" 
                      className={`h-8 px-2 gap-2 ${
                        isLiked 
                          ? 'text-red-500 hover:text-red-600' 
                          : 'text-muted-foreground hover:text-red-500'
                      } hover:bg-red-500/10`}
                      onClick={() => handleLike(tweet.id)}
                    >
                      <Heart className={`h-4 w-4 ${isLiked ? 'fill-current' : ''}`} />
                      <span className="text-xs">
                        {engagement.likes + (isLiked ? 1 : 0)}
                      </span>
                    </Button>
                    
                    <Button 
                      variant="ghost" 
                      size="sm" 
                      className="h-8 px-2 gap-2 text-muted-foreground hover:text-blue-500 hover:bg-blue-500/10"
                    >
                      <BarChart3 className="h-4 w-4" />
                      <span className="text-xs">{formatNumber(engagement.views)}</span>
                    </Button>
                    
                    <div className="flex items-center gap-1">
                      <Button 
                        variant="ghost" 
                        size="icon" 
                        className={`h-8 w-8 ${
                          isBookmarked 
                            ? 'text-blue-500 hover:text-blue-600' 
                            : 'text-muted-foreground hover:text-blue-500'
                        } hover:bg-blue-500/10`}
                        onClick={() => handleBookmark(tweet.id)}
                      >
                        <Bookmark className={`h-4 w-4 ${isBookmarked ? 'fill-current' : ''}`} />
                      </Button>
                      
                      <Button 
                        variant="ghost" 
                        size="icon" 
                        className="h-8 w-8 text-muted-foreground hover:text-blue-500 hover:bg-blue-500/10"
                      >
                        <Share className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                </div>
              </div>
            </Card>
          </div>
        );
      })}
      
      {/* Thread summary */}
      {tweetArray.length > 1 && (
        <Card className="rounded-none border-x-0 border-t-0 p-4 bg-secondary/20">
          <p className="text-sm text-muted-foreground text-center">
            Thread ‚Ä¢ {tweetArray.length} Tweets ‚Ä¢ {formatTime()} ‚Ä¢ {formatDate()}
          </p>
        </Card>
      )}
    </div>
  );
}


================================================
FILE: app/components/preview/YouTubePreview.tsx
================================================
import { useState } from "react";
import { Card } from "~/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "~/components/ui/avatar";
import { Button } from "~/components/ui/button";
import { 
  ThumbsUp, 
  ThumbsDown, 
  Share2, 
  Download, 
  MoreHorizontal,
  BellOff
} from "lucide-react";
import { formatDuration } from "~/lib/video-metadata";

interface YouTubePreviewProps {
  title: string;
  description: string;
  thumbnailUrl?: string;
  videoUrl?: string;
  duration?: number;
  channelName?: string;
  channelAvatar?: string;
  subscriberCount?: string;
  viewCount?: string;
  uploadDate?: string;
}

export function YouTubePreview({
  title,
  description,
  thumbnailUrl,
  videoUrl,
  duration,
  channelName = "Your Channel",
  channelAvatar,
  subscriberCount = "1.2K",
  viewCount = "0",
  uploadDate = "Just now"
}: YouTubePreviewProps) {
  const [isPlaying, setIsPlaying] = useState(false);
  const [showFullDescription, setShowFullDescription] = useState(false);
  const [isSubscribed, setIsSubscribed] = useState(false);
  
  // Format view count
  const formatViews = (views: string) => {
    const num = parseInt(views);
    if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M views`;
    if (num >= 1000) return `${(num / 1000).toFixed(0)}K views`;
    return `${num} views`;
  };
  
  // Truncate description
  const truncateDescription = (text: string, maxLines: number = 3) => {
    const words = text.split(' ');
    const wordsPerLine = 15; // Approximate
    const maxWords = maxLines * wordsPerLine;
    
    if (words.length <= maxWords) return text;
    return words.slice(0, maxWords).join(' ') + '...';
  };

  return (
    <div className="max-w-3xl mx-auto">
      <div className="space-y-4">
        {/* Video Player */}
        <Card className="relative aspect-video bg-black overflow-hidden">
            {isPlaying && videoUrl ? (
              <video
                src={videoUrl}
                className="w-full h-full object-contain"
                controls
                autoPlay
                onEnded={() => setIsPlaying(false)}
              />
            ) : (
              <>
                {thumbnailUrl ? (
                  <img
                    src={thumbnailUrl}
                    alt={title}
                    className="w-full h-full object-cover"
                  />
                ) : (
                  <div className="w-full h-full bg-muted flex items-center justify-center">
                    <p className="text-muted-foreground">No thumbnail</p>
                  </div>
                )}
                
                {/* Play button overlay */}
                {videoUrl && (
                  <button
                    onClick={() => setIsPlaying(true)}
                    className="absolute inset-0 flex items-center justify-center bg-black/20 hover:bg-black/30 transition-colors"
                  >
                    <div className="w-20 h-20 bg-red-600 rounded-full flex items-center justify-center">
                      <svg className="w-8 h-8 text-white ml-1" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z" />
                      </svg>
                    </div>
                  </button>
                )}
                
                {/* Duration badge */}
                {duration && !isPlaying && (
                  <div className="absolute bottom-2 right-2 bg-black/80 text-white text-xs px-1 rounded">
                    {formatDuration(duration)}
                  </div>
                )}
              </>
            )}
          </Card>
          
          {/* Video Info */}
          <div className="space-y-4 w-fit">
            {/* Title */}
            <h1 className="text-xl font-semibold line-clamp-2">
              {title || "Video Title"}
            </h1>
            
            {/* Channel and Actions */}
            <div className="flex items-start justify-between gap-4">
              <div className="flex items-start gap-3">
                <Avatar className="h-10 w-10">
                  <AvatarImage src={channelAvatar} />
                  <AvatarFallback>{channelName.slice(0, 2).toUpperCase()}</AvatarFallback>
                </Avatar>
                
                <div>
                  <p className="font-semibold">{channelName}</p>
                  <p className="text-sm text-muted-foreground">
                    {subscriberCount} subscribers
                  </p>
                </div>
                
                <Button
                  variant={isSubscribed ? "secondary" : "default"}
                  className={isSubscribed ? "gap-2" : "bg-black hover:bg-black/90 text-white"}
                  onClick={() => setIsSubscribed(!isSubscribed)}
                >
                  {isSubscribed ? (
                    <>
                      <BellOff className="h-4 w-4" />
                      Subscribed
                    </>
                  ) : (
                    "Subscribe"
                  )}
                </Button>
              </div>
              
              {/* Action buttons */}
              <div className="flex items-center gap-2">
                <div className="flex items-center bg-secondary rounded-full">
                  <Button variant="ghost" size="sm" className="rounded-l-full gap-2">
                    <ThumbsUp className="h-4 w-4" />
                    <span className="text-sm">0</span>
                  </Button>
                  <div className="w-px h-6 bg-border" />
                  <Button variant="ghost" size="sm" className="rounded-r-full">
                    <ThumbsDown className="h-4 w-4" />
                  </Button>
                </div>
                
                <Button variant="secondary" size="sm" className="gap-2 rounded-full">
                  <Share2 className="h-4 w-4" />
                  Share
                </Button>
                
                <Button variant="secondary" size="sm" className="gap-2 rounded-full">
                  <Download className="h-4 w-4" />
                  Download
                </Button>
                
                <Button variant="ghost" size="icon" className="rounded-full">
                  <MoreHorizontal className="h-4 w-4" />
                </Button>
              </div>
            </div>
            
            {/* Description */}
            <Card className="p-4 bg-secondary/50">
              <div className="space-y-2">
                <p className="text-sm font-medium">
                  {formatViews(viewCount)} ‚Ä¢ {uploadDate}
                </p>
                
                <div className="text-sm">
                  <p className="whitespace-pre-wrap">
                    {showFullDescription 
                      ? description 
                      : truncateDescription(description || "Video description will appear here...")}
                  </p>
                  
                  {description && description.split(' ').length > 45 && (
                    <button
                      onClick={() => setShowFullDescription(!showFullDescription)}
                      className="font-medium hover:underline mt-1"
                    >
                      {showFullDescription ? "Show less" : "...more"}
                    </button>
                  )}
                </div>
              </div>
            </Card>
          </div>
      </div>
    </div>
  );
}


================================================
FILE: app/components/ui/alert-dialog.tsx
================================================
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "~/lib/utils"
import { buttonVariants } from "~/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}



================================================
FILE: app/components/ui/avatar.tsx
================================================
import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "~/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }



================================================
FILE: app/components/ui/badge.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "~/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }



================================================
FILE: app/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "~/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
FILE: app/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "~/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}



================================================
FILE: app/components/ui/chart.tsx
================================================
import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "~/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

function ChartContainer({
  id,
  className,
  children,
  config,
  ...props
}: React.ComponentProps<"div"> & {
  config: ChartConfig
  children: React.ComponentProps<
    typeof RechartsPrimitive.ResponsiveContainer
  >["children"]
}) {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-slot="chart"
        data-chart={chartId}
        className={cn(
          "[&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border flex aspect-video justify-center text-xs [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-sector]:outline-hidden [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-surface]:outline-hidden",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
}

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  // Sanitize the chart ID to prevent CSS injection
  const sanitizedId = id.replace(/[^a-zA-Z0-9-_]/g, '');
  
  // Validate and sanitize color values
  const sanitizeColor = (color: string): string => {
    // Only allow valid CSS color formats (hex, rgb, rgba, hsl, hsla, named colors)
    const validColorPattern = /^(#[0-9a-fA-F]{3,8}|rgb\([^)]+\)|rgba\([^)]+\)|hsl\([^)]+\)|hsla\([^)]+\)|[a-zA-Z]+)$/;
    return validColorPattern.test(color) ? color : 'transparent';
  };

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${sanitizedId}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    if (!color) return null;
    
    // Sanitize the key and color value
    const sanitizedKey = key.replace(/[^a-zA-Z0-9-_]/g, '');
    const sanitizedColor = sanitizeColor(color);
    
    return `  --color-${sanitizedKey}: ${sanitizedColor};`
  })
  .filter(Boolean)
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

function ChartTooltipContent({
  active,
  payload,
  className,
  indicator = "dot",
  hideLabel = false,
  hideIndicator = false,
  label,
  labelFormatter,
  labelClassName,
  formatter,
  color,
  nameKey,
  labelKey,
}: React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
  React.ComponentProps<"div"> & {
    hideLabel?: boolean
    hideIndicator?: boolean
    indicator?: "line" | "dot" | "dashed"
    nameKey?: string
    labelKey?: string
  }) {
  const { config } = useChart()

  const tooltipLabel = React.useMemo(() => {
    if (hideLabel || !payload?.length) {
      return null
    }

    const [item] = payload
    const key = `${labelKey || item?.dataKey || item?.name || "value"}`
    const itemConfig = getPayloadConfigFromPayload(config, item, key)
    const value =
      !labelKey && typeof label === "string"
        ? config[label as keyof typeof config]?.label || label
        : itemConfig?.label

    if (labelFormatter) {
      return (
        <div className={cn("font-medium", labelClassName)}>
          {labelFormatter(value, payload)}
        </div>
      )
    }

    if (!value) {
      return null
    }

    return <div className={cn("font-medium", labelClassName)}>{value}</div>
  }, [
    label,
    labelFormatter,
    payload,
    hideLabel,
    labelClassName,
    config,
    labelKey,
  ])

  if (!active || !payload?.length) {
    return null
  }

  const nestLabel = payload.length === 1 && indicator !== "dot"

  return (
    <div
      className={cn(
        "border-border/50 bg-background grid min-w-[8rem] items-start gap-1.5 rounded-lg border px-2.5 py-1.5 text-xs shadow-xl",
        className
      )}
    >
      {!nestLabel ? tooltipLabel : null}
      <div className="grid gap-1.5">
        {payload.map((item, index) => {
          const key = `${nameKey || item.name || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)
          const indicatorColor = color || item.payload.fill || item.color

          return (
            <div
              key={item.dataKey}
              className={cn(
                "[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5",
                indicator === "dot" && "items-center"
              )}
            >
              {formatter && item?.value !== undefined && item.name ? (
                formatter(item.value, item.name, item, index, item.payload)
              ) : (
                <>
                  {itemConfig?.icon ? (
                    <itemConfig.icon />
                  ) : (
                    !hideIndicator && (
                      <div
                        className={cn(
                          "shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)",
                          {
                            "h-2.5 w-2.5": indicator === "dot",
                            "w-1": indicator === "line",
                            "w-0 border-[1.5px] border-dashed bg-transparent":
                              indicator === "dashed",
                            "my-0.5": nestLabel && indicator === "dashed",
                          }
                        )}
                        style={
                          {
                            "--color-bg": indicatorColor,
                            "--color-border": indicatorColor,
                          } as React.CSSProperties
                        }
                      />
                    )
                  )}
                  <div
                    className={cn(
                      "flex flex-1 justify-between leading-none",
                      nestLabel ? "items-end" : "items-center"
                    )}
                  >
                    <div className="grid gap-1.5">
                      {nestLabel ? tooltipLabel : null}
                      <span className="text-muted-foreground">
                        {itemConfig?.label || item.name}
                      </span>
                    </div>
                    {item.value && (
                      <span className="text-foreground font-mono font-medium tabular-nums">
                        {item.value.toLocaleString()}
                      </span>
                    )}
                  </div>
                </>
              )}
            </div>
          )
        })}
      </div>
    </div>
  )
}

const ChartLegend = RechartsPrimitive.Legend

function ChartLegendContent({
  className,
  hideIcon = false,
  payload,
  verticalAlign = "bottom",
  nameKey,
}: React.ComponentProps<"div"> &
  Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
    hideIcon?: boolean
    nameKey?: string
  }) {
  const { config } = useChart()

  if (!payload?.length) {
    return null
  }

  return (
    <div
      className={cn(
        "flex items-center justify-center gap-4",
        verticalAlign === "top" ? "pb-3" : "pt-3",
        className
      )}
    >
      {payload.map((item) => {
        const key = `${nameKey || item.dataKey || "value"}`
        const itemConfig = getPayloadConfigFromPayload(config, item, key)

        return (
          <div
            key={item.value}
            className={cn(
              "[&>svg]:text-muted-foreground flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3"
            )}
          >
            {itemConfig?.icon && !hideIcon ? (
              <itemConfig.icon />
            ) : (
              <div
                className="h-2 w-2 shrink-0 rounded-[2px]"
                style={{
                  backgroundColor: item.color,
                }}
              />
            )}
            {itemConfig?.label}
          </div>
        )
      })}
    </div>
  )
}

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}



================================================
FILE: app/components/ui/checkbox.tsx
================================================
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "~/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }



================================================
FILE: app/components/ui/dialog.tsx
================================================
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "~/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}



================================================
FILE: app/components/ui/dropdown-menu.tsx
================================================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "~/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}



================================================
FILE: app/components/ui/form.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import type {
  ControllerProps,
  FieldPath,
  FieldValues,
} from "react-hook-form"
import {
  Controller,
  FormProvider,
  useFormContext,
} from "react-hook-form"
import { cn } from "~/lib/utils"
import { Label } from "~/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof Label>,
  React.ComponentPropsWithoutRef<typeof Label>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}


================================================
FILE: app/components/ui/hero-designali.tsx
================================================
"use client";

import { cn } from "~/lib/utils";

// @ts-ignore
function n(e) {
  // @ts-ignore
  this.init(e || {});
}
n.prototype = {
  // @ts-ignore
  init: function (e) {
    // @ts-ignore
    this.phase = e.phase || 0;
    // @ts-ignore
    this.offset = e.offset || 0;
    // @ts-ignore
    this.frequency = e.frequency || 0.001;
    // @ts-ignore
    this.amplitude = e.amplitude || 1;
  },
  update: function () {
    return (
      // @ts-ignore
      (this.phase += this.frequency),
      // @ts-ignore
      (e = this.offset + Math.sin(this.phase) * this.amplitude)
    );
  },
  value: function () {
    return e;
  },
};

// @ts-ignore
function Line(e) {
  // @ts-ignore
  this.init(e || {});
}

Line.prototype = {
  // @ts-ignore
  init: function (e) {
    // @ts-ignore
    this.spring = e.spring + 0.1 * Math.random() - 0.05;
    // @ts-ignore
    this.friction = E.friction + 0.01 * Math.random() - 0.005;
    // @ts-ignore
    this.nodes = [];
    for (var t, n = 0; n < E.size; n++) {
      t = new Node();
      // @ts-ignore
      t.x = pos.x;
      // @ts-ignore
      t.y = pos.y;
      // @ts-ignore
      this.nodes.push(t);
    }
  },
  update: function () {
    // @ts-ignore
    let e = this.spring,
      // @ts-ignore
      t = this.nodes[0];
    // @ts-ignore
    t.vx += (pos.x - t.x) * e;
    // @ts-ignore
    t.vy += (pos.y - t.y) * e;
    // @ts-ignore
    for (var n, i = 0, a = this.nodes.length; i < a; i++)
      // @ts-ignore
      (t = this.nodes[i]),
        0 < i &&
          // @ts-ignore
          ((n = this.nodes[i - 1]),
          (t.vx += (n.x - t.x) * e),
          (t.vy += (n.y - t.y) * e),
          (t.vx += n.vx * E.dampening),
          (t.vy += n.vy * E.dampening)),
        // @ts-ignore
        (t.vx *= this.friction),
        // @ts-ignore
        (t.vy *= this.friction),
        (t.x += t.vx),
        (t.y += t.vy),
        (e *= E.tension);
  },
  draw: function () {
    let e,
      t,
      // @ts-ignore
      n = this.nodes[0].x,
      // @ts-ignore
      i = this.nodes[0].y;
    // @ts-ignore
    ctx.beginPath();
    // @ts-ignore
    ctx.moveTo(n, i);
    // @ts-ignore
    for (var a = 1, o = this.nodes.length - 2; a < o; a++) {
      // @ts-ignore
      e = this.nodes[a];
      // @ts-ignore
      t = this.nodes[a + 1];
      n = 0.5 * (e.x + t.x);
      i = 0.5 * (e.y + t.y);
      // @ts-ignore
      ctx.quadraticCurveTo(e.x, e.y, n, i);
    }
    // @ts-ignore
    e = this.nodes[a];
    // @ts-ignore
    t = this.nodes[a + 1];
    // @ts-ignore
    ctx.quadraticCurveTo(e.x, e.y, t.x, t.y);
    // @ts-ignore
    ctx.stroke();
    // @ts-ignore
    ctx.closePath();
  },
};

// @ts-ignore
function onMousemove(e) {
  function o() {
    lines = [];
    for (let e = 0; e < E.trails; e++)
      lines.push(new Line({ spring: 0.45 + (e / E.trails) * 0.025 }));
  }
  // @ts-ignore
  function c(e) {
    e.touches
      ? // @ts-ignore
        ((pos.x = e.touches[0].pageX), (pos.y = e.touches[0].pageY))
      : // @ts-ignore
        ((pos.x = e.clientX), (pos.y = e.clientY)),
      e.preventDefault();
  }
  // @ts-ignore
  function l(e) {
    // @ts-ignore
    1 == e.touches.length &&
      ((pos.x = e.touches[0].pageX), (pos.y = e.touches[0].pageY));
  }
  document.removeEventListener("mousemove", onMousemove),
    document.removeEventListener("touchstart", onMousemove),
    document.addEventListener("mousemove", c),
    document.addEventListener("touchmove", c),
    document.addEventListener("touchstart", l),
    c(e),
    o(),
    render();
}

function render() {
  // @ts-ignore
  if (ctx.running) {
    // @ts-ignore
    ctx.globalCompositeOperation = "source-over";
    // @ts-ignore
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    // @ts-ignore
    ctx.globalCompositeOperation = "lighter";
    // @ts-ignore
    ctx.strokeStyle = "hsla(" + Math.round(f.update()) + ",100%,50%,0.025)";
    // @ts-ignore
    ctx.lineWidth = 10;
    for (var e, t = 0; t < E.trails; t++) {
      // @ts-ignore
      (e = lines[t]).update();
      e.draw();
    }
    // @ts-ignore
    ctx.frame++;
    window.requestAnimationFrame(render);
  }
}

function resizeCanvas() {
  // @ts-ignore
  ctx.canvas.width = window.innerWidth - 20;
  // @ts-ignore
  ctx.canvas.height = window.innerHeight;
}

// @ts-ignore
var ctx,
  // @ts-ignore
  f,
  e = 0,
  pos = {},
  // @ts-ignore
  lines = [],
  E = {
    debug: true,
    friction: 0.5,
    trails: 80,
    size: 50,
    dampening: 0.025,
    tension: 0.99,
  };
function Node() {
  this.x = 0;
  this.y = 0;
  this.vy = 0;
  this.vx = 0;
}

const renderCanvas = function () {
  // @ts-ignore
  ctx = document.getElementById("canvas").getContext("2d");
  ctx.running = true;
  ctx.frame = 1;
  f = new n({
    phase: Math.random() * 2 * Math.PI,
    amplitude: 85,
    frequency: 0.0015,
    offset: 285,
  });
  document.addEventListener("mousemove", onMousemove);
  document.addEventListener("touchstart", onMousemove);
  document.body.addEventListener("orientationchange", resizeCanvas);
  window.addEventListener("resize", resizeCanvas);
  window.addEventListener("focus", () => {
    // @ts-ignore
    if (!ctx.running) {
      // @ts-ignore
      ctx.running = true;
      render();
    }
  });
  window.addEventListener("blur", () => {
    // @ts-ignore
    ctx.running = true;
  });
  resizeCanvas();
};

import { ReactTyped } from "react-typed";

interface TypeWriterProps {
  strings: string[];
}


const TypeWriter = ({ strings }: TypeWriterProps) => {
  return (
    <ReactTyped
      loop
      typeSpeed={80}
      backSpeed={20}
      strings={strings}
      smartBackspace
      backDelay={1000}
      loopCount={0}
      showCursor
      cursorChar="|"
    />
  );
};

type TColorProp = string | string[];

interface ShineBorderProps {
  borderRadius?: number;
  borderWidth?: number;
  duration?: number;
  color?: TColorProp;
  className?: string;
  children: React.ReactNode;
}

/**
 * @name Shine Border
 * @description It is an animated background border effect component with easy to use and configurable props.
 * @param borderRadius defines the radius of the border.
 * @param borderWidth defines the width of the border.
 * @param duration defines the animation duration to be applied on the shining border
 * @param color a string or string array to define border color.
 * @param className defines the class name to be applied to the component
 * @param children contains react node elements.
 */
function ShineBorder({
  borderRadius = 8,
  borderWidth = 1,
  duration = 14,
  color = "#000000",
  className,
  children,
}: ShineBorderProps) {
  return (
    <div
      style={
        {
          "--border-radius": `${borderRadius}px`,
        } as React.CSSProperties
      }
      className={cn(
        "relative grid h-full w-full place-items-center rounded-3xl bg-white p-3 text-black dark:bg-black dark:text-white",
        className,
      )}
    >
      <div
        style={
          {
            "--border-width": `${borderWidth}px`,
            "--border-radius": `${borderRadius}px`,
            "--shine-pulse-duration": `${duration}s`,
            "--mask-linear-gradient": `linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0)`,
            "--background-radial-gradient": `radial-gradient(transparent,transparent, ${color instanceof Array ? color.join(",") : color},transparent,transparent)`,
          } as React.CSSProperties
        }
        className={`before:bg-shine-size before:absolute before:inset-0 before:aspect-square before:size-full before:rounded-3xl before:p-[--border-width] before:will-change-[background-position] before:content-[""] before:![-webkit-mask-composite:xor] before:[background-image:--background-radial-gradient] before:[background-size:300%_300%] before:![mask-composite:exclude] before:[mask:--mask-linear-gradient] motion-safe:before:animate-[shine-pulse_var(--shine-pulse-duration)_infinite_linear]`}
      ></div>
      {children}
    </div>
  );
}



export { renderCanvas, TypeWriter, ShineBorder }


================================================
FILE: app/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "~/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }



================================================
FILE: app/components/ui/label.tsx
================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "~/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }



================================================
FILE: app/components/ui/progress.tsx
================================================
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "~/lib/utils"

function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn(
        "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",
        className
      )}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
}

export { Progress }



================================================
FILE: app/components/ui/scroll-area.tsx
================================================
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "~/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }



================================================
FILE: app/components/ui/select.tsx
================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "~/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}



================================================
FILE: app/components/ui/separator.tsx
================================================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "~/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }



================================================
FILE: app/components/ui/sheet.tsx
================================================
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "~/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}



================================================
FILE: app/components/ui/sidebar.tsx
================================================
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import {type VariantProps, cva } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"

import { useIsMobile } from "~/hooks/use-mobile"
import { cn } from "~/lib/utils"
import { Button } from "~/components/ui/button"
import { Input } from "~/components/ui/input"
import { Separator } from "~/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "~/components/ui/sheet"
import { Skeleton } from "~/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "~/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener("keydown", handleKeyDown)
    return () => window.removeEventListener("keydown", handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed"

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button"
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}



================================================
FILE: app/components/ui/skeleton.tsx
================================================
import { cn } from "~/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: app/components/ui/table.tsx
================================================
"use client"

import * as React from "react"

import { cn } from "~/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}



================================================
FILE: app/components/ui/tabs.tsx
================================================
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "~/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: app/components/ui/textarea.tsx
================================================
import * as React from "react"
import { cn } from "~/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }


================================================
FILE: app/components/ui/toggle-group.tsx
================================================
import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "~/lib/utils"
import { toggleVariants } from "~/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

function ToggleGroup({
  className,
  variant,
  size,
  children,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <ToggleGroupPrimitive.Root
      data-slot="toggle-group"
      data-variant={variant}
      data-size={size}
      className={cn(
        "group/toggle-group flex w-fit items-center rounded-md data-[variant=outline]:shadow-xs",
        className
      )}
      {...props}
    >
      <ToggleGroupContext.Provider value={{ variant, size }}>
        {children}
      </ToggleGroupContext.Provider>
    </ToggleGroupPrimitive.Root>
  )
}

function ToggleGroupItem({
  className,
  children,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Item> &
  VariantProps<typeof toggleVariants>) {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      data-slot="toggle-group-item"
      data-variant={context.variant || variant}
      data-size={context.size || size}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        "min-w-0 flex-1 shrink-0 rounded-none shadow-none first:rounded-l-md last:rounded-r-md focus:z-10 focus-visible:z-10 data-[variant=outline]:border-l-0 data-[variant=outline]:first:border-l",
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
}

export { ToggleGroup, ToggleGroupItem }



================================================
FILE: app/components/ui/toggle.tsx
================================================
"use client"

import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "~/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-9 px-2 min-w-9",
        sm: "h-8 px-1.5 min-w-8",
        lg: "h-10 px-2.5 min-w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Toggle({
  className,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof TogglePrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <TogglePrimitive.Root
      data-slot="toggle"
      className={cn(toggleVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Toggle, toggleVariants }



================================================
FILE: app/components/ui/tooltip.tsx
================================================
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "~/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



================================================
FILE: app/hooks/use-mobile.ts
================================================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}



================================================
FILE: app/lib/audio-compression.ts
================================================
/**
 * Audio compression utilities to reduce file size before uploading
 */

interface CompressionOptions {
  targetBitrate?: number; // Target bitrate in kbps (e.g., 64, 96, 128)
  targetSampleRate?: number; // Target sample rate in Hz (e.g., 16000, 22050, 44100)
  mono?: boolean; // Convert to mono to reduce size
}

/**
 * Compress an audio file using the Web Audio API
 * This reduces file size while maintaining reasonable quality for transcription
 */
export async function compressAudioFile(
  file: File,
  options: CompressionOptions = {}
): Promise<Blob> {
  const {
    targetBitrate = 64, // 64 kbps is usually sufficient for speech
    targetSampleRate = 16000, // 16 kHz is standard for speech recognition
    mono = true, // Mono is sufficient for transcription
  } = options;

  try {
    // Create an audio context
    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    
    // Read the file as an array buffer
    const arrayBuffer = await file.arrayBuffer();
    
    // Decode the audio data
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
    
    // Create an offline context for processing
    const offlineContext = new OfflineAudioContext(
      mono ? 1 : audioBuffer.numberOfChannels,
      audioBuffer.duration * targetSampleRate,
      targetSampleRate
    );
    
    // Create a buffer source
    const source = offlineContext.createBufferSource();
    source.buffer = audioBuffer;
    
    // If converting to mono and source is stereo, mix channels
    if (mono && audioBuffer.numberOfChannels > 1) {
      const merger = offlineContext.createChannelMerger(1);
      source.connect(merger);
      merger.connect(offlineContext.destination);
    } else {
      source.connect(offlineContext.destination);
    }
    
    // Start processing
    source.start();
    const renderedBuffer = await offlineContext.startRendering();
    
    // Convert to WAV format with lower quality settings
    const wavBlob = await audioBufferToWav(renderedBuffer, targetBitrate);
    
    // Clean up
    audioContext.close();
    
    return wavBlob;
  } catch (error) {
    console.error("Audio compression failed:", error);
    throw error;
  }
}

/**
 * Convert an AudioBuffer to a WAV blob
 */
function audioBufferToWav(buffer: AudioBuffer, bitrate: number): Blob {
  const length = buffer.length * buffer.numberOfChannels * 2;
  const arrayBuffer = new ArrayBuffer(44 + length);
  const view = new DataView(arrayBuffer);
  
  // WAV header
  const writeString = (offset: number, string: string) => {
    for (let i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  };
  
  writeString(0, 'RIFF');
  view.setUint32(4, 36 + length, true);
  writeString(8, 'WAVE');
  writeString(12, 'fmt ');
  view.setUint32(16, 16, true); // PCM
  view.setUint16(20, 1, true); // PCM format
  view.setUint16(22, buffer.numberOfChannels, true);
  view.setUint32(24, buffer.sampleRate, true);
  view.setUint32(28, buffer.sampleRate * buffer.numberOfChannels * 2, true);
  view.setUint16(32, buffer.numberOfChannels * 2, true);
  view.setUint16(34, 16, true); // 16-bit
  writeString(36, 'data');
  view.setUint32(40, length, true);
  
  // Write audio data
  let offset = 44;
  for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
    const channelData = buffer.getChannelData(channel);
    for (let i = 0; i < channelData.length; i++) {
      const sample = Math.max(-1, Math.min(1, channelData[i]));
      view.setInt16(offset, sample * 0x7FFF, true);
      offset += 2;
    }
  }
  
  return new Blob([arrayBuffer], { type: 'audio/wav' });
}

/**
 * Check if a file exceeds the size limit
 */
export function isFileTooLarge(file: File, maxSizeMB: number = 20): boolean {
  const maxSizeBytes = maxSizeMB * 1024 * 1024;
  return file.size > maxSizeBytes;
}

/**
 * Get file size in MB
 */
export function getFileSizeMB(file: File): number {
  return file.size / (1024 * 1024);
}

/**
 * Estimate compressed file size based on duration and bitrate
 */
export function estimateCompressedSize(
  durationSeconds: number,
  bitrate: number = 64,
  channels: number = 1
): number {
  // Size in bytes = (bitrate in kbps * 1000 / 8) * duration * channels
  return (bitrate * 1000 / 8) * durationSeconds * channels;
} 


================================================
FILE: app/lib/ffmpeg-audio.ts
================================================
import { FFmpeg } from '@ffmpeg/ffmpeg';
import { fetchFile, toBlobURL } from '@ffmpeg/util';

let ffmpeg: FFmpeg | null = null;

export async function loadFFmpeg() {
  if (ffmpeg) return ffmpeg;

  ffmpeg = new FFmpeg();
  
  const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd';
  
  await ffmpeg.load({
    coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
    wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
  });
  
  return ffmpeg;
}

export async function extractAudioFromVideo(
  videoFile: File,
  onProgress?: (progress: number) => void
): Promise<File> {
  const ffmpeg = await loadFFmpeg();
  
  // Set up progress handling
  ffmpeg.on('progress', ({ progress }) => {
    onProgress?.(progress);
  });

  try {
    // Write video file to FFmpeg file system
    await ffmpeg.writeFile('input.mp4', await fetchFile(videoFile));
    
    // Extract audio as MP3 (smaller file size)
    // -vn: no video
    // -acodec mp3: use MP3 codec
    // -b:a 128k: audio bitrate 128kbps (good quality, smaller size)
    await ffmpeg.exec([
      '-i', 'input.mp4',
      '-vn',
      '-acodec', 'mp3',
      '-b:a', '128k',
      'output.mp3'
    ]);
    
    // Read the output file
    const data = await ffmpeg.readFile('output.mp3');
    
    // Convert to File object
    const audioBlob = new Blob([data], { type: 'audio/mp3' });
    const audioFile = new File([audioBlob], 'extracted_audio.mp3', { type: 'audio/mp3' });
    
    // Clean up
    await ffmpeg.deleteFile('input.mp4');
    await ffmpeg.deleteFile('output.mp3');
    
    return audioFile;
  } catch (error) {
    console.error('FFmpeg audio extraction error:', error);
    throw new Error('Failed to extract audio from video');
  }
}

export function estimateAudioSize(videoFile: File): number {
  // Estimate audio size at 128kbps
  // Rough estimate: 1MB per 1 minute of audio at 128kbps
  const videoDurationMinutes = videoFile.size / (5 * 1024 * 1024); // Assume 5MB/min for video
  return videoDurationMinutes * 1024 * 1024; // 1MB per minute for audio
}


================================================
FILE: app/lib/thumbnail-generator.ts
================================================
import OpenAI, { toFile } from "openai";

interface ThumbnailGeneratorOptions {
  images: File[];
  prompt: string;
  apiKey: string;
}

export async function generateThumbnailWithGPTImage({
  images,
  prompt,
  apiKey,
}: ThumbnailGeneratorOptions): Promise<{ imageUrl: string; base64?: string }> {
  const client = new OpenAI({ apiKey });

  // Convert File objects to OpenAI format
  const imageFiles = await Promise.all(
    images.map(async (file) => {
      const arrayBuffer = await file.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);
      return toFile(buffer, file.name, {
        type: file.type || "image/png",
      });
    })
  );

  // Use gpt-image-1 model for image editing
  const response = await client.images.edit({
    model: "gpt-image-1",
    image: imageFiles[0], // gpt-image-1 expects a single image
    prompt,
    size: "1024x1024",
    response_format: "b64_json",
  });

  const base64 = response.data[0].b64_json;
  if (!base64) {
    throw new Error("No image data returned from GPT Image API");
  }

  // Convert base64 to data URL
  const imageUrl = `data:image/png;base64,${base64}`;

  return { imageUrl, base64 };
}

// Helper function to convert multiple images into a composite prompt
export function createCompositePrompt(
  basePrompt: string,
  videoTitle?: string,
  channelStyle?: {
    channelName: string;
    niche: string;
    contentType: string;
    tone?: string;
  }
): string {
  let compositePrompt = basePrompt;

  if (videoTitle) {
    compositePrompt = `${compositePrompt}\n\nVideo Title: "${videoTitle}"`;
  }

  if (channelStyle) {
    compositePrompt = `${compositePrompt}\n\nChannel Style: ${channelStyle.channelName} (${channelStyle.niche})`;
    compositePrompt = `${compositePrompt}\nContent Type: ${channelStyle.contentType}`;
    if (channelStyle.tone) {
      compositePrompt = `${compositePrompt}\nTone: ${channelStyle.tone}`;
    }
  }

  // Add YouTube thumbnail requirements
  compositePrompt = `${compositePrompt}\n\nCreate a photorealistic YouTube thumbnail with:
- Bold, readable text overlay
- High contrast and vibrant colors
- Professional quality
- Eye-catching composition
- 16:9 aspect ratio optimized for YouTube`;

  return compositePrompt;
}


================================================
FILE: app/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



================================================
FILE: app/lib/video-error-handler.ts
================================================
import { toast } from "sonner";

export type VideoProcessingError = {
  type: 'upload' | 'transcription' | 'thumbnail' | 'metadata' | 'extraction' | 'format' | 'size' | 'network';
  message: string;
  details?: string;
  recoverable: boolean;
  action?: {
    label: string;
    handler: () => void;
  };
};

export class VideoError extends Error {
  type: VideoProcessingError['type'];
  details?: string;
  recoverable: boolean;
  action?: VideoProcessingError['action'];

  constructor(error: VideoProcessingError) {
    super(error.message);
    this.type = error.type;
    this.details = error.details;
    this.recoverable = error.recoverable;
    this.action = error.action;
    this.name = 'VideoError';
  }
}

export function getErrorDetails(error: any): VideoProcessingError {
  // Network errors
  if (error.message?.includes('fetch') || error.message?.includes('network') || error.message?.includes('Failed to fetch')) {
    return {
      type: 'network',
      message: 'Network connection error',
      details: 'Please check your internet connection and try again.',
      recoverable: true,
    };
  }

  // Upload errors
  if (error.message?.includes('upload') || error.message?.includes('Upload failed')) {
    return {
      type: 'upload',
      message: 'Failed to upload video',
      details: 'The video upload was interrupted. Please try again.',
      recoverable: true,
    };
  }

  // File size errors
  if (error.message?.includes('too large') || error.message?.includes('Maximum size')) {
    const sizeMatch = error.message.match(/(\d+\.?\d*)MB/);
    const size = sizeMatch ? sizeMatch[1] : 'unknown';
    return {
      type: 'size',
      message: 'Video file is too large',
      details: `Your video is ${size}MB. For files over 25MB, we'll extract the audio for transcription. Files over 100MB are not supported.`,
      recoverable: size && parseFloat(size) <= 100,
    };
  }

  // Format errors
  if (error.message?.includes('format') || error.message?.includes('codec') || error.message?.includes('not supported')) {
    return {
      type: 'format',
      message: 'Unsupported video format',
      details: 'Please upload a video in MP4, MOV, AVI, or WebM format.',
      recoverable: false,
    };
  }

  // Transcription errors
  if (error.message?.includes('transcrib') || error.message?.includes('whisper') || error.message?.includes('Transcription')) {
    return {
      type: 'transcription',
      message: 'Failed to transcribe video',
      details: error.message.includes('timeout') 
        ? 'The transcription took too long. Try with a shorter video.'
        : 'We couldn\'t transcribe the audio. The video might be silent or in an unsupported language.',
      recoverable: true,
    };
  }

  // Thumbnail errors
  if (error.message?.includes('thumbnail') || error.message?.includes('DALL-E') || error.message?.includes('safety system')) {
    return {
      type: 'thumbnail',
      message: 'Failed to generate thumbnail',
      details: error.message.includes('safety') 
        ? 'The AI safety system blocked thumbnail generation. Try uploading a custom thumbnail.'
        : 'We couldn\'t generate a thumbnail automatically.',
      recoverable: true,
    };
  }

  // Metadata errors
  if (error.message?.includes('metadata') || error.message?.includes('duration') || error.message?.includes('FFmpeg')) {
    return {
      type: 'metadata',
      message: 'Failed to extract video information',
      details: 'Some video details couldn\'t be extracted, but your video was uploaded successfully.',
      recoverable: true,
    };
  }

  // Audio extraction errors
  if (error.message?.includes('extract') || error.message?.includes('audio')) {
    return {
      type: 'extraction',
      message: 'Failed to extract audio',
      details: 'We couldn\'t extract audio from your video for transcription. The video might be corrupted or use an unsupported codec.',
      recoverable: false,
    };
  }

  // Authorization errors
  if (error.message?.includes('Unauthorized') || error.message?.includes('auth')) {
    return {
      type: 'upload',
      message: 'Authentication required',
      details: 'Please sign in to upload videos.',
      recoverable: false,
    };
  }

  // Generic error
  return {
    type: 'upload',
    message: 'Something went wrong',
    details: error.message || 'An unexpected error occurred. Please try again.',
    recoverable: true,
  };
}

export function handleVideoError(error: any, context: string = '') {
  console.error(`[Video Error${context ? ` - ${context}` : ''}]:`, error);
  
  const errorDetails = getErrorDetails(error);
  
  // Show appropriate toast based on error type
  if (errorDetails.recoverable) {
    toast.error(errorDetails.message, {
      description: errorDetails.details,
      duration: 6000,
    });
  } else {
    toast.error(errorDetails.message, {
      description: errorDetails.details,
      duration: 8000,
    });
  }
  
  return errorDetails;
}

// Helper to create retry action
export function createRetryAction(retryFn: () => void) {
  return {
    label: 'Retry',
    onClick: retryFn,
  };
}

// Helper to check if error is recoverable
export function isRecoverableError(error: any): boolean {
  const errorDetails = getErrorDetails(error);
  return errorDetails.recoverable;
}

// Helper to format error for display in UI
export function formatErrorForDisplay(error: any): string {
  const errorDetails = getErrorDetails(error);
  return errorDetails.details || errorDetails.message;
}


================================================
FILE: app/lib/video-frames.ts
================================================
import { FFmpeg } from '@ffmpeg/ffmpeg';
import { fetchFile, toBlobURL } from '@ffmpeg/util';

let ffmpeg: FFmpeg | null = null;

async function loadFFmpeg() {
  if (ffmpeg) return ffmpeg;

  ffmpeg = new FFmpeg();
  
  const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd';
  
  await ffmpeg.load({
    coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
    wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
  });
  
  return ffmpeg;
}

export interface ExtractedFrame {
  timestamp: number;
  blob: Blob;
  dataUrl: string;
}

export async function extractFramesFromVideo(
  videoFile: File,
  options: {
    count?: number;
    onProgress?: (progress: number) => void;
  } = {}
): Promise<ExtractedFrame[]> {
  const { count = 3, onProgress } = options;
  const ffmpeg = await loadFFmpeg();
  
  // Set up progress handling
  ffmpeg.on('progress', ({ progress }) => {
    onProgress?.(progress);
  });

  try {
    // Write video file to FFmpeg file system
    await ffmpeg.writeFile('input.mp4', await fetchFile(videoFile));
    
    // Get video duration first
    await ffmpeg.exec(['-i', 'input.mp4']);
    
    const frames: ExtractedFrame[] = [];
    
    // Extract frames at different timestamps
    // We'll extract frames at 25%, 50%, and 75% of the video duration
    const timestamps = Array.from({ length: count }, (_, i) => 
      (i + 1) / (count + 1)
    );
    
    for (let i = 0; i < count; i++) {
      const outputName = `frame_${i}.jpg`;
      
      // Extract frame at specific position
      // -ss: seek to position (as percentage)
      // -i: input file
      // -vframes 1: extract 1 frame
      // -q:v 2: quality (2 is high quality)
      await ffmpeg.exec([
        '-ss', `${timestamps[i] * 100}%`,
        '-i', 'input.mp4',
        '-vframes', '1',
        '-q:v', '2',
        outputName
      ]);
      
      // Read the frame
      const frameData = await ffmpeg.readFile(outputName);
      const blob = new Blob([frameData], { type: 'image/jpeg' });
      const dataUrl = await blobToDataURL(blob);
      
      frames.push({
        timestamp: timestamps[i],
        blob,
        dataUrl
      });
      
      // Clean up
      await ffmpeg.deleteFile(outputName);
    }
    
    // Clean up input file
    await ffmpeg.deleteFile('input.mp4');
    
    return frames;
  } catch (error) {
    console.error('FFmpeg frame extraction error:', error);
    throw new Error('Failed to extract frames from video');
  }
}

async function blobToDataURL(blob: Blob): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result as string);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

export async function getVideoThumbnail(videoFile: File): Promise<string> {
  // Extract a single frame at 25% of the video for a quick thumbnail
  const frames = await extractFramesFromVideo(videoFile, { count: 1 });
  return frames[0]?.dataUrl || '';
}


================================================
FILE: app/lib/video-metadata.ts
================================================
import { FFmpeg } from '@ffmpeg/ffmpeg';
import { fetchFile, toBlobURL } from '@ffmpeg/util';

let ffmpeg: FFmpeg | null = null;

async function loadFFmpeg() {
  if (ffmpeg) return ffmpeg;

  ffmpeg = new FFmpeg();
  
  const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd';
  
  console.log('[FFmpeg] Loading FFmpeg...');
  try {
    await ffmpeg.load({
      coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
      wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
    });
    console.log('[FFmpeg] FFmpeg loaded successfully');
  } catch (error) {
    console.error('[FFmpeg] Failed to load FFmpeg:', error);
    throw error;
  }
  
  return ffmpeg;
}

export interface VideoMetadata {
  duration: number; // seconds
  fileSize: number; // bytes
  resolution: {
    width: number;
    height: number;
  };
  frameRate: number;
  bitRate: number;
  format: string;
  codec: string;
  audioInfo?: {
    codec: string;
    sampleRate: number;
    channels: number;
    bitRate: number;
  };
  thumbnails: string[]; // Data URLs of extracted frames
}

// Simple metadata extraction using HTML5 video element
export async function extractBasicVideoMetadata(videoFile: File): Promise<Partial<VideoMetadata>> {
  return new Promise((resolve) => {
    console.log('[BasicMetadata] Starting basic metadata extraction for:', videoFile.name);
    const video = document.createElement('video');
    const url = URL.createObjectURL(videoFile);
    
    video.onloadedmetadata = () => {
      const metadata: Partial<VideoMetadata> = {
        duration: video.duration,
        fileSize: videoFile.size,
        resolution: {
          width: video.videoWidth,
          height: video.videoHeight,
        },
      };
      
      console.log('[BasicMetadata] Successfully extracted:', metadata);
      
      // Clean up
      URL.revokeObjectURL(url);
      video.remove();
      
      resolve(metadata);
    };
    
    video.onerror = (error) => {
      console.error('[BasicMetadata] Video element error:', error);
      URL.revokeObjectURL(url);
      video.remove();
      resolve({
        fileSize: videoFile.size,
      });
    };
    
    video.src = url;
    video.load();
  });
}

export async function extractVideoMetadata(
  videoFile: File,
  options: {
    onProgress?: (progress: number) => void;
    extractThumbnails?: boolean;
    useFFmpeg?: boolean;
  } = {}
): Promise<VideoMetadata> {
  const { onProgress, extractThumbnails = true, useFFmpeg = true } = options;
  
  try {
    // First try to get basic metadata quickly
    const basicMetadata = await extractBasicVideoMetadata(videoFile);
    onProgress?.(0.2);
    
    // If FFmpeg is disabled or fails, return basic metadata
    if (!useFFmpeg) {
      return {
        duration: basicMetadata.duration || 0,
        fileSize: basicMetadata.fileSize || videoFile.size,
        resolution: basicMetadata.resolution || { width: 0, height: 0 },
        frameRate: 0,
        bitRate: 0,
        format: videoFile.type.split('/')[1] || 'unknown',
        codec: 'unknown',
        audioInfo: undefined,
        thumbnails: []
      };
    }
    
    // Then try FFmpeg for more detailed metadata
    const ffmpeg = await loadFFmpeg();
    
    // Set up progress handling
    ffmpeg.on('progress', ({ progress }) => {
      onProgress?.(progress * 0.5 + 0.2); // 20% base + 50% for metadata
    });
    // Write video file to FFmpeg file system
    await ffmpeg.writeFile('input.mp4', await fetchFile(videoFile));
    
    // Get detailed video information using ffprobe-like command
    // FFmpeg.wasm doesn't have ffprobe, so we use ffmpeg with null output
    const output: string[] = [];
    ffmpeg.on('log', ({ message }) => {
      output.push(message);
    });
    
    // Run ffmpeg to get video info
    await ffmpeg.exec([
      '-i', 'input.mp4',
      '-f', 'null',
      '-'
    ]);
    
    // Parse the output to extract metadata
    const metadata = parseFFmpegOutput(output.join('\n'));
    metadata.fileSize = videoFile.size;
    metadata.format = videoFile.type.split('/')[1] || 'unknown';
    
    // Extract thumbnails if requested
    if (extractThumbnails) {
      onProgress?.(0.5);
      const thumbnails: string[] = [];
      const frameCount = 5; // Extract 5 frames
      
      for (let i = 0; i < frameCount; i++) {
        const timestamp = (i + 1) / (frameCount + 1) * metadata.duration;
        const outputName = `thumb_${i}.jpg`;
        
        await ffmpeg.exec([
          '-ss', timestamp.toString(),
          '-i', 'input.mp4',
          '-vframes', '1',
          '-vf', 'scale=320:-1',
          '-q:v', '2',
          outputName
        ]);
        
        const frameData = await ffmpeg.readFile(outputName);
        const blob = new Blob([frameData], { type: 'image/jpeg' });
        const dataUrl = await blobToDataURL(blob);
        thumbnails.push(dataUrl);
        
        await ffmpeg.deleteFile(outputName);
        onProgress?.(0.5 + (0.5 * (i + 1) / frameCount));
      }
      
      metadata.thumbnails = thumbnails;
    }
    
    // Clean up
    await ffmpeg.deleteFile('input.mp4');
    
    // Ensure all required fields are set, merge with basic metadata
    return {
      duration: metadata.duration || basicMetadata.duration || 0,
      fileSize: metadata.fileSize || basicMetadata.fileSize || videoFile.size,
      resolution: metadata.resolution || basicMetadata.resolution || { width: 0, height: 0 },
      frameRate: metadata.frameRate || 0,
      bitRate: metadata.bitRate || 0,
      format: metadata.format || videoFile.type.split('/')[1] || 'unknown',
      codec: metadata.codec || 'unknown',
      audioInfo: metadata.audioInfo,
      thumbnails: metadata.thumbnails || []
    };
  } catch (error) {
    console.error('FFmpeg metadata extraction error:', error);
    // Try to get basic metadata as fallback
    const basicMetadata = await extractBasicVideoMetadata(videoFile);
    
    // Return basic metadata on error
    return {
      duration: basicMetadata.duration || 0,
      fileSize: basicMetadata.fileSize || videoFile.size,
      resolution: basicMetadata.resolution || { width: 0, height: 0 },
      frameRate: 0,
      bitRate: 0,
      format: videoFile.type.split('/')[1] || 'unknown',
      codec: 'unknown',
      thumbnails: []
    };
  }
}

function parseFFmpegOutput(output: string): Partial<VideoMetadata> {
  const metadata: Partial<VideoMetadata> = {};
  
  // Extract duration
  const durationMatch = output.match(/Duration: (\d{2}):(\d{2}):(\d{2}\.\d+)/);
  if (durationMatch) {
    const hours = parseInt(durationMatch[1]);
    const minutes = parseInt(durationMatch[2]);
    const seconds = parseFloat(durationMatch[3]);
    metadata.duration = hours * 3600 + minutes * 60 + seconds;
  }
  
  // Extract video stream info
  const videoStreamMatch = output.match(/Stream.*Video: (\w+).*?(\d+)x(\d+).*?(\d+(?:\.\d+)?)\s*fps.*?(\d+)\s*kb\/s/);
  if (videoStreamMatch) {
    metadata.codec = videoStreamMatch[1];
    metadata.resolution = {
      width: parseInt(videoStreamMatch[2]),
      height: parseInt(videoStreamMatch[3])
    };
    metadata.frameRate = parseFloat(videoStreamMatch[4]);
    metadata.bitRate = parseInt(videoStreamMatch[5]) * 1000; // Convert to bits/s
  }
  
  // Extract audio stream info
  const audioStreamMatch = output.match(/Stream.*Audio: (\w+).*?(\d+)\s*Hz.*?(\w+).*?(\d+)\s*kb\/s/);
  if (audioStreamMatch) {
    metadata.audioInfo = {
      codec: audioStreamMatch[1],
      sampleRate: parseInt(audioStreamMatch[2]),
      channels: audioStreamMatch[3] === 'stereo' ? 2 : 1,
      bitRate: parseInt(audioStreamMatch[4]) * 1000
    };
  }
  
  return metadata;
}

async function blobToDataURL(blob: Blob): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result as string);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

export function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  
  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
  return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

export function formatFileSize(bytes: number): string {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  return (bytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
}

export function formatBitRate(bitsPerSecond: number): string {
  if (bitsPerSecond < 1000) return bitsPerSecond + ' bps';
  if (bitsPerSecond < 1000000) return (bitsPerSecond / 1000).toFixed(0) + ' kbps';
  return (bitsPerSecond / 1000000).toFixed(1) + ' Mbps';
}


================================================
FILE: app/routes/$.tsx
================================================
import type { Route } from "./+types/$";

// Catch-all route for unmatched paths
export async function loader({ request }: Route.LoaderArgs) {
  const url = new URL(request.url);
  
  // Handle Chrome DevTools JSON file request
  if (url.pathname === "/.well-known/appspecific/com.chrome.devtools.json") {
    return new Response("{}", {
      status: 200,
      headers: {
        "Content-Type": "application/json",
      },
    });
  }
  
  // For other unmatched routes, throw 404
  throw new Response("Not Found", { status: 404 });
}

export default function CatchAll() {
  // This component won't be rendered for the loader responses above
  return null;
}


================================================
FILE: app/routes/home.tsx
================================================
import { getAuth } from "@clerk/react-router/ssr.server";
import Footer from "~/components/homepage/footer";
import HeroSection from "~/components/homepage/hero";
import type { Route } from "./+types/home";

export function meta({ }: Route.MetaArgs) {
  const title = "YouTube AI Assistant - Streamline Your Video Content Creation";
  const description =
    "AI-powered assistant for YouTube creators. Generate optimized titles, descriptions, thumbnails, and social media posts for your videos using advanced AI technology.";
  const keywords = "YouTube, AI Assistant, Content Creation, Video Optimization, AI Thumbnails, OpenAI, GPT-4, Video Transcription, Content Generator";
  const siteUrl = "https://youtube-ai-assistant.com/";
  const imageUrl =
    "https://jdj14ctwppwprnqu.public.blob.vercel-storage.com/youtube-ai-assistant-og.png";

  return [
    { title },
    {
      name: "description",
      content: description,
    },

    // Open Graph / Facebook
    { property: "og:type", content: "website" },
    { property: "og:title", content: title },
    { property: "og:description", content: description },
    { property: "og:image", content: imageUrl },
    { property: "og:image:width", content: "1200" },
    { property: "og:image:height", content: "630" },
    { property: "og:url", content: siteUrl },
    { property: "og:site_name", content: "YouTube AI Assistant" },
    { property: "og:image", content: imageUrl },

    // Twitter Card
    { name: "twitter:card", content: "summary_large_image" },
    { name: "twitter:title", content: title },
    {
      name: "twitter:description",
      content: description,
    },
    { name: "twitter:image", content: imageUrl },
    {
      name: "keywords",
      content: keywords,
    },
    { name: "author", content: "YouTube AI Team" },
    { name: "favicon", content: "/youtube-ai-logo.png" },
  ];
}

export async function loader(args: Route.LoaderArgs) {
  const { userId } = await getAuth(args);



  return {
    isSignedIn: !!userId,
  };
}

export default function Home({ loaderData }: Route.ComponentProps) {
  return (
    <>
      <HeroSection loaderData={loaderData} />
      <Footer />
    </>
  );
}



================================================
FILE: app/routes/share.$shareId.tsx
================================================
import { api } from "convex/_generated/api";
import { ConvexHttpClient } from "convex/browser";
import { useMutation } from "convex/react";
import { useEffect } from "react";
import type { LoaderFunctionArgs } from "react-router";
import { useLoaderData } from "react-router";
import { SharedCanvas } from "~/components/canvas/SharedCanvas";

export async function loader({ params }: LoaderFunctionArgs) {
  const shareId = params.shareId;
  
  console.log("Loading share page with ID:", shareId);
  
  if (!shareId) {
    throw new Response("Share ID not found", { status: 404 });
  }

  // Hardcode the Convex URL for now
  const convexUrl = "https://charming-bird-938.convex.cloud";
  
  const convex = new ConvexHttpClient(convexUrl);
  
  try {
    const sharedData = await convex.query(api.shares.getSharedCanvas, { shareId });
    
    if (!sharedData) {
      throw new Response("Shared canvas not found", { status: 404 });
    }
    
    return { sharedData, shareId };
  } catch (error) {
    console.error("Error loading shared canvas:", error);
    throw new Response("Failed to load shared canvas", { status: 500 });
  }
}

export default function SharedCanvasPage() {
  const { sharedData, shareId } = useLoaderData<typeof loader>();
  const incrementViewCount = useMutation(api.shares.incrementViewCount);
  
  // Increment view count on mount
  useEffect(() => {
    if (shareId) {
      incrementViewCount({ shareId }).catch(console.error);
    }
  }, [shareId, incrementViewCount]);
  
  if (!sharedData) {
    return (
      <div className="h-screen bg-background flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-2xl font-semibold mb-2">Share not found</h1>
          <p className="text-muted-foreground">This shared canvas could not be found.</p>
        </div>
      </div>
    );
  }
  
  return (
    <div className="h-screen bg-background">
      <SharedCanvas data={sharedData} />
    </div>
  );
}


================================================
FILE: app/routes/sign-in.tsx
================================================
import { SignIn } from "@clerk/react-router";

export default function SignInPage() {
  return (
    <div className="flex items-center justify-center h-screen">
      <SignIn 
        routing="path"
        path="/sign-in"
        signUpUrl="/sign-up"
        afterSignInUrl="/dashboard"
        afterSignUpUrl="/dashboard"
      />
    </div>
  );
}



================================================
FILE: app/routes/sign-up.tsx
================================================
import { SignUp } from "@clerk/react-router";

export default function SignUpPage() {
  return (
    <div className="flex items-center justify-center h-screen">
      <SignUp 
        routing="path"
        path="/sign-up"
        signInUrl="/sign-in"
        afterSignInUrl="/dashboard"
        afterSignUpUrl="/dashboard"
      />
    </div>
  );
}



================================================
FILE: app/routes/dashboard/chat.tsx
================================================
"use client";

import { useChat } from "@ai-sdk/react";
import Markdown from "react-markdown";
import { Button } from "~/components/ui/button";
import { Input } from "~/components/ui/input";
import { cn } from "~/lib/utils";

const CONVEX_SITE_URL = import.meta.env.VITE_CONVEX_URL!.replace(
  /.cloud$/,
  ".site"
);

export default function Chat() {
  const { messages, input, handleInputChange, handleSubmit, isLoading } =
    useChat({
      maxSteps: 10,
      api: `${CONVEX_SITE_URL}/api/chat`,
    });

  return (
    <div className="flex flex-col w-full py-24 justify-center items-center">
      <div className="w-full max-w-xl space-y-4 mb-20">
        {messages.map((message, i) => (
          <div
            key={message.id}
            className={cn(
              "flex",
              message.role === "user" ? "justify-end" : "justify-start"
            )}
          >
            <div
              className={cn(
                "max-w-[65%] px-3 py-1.5 text-sm shadow-sm",
                message.role === "user"
                  ? "bg-[#0B93F6] text-white rounded-2xl rounded-br-sm"
                  : "bg-[#E9E9EB] text-black rounded-2xl rounded-bl-sm"
              )}
            >
              {message.parts.map((part) => {
                switch (part.type) {
                  case "text":
                    return (
                      <div
                        key={`${message.id}-${i}`}
                        className="prose-sm prose-p:my-0.5 prose-li:my-0.5 prose-ul:my-1 prose-ol:my-1"
                      >
                        <Markdown>{part.text}</Markdown>
                      </div>
                    );
                  default:
                    return null;
                }
              })}
            </div>
          </div>
        ))}
      </div>

      <form
        className="flex gap-2 justify-center w-full items-center fixed bottom-0"
        onSubmit={handleSubmit}
      >
        <div className="flex flex-col gap-2 justify-center items-start mb-8 max-w-xl w-full border p-2 rounded-lg bg-white ">
          <Input
            className="w-full border-0 shadow-none !ring-transparent "
            value={input}
            placeholder="Say something..."
            onChange={handleInputChange}
          />
          <div className="flex justify-end gap-3 items-center w-full">
            <Button size="sm" className="text-xs">
              Send
            </Button>
          </div>
        </div>
      </form>
    </div>
  );
}



================================================
FILE: app/routes/dashboard/index.tsx
================================================
import { Link } from "react-router";
import { useQuery, useMutation } from "convex/react";
import { api } from "convex/_generated/api";
import type { Id } from "convex/_generated/dataModel";
import { useState, useEffect } from "react";
import { Plus, Video, Calendar, Archive, MoreVertical, Settings, User, ArrowRight, Sparkles } from "lucide-react";
import { Button } from "~/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "~/components/ui/dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "~/components/ui/dropdown-menu";
import { Input } from "~/components/ui/input";
import { Label } from "~/components/ui/label";
import { Textarea } from "~/components/ui/textarea";
import { toast } from "sonner";
import { formatDistanceToNow } from "date-fns";

export default function Page() {
  const projects = useQuery(api.projects.list, { includeArchived: false });
  const profile = useQuery(api.profiles.get);
  const createProject = useMutation(api.projects.create);
  const archiveProject = useMutation(api.projects.update);
  const deleteProject = useMutation(api.projects.remove);
  
  const [isCreateOpen, setIsCreateOpen] = useState(false);
  const [showProfileDialog, setShowProfileDialog] = useState(false);
  const [newProject, setNewProject] = useState({
    title: "",
    description: "",
  });

  // Check if profile is incomplete on first visit
  useEffect(() => {
    if (profile !== undefined) {
      const isIncomplete = !profile || !profile.channelName || !profile.contentType || !profile.niche;
      if (isIncomplete && !localStorage.getItem('profileDialogDismissed')) {
        setShowProfileDialog(true);
      }
    }
  }, [profile]);

  const handleDismissProfileDialog = () => {
    setShowProfileDialog(false);
    localStorage.setItem('profileDialogDismissed', 'true');
  };

  const handleCreateProject = async () => {
    if (!newProject.title.trim()) {
      toast.error("Project title is required");
      return;
    }

    try {
      const projectId = await createProject({
        title: newProject.title,
        description: newProject.description || undefined,
      });
      
      toast.success("Project created successfully!");
      setIsCreateOpen(false);
      setNewProject({ title: "", description: "" });
      
      // Navigate to the new project canvas
      window.location.href = `/dashboard/project/${projectId}`;
    } catch (error) {
      toast.error("Failed to create project");
    }
  };

  const handleArchive = async (projectId: string) => {
    try {
      await archiveProject({
        id: projectId as Id<"projects">,
        isArchived: true,
      });
      toast.success("Project archived");
    } catch (error) {
      toast.error("Failed to archive project");
    }
  };

  const handleDelete = async (projectId: string) => {
    if (!confirm("Are you sure you want to delete this project? This action cannot be undone.")) {
      return;
    }

    try {
      await deleteProject({ id: projectId as Id<"projects"> });
      toast.success("Project deleted");
    } catch (error) {
      toast.error("Failed to delete project");
    }
  };

  return (
    <div className="space-y-6 p-6">
      {/* Profile Completion Dialog */}
      <Dialog open={showProfileDialog} onOpenChange={setShowProfileDialog}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <div className="flex items-center gap-3 mb-2">
              <div className="p-2.5 rounded-xl bg-gradient-to-br from-primary/20 to-primary/10">
                <User className="h-5 w-5 text-primary" />
              </div>
              <DialogTitle className="text-xl">Complete Your Profile</DialogTitle>
            </div>
            <DialogDescription className="text-base">
              Set up your YouTube channel profile to get personalized AI-generated content that matches your style and audience.
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4 py-4">
            <div className="rounded-lg border bg-muted/50 p-4">
              <h4 className="font-medium mb-2 flex items-center gap-2">
                <Sparkles className="h-4 w-4 text-primary" />
                Why complete your profile?
              </h4>
              <ul className="space-y-2 text-sm text-muted-foreground">
                <li className="flex items-start gap-2">
                  <span className="text-primary mt-0.5">‚Ä¢</span>
                  <span>AI generates content tailored to your channel's niche</span>
                </li>
                <li className="flex items-start gap-2">
                  <span className="text-primary mt-0.5">‚Ä¢</span>
                  <span>Matches your unique tone and communication style</span>
                </li>
                <li className="flex items-start gap-2">
                  <span className="text-primary mt-0.5">‚Ä¢</span>
                  <span>Targets your specific audience demographics</span>
                </li>
              </ul>
            </div>
          </div>
          
          <DialogFooter className="flex-col sm:flex-row gap-2">
            <Button
              variant="outline"
              onClick={handleDismissProfileDialog}
              className="sm:flex-1"
            >
              Skip for now
            </Button>
            <Button asChild className="sm:flex-1 gap-2">
              <Link to="/dashboard/settings">
                <Settings className="h-4 w-4" />
                Go to Settings
                <ArrowRight className="h-4 w-4" />
              </Link>
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold">Projects</h1>
          <p className="text-muted-foreground">
            Create and manage your YouTube video projects
          </p>
        </div>
        
        <div className="flex items-center gap-3">
          {profile && (!profile.channelName || !profile.contentType || !profile.niche) && (
            <Button variant="outline" size="sm" asChild className="gap-2">
              <Link to="/dashboard/settings">
                <User className="h-4 w-4" />
                Complete Profile
              </Link>
            </Button>
          )}
          
          <Dialog open={isCreateOpen} onOpenChange={setIsCreateOpen}>
            <DialogTrigger asChild>
              <Button>
                <Plus className="mr-2 h-4 w-4" />
                New Project
              </Button>
            </DialogTrigger>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Create New Project</DialogTitle>
              <DialogDescription>
                Each project is a canvas for creating content for one video
              </DialogDescription>
            </DialogHeader>
            <div className="grid gap-4 py-4">
              <div className="grid gap-2">
                <Label htmlFor="title">Project Title</Label>
                <Input
                  id="title"
                  placeholder="My Awesome Video"
                  value={newProject.title}
                  onChange={(e) =>
                    setNewProject({ ...newProject, title: e.target.value })
                  }
                />
              </div>
              <div className="grid gap-2">
                <Label htmlFor="description">Description (optional)</Label>
                <Textarea
                  id="description"
                  placeholder="Brief description of your video project..."
                  value={newProject.description}
                  onChange={(e) =>
                    setNewProject({ ...newProject, description: e.target.value })
                  }
                />
              </div>
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setIsCreateOpen(false)}>
                Cancel
              </Button>
              <Button onClick={handleCreateProject}>Create Project</Button>
            </DialogFooter>
          </DialogContent>
          </Dialog>
        </div>
      </div>

      {projects === undefined ? (
        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
          {[1, 2, 3].map((i) => (
            <Card key={i} className="animate-pulse">
              <CardHeader className="space-y-2">
                <div className="h-4 w-3/4 bg-muted rounded" />
                <div className="h-3 w-1/2 bg-muted rounded" />
              </CardHeader>
              <CardContent>
                <div className="h-32 bg-muted rounded" />
              </CardContent>
            </Card>
          ))}
        </div>
      ) : projects.length === 0 ? (
        <Card className="border-dashed">
          <CardContent className="flex flex-col items-center justify-center py-12">
            <Video className="h-12 w-12 text-muted-foreground mb-4" />
            <h3 className="text-lg font-semibold mb-2">No projects yet</h3>
            <p className="text-muted-foreground text-center mb-4">
              Create your first project to start generating YouTube content
            </p>
            <Button onClick={() => setIsCreateOpen(true)}>
              <Plus className="mr-2 h-4 w-4" />
              Create First Project
            </Button>
          </CardContent>
        </Card>
      ) : (
        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
          {projects.map((project) => (
            <Card key={project._id} className="group relative overflow-hidden">
              <Link to={`/dashboard/project/${project._id}`}>
                <CardHeader>
                  <div className="flex items-start justify-between">
                    <div className="space-y-1">
                      <CardTitle className="line-clamp-1">
                        {project.title}
                      </CardTitle>
                      <CardDescription className="line-clamp-2">
                        {project.description || "No description"}
                      </CardDescription>
                    </div>
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild onClick={(e) => e.preventDefault()}>
                        <Button
                          variant="ghost"
                          size="icon"
                          className="opacity-0 group-hover:opacity-100 transition-opacity"
                        >
                          <MoreVertical className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem
                          onClick={(e) => {
                            e.preventDefault();
                            handleArchive(project._id);
                          }}
                        >
                          <Archive className="mr-2 h-4 w-4" />
                          Archive
                        </DropdownMenuItem>
                        <DropdownMenuItem
                          className="text-destructive"
                          onClick={(e) => {
                            e.preventDefault();
                            handleDelete(project._id);
                          }}
                        >
                          Delete
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </div>
                </CardHeader>
                <CardFooter>
                  <div className="flex items-center text-sm text-muted-foreground">
                    <Calendar className="mr-1 h-3 w-3" />
                    {formatDistanceToNow(new Date(project.updatedAt), {
                      addSuffix: true,
                    })}
                  </div>
                </CardFooter>
              </Link>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}



================================================
FILE: app/routes/dashboard/layout.tsx
================================================
import { getAuth } from "@clerk/react-router/ssr.server";
import { Outlet, redirect, useLoaderData } from "react-router";
import { AppSidebar } from "~/components/dashboard/app-sidebar";
import { SiteHeader } from "~/components/dashboard/site-header";
import { SidebarInset, SidebarProvider } from "~/components/ui/sidebar";
import { useState, useEffect } from "react";
import type { Route } from "./+types/layout";

export async function loader(args: Route.LoaderArgs) {
  const { userId } = await getAuth(args);

  // Redirect to sign-in if not authenticated
  if (!userId) {
    throw redirect("/sign-in");
  }

  return { userId };
}

export default function DashboardLayout() {
  const { user } = useLoaderData();
  const [sidebarOpen, setSidebarOpen] = useState(false);

  // Load saved state after mount to avoid hydration mismatch
  useEffect(() => {
    const saved = localStorage.getItem("sidebar-open");
    if (saved !== null) {
      setSidebarOpen(saved === "true");
    }
  }, []);

  // Save to localStorage whenever state changes
  useEffect(() => {
    localStorage.setItem("sidebar-open", String(sidebarOpen));
  }, [sidebarOpen]);

  return (
    <SidebarProvider
      defaultOpen={false}
      open={sidebarOpen}
      onOpenChange={setSidebarOpen}
      style={
        {
          "--sidebar-width": "calc(var(--spacing) * 72)",
          "--header-height": "calc(var(--spacing) * 12)",
        } as React.CSSProperties
      }
    >
      <AppSidebar variant="inset" user={user} />
      <SidebarInset>
        <SiteHeader />
        <Outlet />
      </SidebarInset>
    </SidebarProvider>
  );
}



================================================
FILE: app/routes/dashboard/project.$projectId.tsx
================================================
import { useParams } from "react-router";
import { useQuery } from "convex/react";
import { api } from "convex/_generated/api";
import type { Id } from "convex/_generated/dataModel";
import { ClientOnly } from "~/components/ClientOnly";
import ClientCanvas from "~/components/canvas/ClientCanvas";

export default function ProjectCanvas() {
  const { projectId } = useParams();
  const project = useQuery(api.projects.get, { 
    id: projectId as Id<"projects"> 
  });

  if (!project && project !== undefined) {
    return (
      <div className="flex h-[calc(100vh-var(--header-height))] items-center justify-center">
        <p className="text-muted-foreground">Project not found</p>
      </div>
    );
  }

  return (
    <ClientOnly
      fallback={
        <div className="flex h-[calc(100vh-var(--header-height))] items-center justify-center">
          <p className="text-muted-foreground">Loading canvas...</p>
        </div>
      }
    >
      <ClientCanvas projectId={projectId as Id<"projects">} />
    </ClientOnly>
  );
}


================================================
FILE: app/routes/dashboard/settings.tsx
================================================
import { useState, useEffect } from "react";
import { useQuery, useMutation } from "convex/react";
import { api } from "convex/_generated/api";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import * as z from "zod";
import { toast } from "sonner";
import { 
  Loader2, Plus, X, User, Globe, Target, Palette, 
  Youtube, Link2, Sparkles, Save, Eye, Hash,
  MessageSquare, Users, TrendingUp, Video
} from "lucide-react";
import { Button } from "~/components/ui/button";
import { Progress } from "~/components/ui/progress";
import { cn } from "~/lib/utils";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "~/components/ui/card";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "~/components/ui/form";
import { Input } from "~/components/ui/input";
import { Textarea } from "~/components/ui/textarea";
import { Badge } from "~/components/ui/badge";
import { Separator } from "~/components/ui/separator";

const profileSchema = z.object({
  channelName: z.string().min(1, "Channel name is required"),
  contentType: z.string().min(1, "Content type is required"),
  niche: z.string().min(1, "Niche is required"),
  links: z.array(z.string()).default([]),
  tone: z.string().optional(),
  targetAudience: z.string().optional(),
});

type ProfileFormValues = z.infer<typeof profileSchema>;

export default function Page() {
  const profile = useQuery(api.profiles.get);
  const upsertProfile = useMutation(api.profiles.upsert);
  const [links, setLinks] = useState<string[]>([]);
  const [newLink, setNewLink] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  const form = useForm<ProfileFormValues>({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      channelName: "",
      contentType: "",
      niche: "",
      links: [],
      tone: "",
      targetAudience: "",
    },
  });

  // Load existing profile data
  useEffect(() => {
    if (profile) {
      form.reset({
        channelName: profile.channelName,
        contentType: profile.contentType,
        niche: profile.niche,
        links: profile.links,
        tone: profile.tone || "",
        targetAudience: profile.targetAudience || "",
      });
      setLinks(profile.links);
    }
  }, [profile, form]);

  const onSubmit = async (values: ProfileFormValues) => {
    setIsSubmitting(true);
    try {
      await upsertProfile({
        ...values,
        links,
      });
      toast.success("Profile saved successfully!");
    } catch (error) {
      toast.error("Failed to save profile");
    } finally {
      setIsSubmitting(false);
    }
  };

  const addLink = () => {
    if (!newLink) return;
    
    try {
      new URL(newLink);
      setLinks([...links, newLink]);
      setNewLink("");
    } catch {
      toast.error("Please enter a valid URL");
    }
  };

  const removeLink = (index: number) => {
    setLinks(links.filter((_, i) => i !== index));
  };

  // Calculate profile completion
  const calculateCompletion = () => {
    if (!profile) return 0;
    let score = 0;
    const fields = [
      profile.channelName,
      profile.contentType,
      profile.niche,
      profile.tone,
      profile.targetAudience,
      profile.links.length > 0
    ];
    fields.forEach(field => {
      if (field) score += 100 / fields.length;
    });
    return Math.round(score);
  };

  const completionPercentage = calculateCompletion();

  return (
    <div className="min-h-screen bg-gradient-to-br from-background via-background to-muted/20">
      {/* Decorative background */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute top-20 right-20 w-96 h-96 bg-gradient-to-br from-primary/10 via-primary/5 to-transparent rounded-full blur-3xl" />
        <div className="absolute bottom-20 left-20 w-96 h-96 bg-gradient-to-tr from-primary/10 via-primary/5 to-transparent rounded-full blur-3xl" />
      </div>
      
      <div className="relative space-y-8 p-6 max-w-7xl mx-auto">
        {/* Header */}
        <div className="space-y-4">
          <div className="flex items-center gap-3">
            <div className="p-3 rounded-xl bg-gradient-to-br from-primary/20 to-primary/10">
              <Youtube className="h-6 w-6 text-primary" />
            </div>
            <div>
              <h1 className="text-3xl font-bold">Channel Settings</h1>
              <p className="text-muted-foreground">
                Configure your YouTube channel profile for personalized AI content
              </p>
            </div>
          </div>
          
          {/* Profile Completion */}
          <Card className="border-primary/20">
            <CardContent className="p-6">
              <div className="flex items-center justify-between mb-2">
                <span className="text-sm font-medium">Profile Completion</span>
                <span className="text-sm font-bold text-primary">{completionPercentage}%</span>
              </div>
              <Progress value={completionPercentage} className="h-2" />
              {completionPercentage < 100 && (
                <p className="text-xs text-muted-foreground mt-2">
                  Complete your profile for better AI-generated content
                </p>
              )}
            </CardContent>
          </Card>
        </div>

        <div className="grid gap-6 lg:grid-cols-3">
          {/* Main Form - 2 columns */}
          <div className="lg:col-span-2 space-y-6">
            {/* Basic Information */}
            <Card className="p-0 rounded">
              <div className="bg-gradient-to-r from-primary/10 to-primary/5 p-6 border-b">
                <CardHeader className="p-0">
                  <div className="flex items-center gap-3">
                    <div className="p-2 rounded-lg bg-background/80 backdrop-blur">
                      <User className="h-5 w-5 text-primary" />
                    </div>
                    <div>
                      <CardTitle>Basic Information</CardTitle>
                      <CardDescription>
                        Tell us about your YouTube channel
                      </CardDescription>
                    </div>
                  </div>
                </CardHeader>
              </div>
              <CardContent className="p-6">
                <Form {...form}>
                  <form onSubmit={form.handleSubmit(onSubmit as any)} className="space-y-6">
                    <div className="grid gap-6 sm:grid-cols-2">
                      <FormField
                        control={form.control}
                        name="channelName"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel className="flex items-center gap-2">
                              <Youtube className="h-4 w-4" />
                              Channel Name
                            </FormLabel>
                            <FormControl>
                              <Input placeholder="Tech Tutorials Pro" {...field} />
                            </FormControl>
                            <FormDescription>
                              Your YouTube channel name
                            </FormDescription>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={form.control}
                        name="contentType"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel className="flex items-center gap-2">
                              <Video className="h-4 w-4" />
                              Content Type
                            </FormLabel>
                            <FormControl>
                              <Input placeholder="Educational Technology" {...field} />
                            </FormControl>
                            <FormDescription>
                              Type of content (tutorials, reviews, vlogs)
                            </FormDescription>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                    </div>

                    <FormField
                      control={form.control}
                      name="niche"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="flex items-center gap-2">
                            <Hash className="h-4 w-4" />
                            Niche
                          </FormLabel>
                          <FormControl>
                            <Input placeholder="Web Development" {...field} />
                          </FormControl>
                          <FormDescription>
                            Your specific area of focus
                          </FormDescription>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </form>
                </Form>
              </CardContent>
            </Card>

            {/* Advanced Settings */}
            <Card className="p-0 rounded">
              <div className="bg-gradient-to-r from-primary/10 to-primary/5 p-6 border-b">
                <CardHeader className="p-0">
                  <div className="flex items-center gap-3">
                    <div className="p-2 rounded-lg bg-background/80 backdrop-blur">
                      <Sparkles className="h-5 w-5 text-primary" />
                    </div>
                    <div>
                      <CardTitle>Content Style</CardTitle>
                      <CardDescription>
                        Define your unique voice and audience
                      </CardDescription>
                    </div>
                  </div>
                </CardHeader>
              </div>
              
              <CardContent className="p-6">
                <Form {...form}>
                  <form className="space-y-6">

                    <FormField
                      control={form.control}
                      name="tone"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="flex items-center gap-2">
                            <MessageSquare className="h-4 w-4" />
                            Tone & Style
                          </FormLabel>
                          <FormControl>
                            <Textarea
                              placeholder="Professional yet approachable, with a focus on clarity..."
                              className="resize-none min-h-[100px]"
                              {...field}
                            />
                          </FormControl>
                          <FormDescription>
                            Describe your communication style
                          </FormDescription>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="targetAudience"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="flex items-center gap-2">
                            <Users className="h-4 w-4" />
                            Target Audience
                          </FormLabel>
                          <FormControl>
                            <Textarea
                              placeholder="Beginner to intermediate developers looking to..."
                              className="resize-none min-h-[100px]"
                              {...field}
                            />
                          </FormControl>
                          <FormDescription>
                            Who watches your content
                          </FormDescription>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <div className="space-y-3">
                      <FormLabel className="flex items-center gap-2">
                        <Link2 className="h-4 w-4" />
                        Channel Links
                      </FormLabel>
                      <div className="flex gap-2">
                        <Input
                          value={newLink}
                          onChange={(e) => setNewLink(e.target.value)}
                          placeholder="https://youtube.com/@yourchannel"
                          onKeyDown={(e) => {
                            if (e.key === "Enter") {
                              e.preventDefault();
                              addLink();
                            }
                          }}
                        />
                        <Button 
                          type="button" 
                          size="icon" 
                          onClick={addLink}
                          className="shrink-0"
                        >
                          <Plus className="h-4 w-4" />
                        </Button>
                      </div>
                      {links.length > 0 && (
                        <div className="rounded-lg border bg-muted/50 p-3">
                          <div className="flex flex-wrap gap-2">
                            {links.map((link, index) => (
                              <Badge 
                                key={index} 
                                variant="secondary" 
                                className="pr-1 gap-1"
                              >
                                <Link2 className="h-3 w-3" />
                                <span className="max-w-[200px] truncate">{link}</span>
                                <Button
                                  type="button"
                                  variant="ghost"
                                  size="icon"
                                  className="h-4 w-4 ml-1 hover:bg-destructive/20"
                                  onClick={() => removeLink(index)}
                                >
                                  <X className="h-3 w-3" />
                                </Button>
                              </Badge>
                            ))}
                          </div>
                        </div>
                      )}
                    </div>
                  </form>
                </Form>
              </CardContent>
            </Card>
            
            {/* Save Button */}
            <div className="flex justify-end">
              <Button 
                onClick={form.handleSubmit(onSubmit as any)}
                disabled={isSubmitting}
                size="lg"
                className="gap-2"
              >
                {isSubmitting ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  <Save className="h-4 w-4" />
                )}
                Save All Changes
              </Button>
            </div>
          </div>

          {/* Profile Preview - 1 column */}
          <div className="space-y-6">
          <Card className="p-0 rounded sticky top-6">
              <div className="bg-gradient-to-r from-primary/10 to-primary/5 p-6 border-b">
                <CardHeader className="p-0">
                  <div className="flex items-center gap-3">
                    <div className="p-2 rounded-lg bg-background/80 backdrop-blur">
                      <Eye className="h-5 w-5 text-primary" />
                    </div>
                    <div>
                      <CardTitle>AI Profile Preview</CardTitle>
                      <CardDescription>
                        How the AI understands your channel
                      </CardDescription>
                    </div>
                  </div>
                </CardHeader>
              </div>
              <CardContent className="p-6">
                {profile ? (
                  <div className="space-y-4">
                    {/* Channel Overview */}
                    <div className="rounded-lg bg-gradient-to-br from-primary/5 to-transparent p-4">
                      <div className="flex items-start gap-3">
                        <div className="p-2 rounded-lg bg-primary/10">
                          <Youtube className="h-5 w-5 text-primary" />
                        </div>
                        <div className="flex-1">
                          <p className="font-semibold text-lg">{profile.channelName}</p>
                          <p className="text-sm text-muted-foreground mt-1">
                            {profile.contentType} ‚Ä¢ {profile.niche}
                          </p>
                        </div>
                      </div>
                    </div>
                
                    {/* Content Details */}
                    <div className="space-y-3">
                      {profile.tone && (
                        <div className="rounded-lg border bg-card/50 p-4">
                          <div className="flex items-start gap-3">
                            <MessageSquare className="h-5 w-5 text-muted-foreground mt-0.5" />
                            <div className="flex-1">
                              <p className="text-sm font-medium mb-1">Communication Style</p>
                              <p className="text-sm text-muted-foreground leading-relaxed">
                                {profile.tone}
                              </p>
                            </div>
                          </div>
                        </div>
                      )}
                      
                      {profile.targetAudience && (
                        <div className="rounded-lg border bg-card/50 p-4">
                          <div className="flex items-start gap-3">
                            <Users className="h-5 w-5 text-muted-foreground mt-0.5" />
                            <div className="flex-1">
                              <p className="text-sm font-medium mb-1">Target Audience</p>
                              <p className="text-sm text-muted-foreground leading-relaxed">
                                {profile.targetAudience}
                              </p>
                            </div>
                          </div>
                        </div>
                      )}
                    </div>
                
                    {profile.links.length > 0 && (
                      <div className="rounded-lg border bg-card/50 p-4">
                        <div className="flex items-start gap-3">
                          <Link2 className="h-5 w-5 text-muted-foreground mt-0.5" />
                          <div className="flex-1">
                            <p className="text-sm font-medium mb-2">Connected Links</p>
                            <div className="space-y-2">
                              {profile.links.map((link, index) => (
                                <a
                                  key={index}
                                  href={link}
                                  target="_blank"
                                  rel="noopener noreferrer"
                                  className="text-sm text-primary hover:underline flex items-center gap-1 group"
                                >
                                  <span className="truncate">{link}</span>
                                  <TrendingUp className="h-3 w-3 opacity-0 group-hover:opacity-100 transition-opacity" />
                                </a>
                              ))}
                            </div>
                          </div>
                        </div>
                      </div>
                    )}
                    
                    {/* AI Understanding */}
                    <div className="rounded-lg bg-gradient-to-br from-primary/5 to-transparent border border-primary/20 p-4">
                      <div className="flex items-center gap-2 mb-2">
                        <Sparkles className="h-4 w-4 text-primary" />
                        <p className="text-sm font-medium">AI Understanding</p>
                      </div>
                      <p className="text-sm text-muted-foreground leading-relaxed">
                        Based on your profile, the AI will generate content optimized for {profile.niche} creators, 
                        with a {profile.tone ? "tone that matches your style" : "professional tone"}, 
                        targeting {profile.targetAudience || "your audience"}.
                      </p>
                    </div>
                  </div>
                ) : (
                  <div className="text-center py-8">
                    <div className="p-3 rounded-full bg-muted/50 w-fit mx-auto mb-3">
                      <User className="h-6 w-6 text-muted-foreground" />
                    </div>
                    <p className="text-muted-foreground">
                      Complete your profile to see how the AI will personalize your content
                    </p>
                  </div>
                )}
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
}


================================================
FILE: app/styles/reactflow.css
================================================
/* ReactFlow styles */
@import "@xyflow/react/dist/style.css";

/* Custom canvas styles */
.react-flow__node-custom {
  background: white;
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 10px;
}

.react-flow__handle {
  width: 10px;
  height: 10px;
  background: #555;
  border: 2px solid #fff;
}

/* Prevent drag ghost from showing */
[draggable="true"] {
  -webkit-user-drag: element;
}

/* Style for dragging state */
[draggable="true"]:active {
  opacity: 0.5;
}


================================================
FILE: convex/README.md
================================================
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// functions.js
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.functions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// functions.js
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get(id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.functions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.



================================================
FILE: convex/agents.ts
================================================
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

export const create = mutation({
  args: {
    videoId: v.id("videos"),
    type: v.union(
      v.literal("title"),
      v.literal("description"),
      v.literal("thumbnail"),
      v.literal("tweets")
    ),
    canvasPosition: v.object({
      x: v.number(),
      y: v.number(),
    }),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    // Verify video exists and belongs to user
    const video = await ctx.db.get(args.videoId);
    if (!video || video.userId !== userId) {
      throw new Error("Video not found or unauthorized");
    }

    if (!video.projectId) {
      throw new Error("Video must belong to a project");
    }

    return await ctx.db.insert("agents", {
      videoId: args.videoId,
      userId,
      projectId: video.projectId,
      type: args.type,
      draft: "",
      connections: [],
      chatHistory: [],
      canvasPosition: args.canvasPosition,
      status: "idle",
      createdAt: Date.now(),
    });
  },
});

export const updateDraft = mutation({
  args: {
    id: v.id("agents"),
    draft: v.string(),
    status: v.optional(v.union(
      v.literal("idle"),
      v.literal("generating"),
      v.literal("ready"),
      v.literal("error")
    )),
    thumbnailUrl: v.optional(v.string()),
    thumbnailStorageId: v.optional(v.id("_storage")),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const agent = await ctx.db.get(args.id);
    if (!agent || agent.userId !== userId) {
      throw new Error("Agent not found or unauthorized");
    }

    const updateData: any = {
      draft: args.draft,
      status: args.status || "ready",
    };
    
    if (args.thumbnailUrl !== undefined) {
      updateData.thumbnailUrl = args.thumbnailUrl;
    }
    
    if (args.thumbnailStorageId !== undefined) {
      updateData.thumbnailStorageId = args.thumbnailStorageId;
    }

    await ctx.db.patch(args.id, updateData);
  },
});

export const updateConnections = mutation({
  args: {
    id: v.id("agents"),
    connections: v.array(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const agent = await ctx.db.get(args.id);
    if (!agent || agent.userId !== userId) {
      throw new Error("Agent not found or unauthorized");
    }

    await ctx.db.patch(args.id, { connections: args.connections });
  },
});

export const addChatMessage = mutation({
  args: {
    id: v.id("agents"),
    role: v.union(v.literal("user"), v.literal("ai")),
    message: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const agent = await ctx.db.get(args.id);
    if (!agent || agent.userId !== userId) {
      throw new Error("Agent not found or unauthorized");
    }

    const chatHistory = [...agent.chatHistory, {
      role: args.role,
      message: args.message,
      timestamp: Date.now(),
    }];

    await ctx.db.patch(args.id, { chatHistory });
  },
});

export const updatePosition = mutation({
  args: {
    id: v.id("agents"),
    canvasPosition: v.object({
      x: v.number(),
      y: v.number(),
    }),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const agent = await ctx.db.get(args.id);
    if (!agent || agent.userId !== userId) {
      throw new Error("Agent not found or unauthorized");
    }

    await ctx.db.patch(args.id, { canvasPosition: args.canvasPosition });
  },
});

export const getByVideo = query({
  args: { videoId: v.id("videos") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];
    const userId = identity.subject;

    return await ctx.db
      .query("agents")
      .withIndex("by_video", (q) => q.eq("videoId", args.videoId))
      .filter((q) => q.eq(q.field("userId"), userId))
      .collect();
  },
});

export const getByProject = query({
  args: { projectId: v.id("projects") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];
    const userId = identity.subject;

    // Verify project ownership
    const project = await ctx.db.get(args.projectId);
    if (!project || project.userId !== userId) {
      return [];
    }

    return await ctx.db
      .query("agents")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .collect();
  },
});

export const getById = query({
  args: { id: v.id("agents") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const agent = await ctx.db.get(args.id);
    if (!agent || agent.userId !== userId) {
      throw new Error("Agent not found or unauthorized");
    }

    return agent;
  },
});

export const remove = mutation({
  args: { id: v.id("agents") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const agent = await ctx.db.get(args.id);
    if (!agent || agent.userId !== userId) {
      throw new Error("Agent not found or unauthorized");
    }

    await ctx.db.delete(args.id);
  },
});


================================================
FILE: convex/ai.ts
================================================
import { v } from "convex/values";
import { action } from "./_generated/server";
import { api } from "./_generated/api";
import { openai } from "@ai-sdk/openai";
import { generateText } from "ai";

export const generateContent = action({
  args: {
    agentId: v.id("agents"),
    videoData: v.object({
      title: v.optional(v.string()),
      transcription: v.optional(v.string()),
    }),
    connectedAgentOutputs: v.array(
      v.object({
        type: v.string(),
        content: v.string(),
      })
    ),
    profileData: v.optional(
      v.object({
        channelName: v.string(),
        contentType: v.string(),
        niche: v.string(),
        tone: v.optional(v.string()),
        targetAudience: v.optional(v.string()),
      })
    ),
  },
  handler: async (ctx, args): Promise<string> => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    // Get agent details
    const agent = await ctx.runQuery(api.agents.getById, { id: args.agentId });
    if (!agent) throw new Error("Agent not found");

    // Update status to generating
    await ctx.runMutation(api.agents.updateDraft, {
      id: args.agentId,
      draft: agent.draft,
      status: "generating",
    });

    try {
      const prompt = buildPrompt(
        agent.type,
        args.videoData,
        args.connectedAgentOutputs,
        args.profileData
      );

      const { text: generatedContent } = await generateText({
        model: openai("gpt-4o-mini"),
        system: getSystemPrompt(agent.type),
        prompt,
        temperature: 0.7,
        maxTokens: agent.type === "description" ? 500 : 300,
      });

      // Update agent with generated content
      await ctx.runMutation(api.agents.updateDraft, {
        id: args.agentId,
        draft: generatedContent,
        status: "ready",
      });

      return generatedContent;
    } catch (error) {
      // Update status to error
      await ctx.runMutation(api.agents.updateDraft, {
        id: args.agentId,
        draft: agent.draft,
        status: "error",
      });
      throw error;
    }
  },
});

export const refineContent = action({
  args: {
    agentId: v.id("agents"),
    userMessage: v.string(),
    currentDraft: v.string(),
    videoData: v.optional(v.object({
      title: v.optional(v.string()),
      transcription: v.optional(v.string()),
    })),
    connectedAgentOutputs: v.optional(v.array(
      v.object({
        type: v.string(),
        content: v.string(),
      })
    )),
    profileData: v.optional(
      v.object({
        channelName: v.string(),
        contentType: v.string(),
        niche: v.string(),
        tone: v.optional(v.string()),
        targetAudience: v.optional(v.string()),
      })
    ),
  },
  handler: async (ctx, args): Promise<string> => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    const agent = await ctx.runQuery(api.agents.getById, { id: args.agentId });
    if (!agent) throw new Error("Agent not found");

    // Add user message to chat history
    await ctx.runMutation(api.agents.addChatMessage, {
      id: args.agentId,
      role: "user",
      message: args.userMessage,
    });

    try {
      // Build context with all available information
      let contextMessage = `Current draft: ${args.currentDraft}\n\n`;
      
      if (args.videoData) {
        contextMessage += "Video Context:\n";
        if (args.videoData.title) {
          contextMessage += `Title: ${args.videoData.title}\n`;
        }
        if (args.videoData.transcription) {
          contextMessage += `Transcription: ${args.videoData.transcription.slice(0, 1000)}...\n`;
        }
        contextMessage += "\n";
      }
      
      if (args.connectedAgentOutputs && args.connectedAgentOutputs.length > 0) {
        contextMessage += "Connected Agent Outputs:\n";
        args.connectedAgentOutputs.forEach(({ type, content }) => {
          contextMessage += `${type}: ${content}\n`;
        });
        contextMessage += "\n";
      }
      
      if (args.profileData) {
        contextMessage += "Channel Profile:\n";
        contextMessage += `Channel: ${args.profileData.channelName} (${args.profileData.niche})\n`;
        contextMessage += `Content Type: ${args.profileData.contentType}\n`;
        if (args.profileData.tone) {
          contextMessage += `Tone: ${args.profileData.tone}\n`;
        }
        if (args.profileData.targetAudience) {
          contextMessage += `Target Audience: ${args.profileData.targetAudience}\n`;
        }
      }

      const { text: refinedContent } = await generateText({
        model: openai("gpt-4o-mini"),
        system: getSystemPrompt(agent.type),
        messages: [
          {
            role: "assistant",
            content: contextMessage,
          },
          {
            role: "user",
            content: args.userMessage,
          },
        ],
        temperature: 0.7,
        maxTokens: agent.type === "description" ? 500 : 300,
      });

      // Update agent with refined content
      await ctx.runMutation(api.agents.updateDraft, {
        id: args.agentId,
        draft: refinedContent,
        status: "ready",
      });

      // Add AI response to chat history
      await ctx.runMutation(api.agents.addChatMessage, {
        id: args.agentId,
        role: "ai",
        message: refinedContent,
      });

      return refinedContent;
    } catch (error) {
      console.error("Error refining content:", error);
      throw error;
    }
  },
});

function getSystemPrompt(agentType: string): string {
  const prompts = {
    title: "You are an expert YouTube title creator. Create engaging, SEO-friendly titles that maximize click-through rates while accurately representing the video content. Keep titles under 60 characters when possible.",
    description: "You are an expert YouTube description writer. Create comprehensive, SEO-optimized descriptions that include relevant keywords, provide value to viewers, and encourage engagement. Include timestamps if applicable.",
    thumbnail: "You are an expert YouTube thumbnail designer. Describe compelling thumbnail concepts that grab attention, clearly communicate the video's value, and follow YouTube best practices. Focus on visual elements, text overlay suggestions, and color schemes.",
    tweets: "You are an expert social media marketer. Create engaging Twitter/X threads that promote YouTube videos. Write concise, engaging tweets that drive traffic to the video while providing value to the Twitter audience.",
  };

  return prompts[agentType as keyof typeof prompts] || prompts.title;
}

function buildPrompt(
  agentType: string,
  videoData: { title?: string; transcription?: string },
  connectedOutputs: Array<{ type: string; content: string }>,
  profileData?: {
    channelName: string;
    contentType: string;
    niche: string;
    tone?: string;
    targetAudience?: string;
  }
): string {
  let prompt = `Generate ${agentType} content for a YouTube video.\n\n`;

  // Add video data
  if (videoData.title) {
    prompt += `Video Title: ${videoData.title}\n`;
  }
  if (videoData.transcription) {
    prompt += `Video Transcription: ${videoData.transcription.slice(0, 1000)}...\n\n`;
  }

  // Add connected agent outputs
  if (connectedOutputs.length > 0) {
    prompt += "Related content from other agents:\n";
    connectedOutputs.forEach(({ type, content }) => {
      prompt += `${type}: ${content}\n`;
    });
    prompt += "\n";
  }

  // Add profile data
  if (profileData) {
    prompt += "Channel Information:\n";
    prompt += `Channel Name: ${profileData.channelName}\n`;
    prompt += `Content Type: ${profileData.contentType}\n`;
    prompt += `Niche: ${profileData.niche}\n`;
    if (profileData.tone) {
      prompt += `Tone: ${profileData.tone}\n`;
    }
    if (profileData.targetAudience) {
      prompt += `Target Audience: ${profileData.targetAudience}\n`;
    }
  }

  return prompt;
}


================================================
FILE: convex/aiHackathon.ts
================================================
import { v } from "convex/values";
import { action } from "./_generated/server";
import { api } from "./_generated/api";
import { openai } from "@ai-sdk/openai";
import { generateText } from "ai";

// Simplified AI generation for hackathon - no database dependencies
export const generateContentSimple = action({
  args: {
    agentType: v.union(
      v.literal("title"),
      v.literal("description"),
      v.literal("thumbnail"),
      v.literal("tweets")
    ),
    videoId: v.optional(v.id("videos")),
    videoData: v.object({
      title: v.optional(v.string()),
      transcription: v.optional(v.string()),
      duration: v.optional(v.number()),
      resolution: v.optional(v.object({
        width: v.number(),
        height: v.number(),
      })),
      format: v.optional(v.string()),
    }),
    connectedAgentOutputs: v.array(
      v.object({
        type: v.string(),
        content: v.string(),
      })
    ),
    profileData: v.optional(
      v.object({
        channelName: v.string(),
        contentType: v.string(),
        niche: v.string(),
        tone: v.optional(v.string()),
        targetAudience: v.optional(v.string()),
      })
    ),
  },
  handler: async (ctx, args): Promise<{ content: string; prompt: string }> => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    try {
      // If we have a videoId, fetch the latest video data with transcription
      let videoData = args.videoData;
      if (args.videoId) {
        const freshVideoData = await ctx.runQuery(api.videos.getWithTranscription, {
          id: args.videoId,
        });
        if (freshVideoData && freshVideoData.transcription) {
          videoData = {
            title: freshVideoData.title || args.videoData.title,
            transcription: freshVideoData.transcription,
          };
          console.log(`Using transcription for ${args.agentType} generation (${freshVideoData.transcription.length} chars)`);
          // Log first 200 chars of transcription for debugging
          console.log(`Transcription preview: "${freshVideoData.transcription.substring(0, 200)}..."`);
        }
      }
      // Log data availability for title generation
      if (args.agentType === 'title') {
        console.log(`[Title Agent] Data availability:`, {
          hasTranscription: !!videoData.transcription,
          transcriptionLength: videoData.transcription?.length || 0,
          hasProfile: !!args.profileData,
          channelName: args.profileData?.channelName,
          contentType: args.profileData?.contentType,
          targetAudience: args.profileData?.targetAudience,
          hasConnectedAgents: args.connectedAgentOutputs.length > 0
        });
      }

      const prompt = buildPrompt(
        args.agentType,
        videoData, // Use the fresh video data
        args.connectedAgentOutputs,
        args.profileData
      );

      // Log if generating without transcription
      if (!videoData.transcription) {
        console.log(`Generating ${args.agentType} without transcription - using title only`);
      }

      // Optimize generation parameters based on content type
      const generationParams = {
        title: { temperature: 0.8, maxTokens: 100 },      // More creative titles
        description: { temperature: 0.7, maxTokens: 150 }, // Concise 2-line benefits
        thumbnail: { temperature: 0.9, maxTokens: 400 },   // Very creative visuals
        tweets: { temperature: 0.8, maxTokens: 200 },      // Simple 2-tweet format
      };

      const params = generationParams[args.agentType as keyof typeof generationParams] 
        || { temperature: 0.7, maxTokens: 300 };

      const { text: generatedContent } = await generateText({
        model: openai("gpt-4o"),  // Upgrade to better model for quality
        system: getSystemPrompt(args.agentType),
        prompt,
        temperature: params.temperature,
        maxTokens: params.maxTokens,
      });

      return { content: generatedContent, prompt };
    } catch (error) {
      console.error("Error generating content:", error);
      throw error;
    }
  },
});

function getSystemPrompt(agentType: string): string {
  const prompts = {
    title: `You are a world-class YouTube algorithm optimization expert with 10+ years of experience. Your titles consistently achieve 10%+ CTR.

CRITICAL ANALYSIS PROCESS:
1. FIRST, analyze the video transcription to identify:
   - The main topic/problem being addressed
   - Key moments, revelations, or transformations
   - Specific numbers, statistics, or results mentioned
   - Emotional peaks or surprising elements
   - The unique value proposition of this video

2. THEN, consider the channel's profile:
   - Match the tone to the brand voice
   - Use vocabulary appropriate for the target audience
   - Stay consistent with the channel's content style
   - Leverage the niche expertise

TITLE OPTIMIZATION RULES:
1. Maximum 60 characters (YouTube truncates after this)
2. Front-load the most compelling element in first 30 characters
3. Include 1-2 searchable keywords from the transcription naturally
4. Ensure the title accurately represents what viewers will learn/see
5. Test readability at a glance (would you click this?)

PROVEN TITLE FORMULAS BY CONTENT TYPE:
Educational/Tutorial:
- "How to [Achieve Specific Result] in [Timeframe]"
- "[Number] [Mistakes/Tips] for [Topic]"
- "The [Adjective] Guide to [Topic]"

Entertainment/Story:
- "I [Did Something Unexpected] and [Result]"
- "[Person/Thing] [Unexpected Action]"
- "The [Adjective] Truth About [Topic]"

News/Commentary:
- "[Famous Person/Brand] Just [Action]"
- "Why [Recent Event] Changes Everything"
- "[Number] Things You Missed About [Topic]"

Review/Analysis:
- "[Product/Topic]: [Verdict] After [Time/Usage]"
- "Is [Topic] Worth It? [Surprising Finding]"
- "[Topic] vs [Topic]: The [Adjective] Truth"

PSYCHOLOGICAL OPTIMIZATION:
- Curiosity Gap: Tease the payoff without giving it away
- Specificity: Use exact numbers/timeframes from the video
- Urgency: If time-sensitive, include temporal elements
- Social Proof: Reference popularity/authority when relevant
- Transformation: Show before/after or problem/solution

BRAND CONSISTENCY CHECK:
- Does this title match the channel's typical style?
- Is the language appropriate for the target audience?
- Does it reflect the creator's unique perspective?
- Would regular viewers recognize this as your content?

CREATE ONE POWERFUL TITLE that:
1. Accurately summarizes the video's core value
2. Uses specific details from the transcription
3. Matches the channel's brand and audience
4. Maximizes click-through potential
5. Fits within 60 characters

IMPORTANT OUTPUT FORMAT:
- Return ONLY the title text itself
- Do NOT include "Title:", "**", quotes, or any markdown/formatting
- Just output the plain title text, nothing else`,

    description: `You are a master at writing compelling 2-line YouTube descriptions that focus entirely on viewer benefits.

Write EXACTLY 2 lines that tell viewers what they'll gain from watching:
- Line 1: The specific skill, knowledge, or insight they'll gain
- Line 2: The outcome or transformation they'll achieve

Rules:
- Use "You'll learn/discover/master" language
- Be specific about benefits (not vague promises)
- NO timestamps, links, hashtags, or SEO keywords
- NO "In this video" or "Watch to find out" phrases
- Maximum 80 characters per line
- Focus on VALUE, not features

Example format:
Learn how to use AI tools to write JavaScript 10x faster and debug like a pro.
You'll save hours of coding time and eliminate frustrating syntax errors forever.`,

    thumbnail: `You are a YouTube thumbnail psychology expert and visual marketing specialist. Your thumbnails consistently achieve 15%+ CTR.

ANALYZE THE VIDEO TRANSCRIPTION and create a thumbnail concept following these PROVEN PRINCIPLES:

1. VISUAL HIERARCHY:
   - One clear focal point (usually a face with strong emotion)
   - High contrast between elements
   - Rule of thirds composition
   - 2-3 visual elements maximum

2. COLOR PSYCHOLOGY:
   - YouTube Red (#FF0000) for urgency/importance
   - Bright Yellow (#FFD700) for attention/warning
   - Neon Green (#39FF14) for success/money
   - Electric Blue (#0FF0FC) for tech/future
   - White/Black for contrast

3. TEXT OVERLAY RULES:
   - Maximum 3-5 words
   - Sans-serif bold fonts (Impact, Bebas Neue)
   - Text size: readable on mobile (test at 120x90px)
   - Contrasting stroke/shadow for readability
   - Place text where it won't be covered by duration stamp

4. EMOTIONAL TRIGGERS:
   - Shock/Surprise (wide eyes, open mouth)
   - Curiosity (partially hidden elements)
   - Desire (aspirational imagery)
   - Fear/Concern (worried expressions)
   - Joy/Success (genuine smiles, celebrations)

5. COMPOSITION TECHNIQUES:
   - Use arrows/circles to direct attention
   - Before/After splits for transformations
   - Number overlays for listicles
   - "X" marks for myths/mistakes
   - Progress bars for challenges

Describe specific visual elements, exact colors (hex codes), text placement, and facial expressions based on the video content.`,

    tweets: `You are a social media expert who creates simple, effective tweet threads that drive YouTube views.

Create EXACTLY 2 tweets:

TWEET 1 (Teaser with thumbnail):
- 2 lines that tease the video content
- Create curiosity without giving everything away
- Natural, conversational tone
- NO hashtags, NO "thread üßµ" 
- Just make people want to know more
- End with: [thumbnail]

TWEET 2 (Link tweet):
- Simple and direct
- One line that promises the benefit
- Include the video link
- Format: "Here's how: [link]" or "Watch here: [link]"

Example format:
Tweet 1:
Wait, you can use AI to write JavaScript now?
This is about to save me hours of debugging... [thumbnail]

Tweet 2:
Here's how to never write a syntax error again: [link]

Keep it SIMPLE and NATURAL - like you're telling a friend about something cool.`,
  };

  return prompts[agentType as keyof typeof prompts] || prompts.title;
}

function buildPrompt(
  agentType: string,
  videoData: { 
    title?: string; 
    transcription?: string;
    duration?: number;
    resolution?: { width: number; height: number };
    format?: string;
  },
  connectedOutputs: Array<{ type: string; content: string }>,
  profileData?: {
    channelName: string;
    contentType: string;
    niche: string;
    tone?: string;
    targetAudience?: string;
  }
): string {
  let prompt = "";

  // Add video metadata if available
  if (videoData.duration || videoData.resolution) {
    prompt += "Video Technical Details:\n";
    if (videoData.duration) {
      const minutes = Math.floor(videoData.duration / 60);
      const seconds = Math.floor(videoData.duration % 60);
      prompt += `- Duration: ${minutes}:${seconds.toString().padStart(2, '0')}\n`;
    }
    if (videoData.resolution) {
      prompt += `- Resolution: ${videoData.resolution.width}x${videoData.resolution.height}`;
      if (videoData.resolution.height >= 2160) prompt += " (4K)";
      else if (videoData.resolution.height >= 1080) prompt += " (HD)";
      prompt += "\n";
    }
    if (videoData.format) {
      prompt += `- Format: ${videoData.format}\n`;
    }
    prompt += "\n";
  }

  // Emphasize transcription-based generation
  if (videoData.transcription) {
    // Analyze transcription for key insights
    const wordCount = videoData.transcription.split(' ').length;
    const estimatedReadTime = Math.ceil(wordCount / 150); // 150 words per minute average speaking rate
    
    prompt += `üéØ CONTENT ANALYSIS:\n`;
    prompt += `- Video length: ${videoData.duration ? Math.floor(videoData.duration / 60) + ' minutes' : estimatedReadTime + ' minutes (estimated)'}\n`;
    prompt += `- Word count: ~${wordCount} words\n`;
    prompt += `- Content depth: ${wordCount > 2000 ? 'In-depth/Tutorial' : wordCount > 800 ? 'Standard' : 'Quick/Short-form'}\n\n`;
    
    prompt += `üìù VIDEO TRANSCRIPTION (Analyze carefully for key points, emotions, and hooks):\n`;
    
    // Include more of the transcription for better context (up to 4000 chars for better understanding)
    const transcriptionPreview = videoData.transcription.length > 4000 
      ? videoData.transcription.slice(0, 4000) + "\n\n[Transcription continues...]"
      : videoData.transcription;
    prompt += `${transcriptionPreview}\n\n`;
    
    if (videoData.title) {
      prompt += `Current Video Title: ${videoData.title}\n\n`;
    }
    
    // Add specific instructions based on agent type
    if (agentType === 'title') {
      prompt += `üéØ TITLE GENERATION REQUIREMENTS:\n\n`;
      
      // Extract key moments from transcription for title focus
      prompt += `üìä KEY CONTENT ANALYSIS:\n`;
      prompt += `Based on the transcription above, focus your title on:\n`;
      prompt += `- The MAIN VALUE viewers will get from this video\n`;
      prompt += `- Any SPECIFIC NUMBERS, stats, or timeframes mentioned\n`;
      prompt += `- The PROBLEM being solved or question being answered\n`;
      prompt += `- Any SURPRISING or counterintuitive points made\n`;
      prompt += `- TRANSFORMATION or results achieved\n\n`;
      
      // Emphasize profile integration
      if (profileData) {
        prompt += `üé® BRAND-SPECIFIC REQUIREMENTS:\n`;
        prompt += `- This is a ${profileData.contentType} video for ${profileData.channelName}\n`;
        prompt += `- Target audience: ${profileData.targetAudience || 'General viewers'}\n`;
        prompt += `- Brand tone: ${profileData.tone || 'Professional'}\n`;
        prompt += `- Niche focus: ${profileData.niche}\n`;
        prompt += `- IMPORTANT: The title MUST feel authentic to this channel's style\n\n`;
      }
      
      prompt += `‚úÖ TITLE CHECKLIST:\n`;
      prompt += `‚ñ° Uses specific details from the transcription (not generic)\n`;
      prompt += `‚ñ° Matches the channel's established style and tone\n`;
      prompt += `‚ñ° Appeals to the target audience's interests\n`;
      prompt += `‚ñ° Under 60 characters (count them!)\n`;
      prompt += `‚ñ° Would make YOU click if you saw it\n\n`;
      
      // Add content-type specific examples
      if (profileData?.contentType) {
        prompt += `üí° EXAMPLES FOR ${profileData.contentType.toUpperCase()} CONTENT:\n`;
        
        const examplesByType: Record<string, string[]> = {
          'Gaming': [
            'This Strategy Broke [Game] in 24 Hours',
            'Why Pro Players Hate This One Trick',
            'I Reached Max Level Using Only [Constraint]'
          ],
          'Technology': [
            'The $99 Device That Replaced My $2000 Setup',
            'Apple Didn\'t Want You to Know This',
            '5 GitHub Repos That Will 10x Your Coding'
          ],
          'Education': [
            'Learn [Skill] in 20 Minutes (Science-Based)',
            'MIT\'s Secret Study Method (137% Better)',
            'The Math Trick Schools Don\'t Teach'
          ],
          'Entertainment': [
            'We Tried [Challenge] for 30 Days',
            'Reading My Subscriber\'s Wildest Stories',
            'This Changed Everything (Not Clickbait)'
          ],
          'Lifestyle': [
            'My Morning Routine Saves 3 Hours Daily',
            'Minimalists Are Wrong About This',
            '$20 vs $200: The Shocking Truth'
          ]
        };
        
        const examples = examplesByType[profileData.contentType] || [
          'The Hidden Truth About [Topic]',
          'Why [Common Belief] Is Completely Wrong',
          'I Tested [Method] for 30 Days'
        ];
        
        examples.forEach(example => {
          prompt += `- ${example}\n`;
        });
        prompt += `\nAdapt these patterns to YOUR specific video content!\n\n`;
      }
    } else if (agentType === 'description') {
      prompt += `üéØ DESCRIPTION GENERATION FOCUS:\n`;
      prompt += `- Extract ALL main points discussed in order\n`;
      prompt += `- Identify natural timestamp breaks\n`;
      prompt += `- Find quotable moments for engagement\n\n`;
    } else if (agentType === 'thumbnail') {
      prompt += `üéØ THUMBNAIL GENERATION FOCUS:\n`;
      prompt += `- Identify the most visually representable moment\n`;
      prompt += `- Find emotional peaks in the content\n`;
      prompt += `- Look for before/after, numbers, or shock value\n\n`;
    } else if (agentType === 'tweets') {
      prompt += `üéØ TWEET GENERATION FOCUS:\n`;
      prompt += `- Extract the most shareable insights\n`;
      prompt += `- Find controversial or surprising statements\n`;
      prompt += `- Identify actionable tips mentioned\n\n`;
    }
  } else {
    prompt += `‚ö†Ô∏è LIMITED CONTEXT MODE - No transcription available\n\n`;
    if (videoData.title) {
      prompt += `Video Title: ${videoData.title}\n`;
    }
    prompt += `Generate high-quality ${agentType} content based on the title and any connected content.\n`;
    prompt += `Focus on creating compelling, clickable content that aligns with the title's topic.\n\n`;
  }

  // Add connected agent outputs
  if (connectedOutputs.length > 0) {
    prompt += "Related content from other agents:\n";
    connectedOutputs.forEach(({ type, content }) => {
      prompt += `${type}: ${content}\n`;
    });
    prompt += "\n";
  }

  // Add profile data with strategic emphasis
  if (profileData) {
    prompt += "üé® BRAND IDENTITY & AUDIENCE:\n";
    prompt += `Channel: ${profileData.channelName}\n`;
    prompt += `Content Vertical: ${profileData.contentType}\n`;
    prompt += `Niche Authority: ${profileData.niche}\n`;
    
    if (profileData.tone) {
      prompt += `Brand Voice: ${profileData.tone}\n`;
      prompt += `IMPORTANT: All content must match this tone consistently!\n`;
    }
    
    if (profileData.targetAudience) {
      prompt += `Target Viewer: ${profileData.targetAudience}\n`;
      prompt += `Optimization: Tailor language, references, and complexity for this audience\n`;
    }
    
    prompt += "\nüí° FINAL INSTRUCTIONS:\n";
    prompt += `- Stay true to the channel's established brand\n`;
    prompt += `- Use language that resonates with the target audience\n`;
    prompt += `- Maintain consistency with existing content style\n`;
    prompt += `- Be authentic to the creator's voice\n`;
  } else {
    prompt += "\nüí° FINAL INSTRUCTIONS:\n";
    prompt += `- Create professional, engaging content\n`;
    prompt += `- Focus on value and viewer retention\n`;
    prompt += `- Use clear, accessible language\n`;
  }

  return prompt;
}


================================================
FILE: convex/auth.config.ts
================================================
export default {
    providers: [
      {
        domain: process.env.VITE_CLERK_FRONTEND_API_URL,
        applicationID: "convex",
      },
    ]
  };


================================================
FILE: convex/canvas.ts
================================================
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

export const saveState = mutation({
  args: {
    projectId: v.id("projects"),
    nodes: v.array(
      v.object({
        id: v.string(),
        type: v.string(),
        position: v.object({
          x: v.number(),
          y: v.number(),
        }),
        data: v.any(),
      })
    ),
    edges: v.array(
      v.object({
        id: v.string(),
        source: v.string(),
        target: v.string(),
        sourceHandle: v.optional(v.string()),
        targetHandle: v.optional(v.string()),
      })
    ),
    viewport: v.object({
      x: v.number(),
      y: v.number(), 
      zoom: v.number(),
    }),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    // Verify project ownership
    const project = await ctx.db.get(args.projectId);
    if (!project || project.userId !== userId) {
      throw new Error("Project not found or unauthorized");
    }

    // Use viewport as-is, only validate that it's not completely broken
    const viewport = args.viewport;
    const validatedViewport = {
      x: isFinite(viewport.x) ? viewport.x : 0,
      y: isFinite(viewport.y) ? viewport.y : 0,
      zoom: (isFinite(viewport.zoom) && viewport.zoom > 0) ? viewport.zoom : 1,
    };

    const existing = await ctx.db
      .query("projectCanvases")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .first();

    if (existing) {
      await ctx.db.patch(existing._id, {
        nodes: args.nodes,
        edges: args.edges,
        viewport: validatedViewport,
        updatedAt: Date.now(),
      });
    } else {
      await ctx.db.insert("projectCanvases", {
        userId,
        projectId: args.projectId,
        nodes: args.nodes,
        edges: args.edges,
        viewport: validatedViewport,
        updatedAt: Date.now(),
      });
    }
  },
});

export const getState = query({
  args: { projectId: v.id("projects") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;
    const userId = identity.subject;

    // Verify project ownership
    const project = await ctx.db.get(args.projectId);
    if (!project || project.userId !== userId) {
      return null;
    }

    return await ctx.db
      .query("projectCanvases")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .first();
  },
});

export const clearState = mutation({
  args: { projectId: v.id("projects") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    // Verify project ownership
    const project = await ctx.db.get(args.projectId);
    if (!project || project.userId !== userId) {
      throw new Error("Project not found or unauthorized");
    }

    const state = await ctx.db
      .query("projectCanvases")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .first();

    if (state) {
      await ctx.db.delete(state._id);
    }
  },
});


================================================
FILE: convex/chat.ts
================================================
import { v } from "convex/values";
import { action } from "./_generated/server";
import { api } from "./_generated/api";
import { openai } from "@ai-sdk/openai";
import { generateText } from "ai";

export const refineContent = action({
  args: {
    agentId: v.id("agents"),
    userMessage: v.string(),
    currentDraft: v.string(),
    agentType: v.union(
      v.literal("title"),
      v.literal("description"),
      v.literal("thumbnail"),
      v.literal("tweets")
    ),
    chatHistory: v.array(
      v.object({
        role: v.union(v.literal("user"), v.literal("ai")),
        content: v.string(),
      })
    ),
    videoData: v.optional(
      v.object({
        title: v.optional(v.string()),
        transcription: v.optional(v.string()),
        duration: v.optional(v.number()),
        resolution: v.optional(v.object({
          width: v.number(),
          height: v.number(),
        })),
        format: v.optional(v.string()),
      })
    ),
    connectedAgentOutputs: v.optional(v.array(
      v.object({
        type: v.string(),
        content: v.string(),
      })
    )),
    profileData: v.optional(
      v.object({
        channelName: v.string(),
        contentType: v.string(),
        niche: v.string(),
        tone: v.optional(v.string()),
        targetAudience: v.optional(v.string()),
      })
    ),
  },
  handler: async (ctx, args): Promise<{ response: string; updatedDraft: string }> => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    try {
      // Build the system prompt based on agent type
      const systemPrompt = getRefineSystemPrompt(args.agentType);
      
      // Build the conversation context with proper types
      let prompt = systemPrompt + "\n\n";
      prompt += `CURRENT ${args.agentType.toUpperCase()} (that needs to be changed): "${args.currentDraft}"\n\n`;
      prompt += `Note: The user wants this regenerated/changed. Do NOT return the same content.\n\n`;
      
      // Add chat history
      if (args.chatHistory.length > 0) {
        prompt += "Previous conversation:\n";
        args.chatHistory.forEach((msg) => {
          prompt += `${msg.role === "user" ? "User" : "Assistant"}: ${msg.content}\n`;
        });
        prompt += "\n";
      }
      
      // Add context about the video if available
      if (args.videoData?.transcription) {
        prompt += `Video context: ${args.videoData.transcription.slice(0, 1000)}...\n\n`;
      }
      
      // Add connected agent outputs if available
      if (args.connectedAgentOutputs && args.connectedAgentOutputs.length > 0) {
        prompt += "Related content from other agents:\n";
        args.connectedAgentOutputs.forEach(({ type, content }) => {
          prompt += `${type}: ${content}\n`;
        });
        prompt += "\n";
      }
      
      // Add profile data if available
      if (args.profileData) {
        prompt += "Channel Profile:\n";
        prompt += `Channel: ${args.profileData.channelName} (${args.profileData.niche})\n`;
        prompt += `Content Type: ${args.profileData.contentType}\n`;
        if (args.profileData.tone) {
          prompt += `Tone: ${args.profileData.tone}\n`;
        }
        if (args.profileData.targetAudience) {
          prompt += `Target Audience: ${args.profileData.targetAudience}\n`;
        }
        prompt += "\n";
      }
      
      // Add the current user message
      prompt += `User: ${args.userMessage}\n\nPlease provide your response following the format specified in the system prompt.`;

      // Generate refined content
      const { text: response } = await generateText({
        model: openai("gpt-4o-mini"),
        system: systemPrompt,
        prompt,
        temperature: 0.7,
        maxTokens: 500,
      });

      // Extract the updated draft from the response
      // The AI should return both a conversational response and the updated content
      const updatedDraft = extractUpdatedDraft(response, args.agentType, args.currentDraft);

      // Save the chat messages to the agent
      await ctx.runMutation(api.agents.addChatMessage, {
        id: args.agentId,
        role: "user",
        message: args.userMessage,
      });
      
      await ctx.runMutation(api.agents.addChatMessage, {
        id: args.agentId,
        role: "ai",
        message: response,
      });
      
      // Update the agent's draft if it changed
      if (updatedDraft !== args.currentDraft) {
        await ctx.runMutation(api.agents.updateDraft, {
          id: args.agentId,
          draft: updatedDraft,
          status: "ready",
        });
      }

      return { response, updatedDraft };
    } catch (error) {
      console.error("Error refining content:", error);
      throw error;
    }
  },
});

function getRefineSystemPrompt(agentType: string): string {
  const basePrompt = `You are an AI assistant helping to refine ${agentType} content for YouTube videos. 
When the user asks for changes or regeneration, you MUST create NEW content that is DIFFERENT from the current draft while incorporating their feedback.

IMPORTANT: 
- If the user asks to regenerate, create something COMPLETELY NEW based on their instructions
- Do NOT return the same or similar content as the current draft
- The updated content should reflect the user's specific requests

When responding, provide:
1. A friendly response acknowledging their request
2. The NEW ${agentType} that incorporates their feedback

Format your response as:
[Your conversational response]

UPDATED ${agentType.toUpperCase()}:
[The completely new or significantly modified content]

Important guidelines:`;

  const typeSpecificGuidelines = {
    title: `
- Keep titles under 60 characters
- Make them engaging and clickable
- Include relevant keywords
- Avoid clickbait but create curiosity`,
    
    description: `
- Include relevant keywords naturally
- Structure with clear sections
- Add timestamps if mentioned
- Include calls-to-action
- Optimize for SEO`,
    
    thumbnail: `
- Describe visual elements clearly
- Suggest compelling text overlays
- Recommend color schemes
- Focus on eye-catching composition
- Consider mobile visibility`,
    
    tweets: `
- Keep within Twitter/X character limits
- Make each tweet valuable standalone
- Include relevant hashtags
- Create engaging hooks
- Encourage retweets and engagement`,
  };

  return basePrompt + (typeSpecificGuidelines[agentType as keyof typeof typeSpecificGuidelines] || "");
}

function extractUpdatedDraft(response: string, agentType: string, currentDraft: string): string {
  // Look for the updated content section in the response
  const marker = `UPDATED ${agentType.toUpperCase()}:`;
  const markerIndex = response.indexOf(marker);
  
  if (markerIndex !== -1) {
    const updatedContent = response.substring(markerIndex + marker.length).trim();
    return updatedContent;
  }
  
  // If no explicit update marker, return the current draft
  return currentDraft;
}


================================================
FILE: convex/convex.config.ts
================================================
// convex/convex.config.ts
import { defineApp } from "convex/server";
import polar from "@convex-dev/polar/convex.config";

const app = defineApp();
app.use(polar);

export default app;



================================================
FILE: convex/files.ts
================================================
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

// This mutation generates an upload URL for the client to upload files directly
export const generateUploadUrl = mutation(async (ctx) => {
  const identity = await ctx.auth.getUserIdentity();
  if (!identity) throw new Error("Unauthorized");
  
  // This creates a temporary upload URL that the client can POST to
  return await ctx.storage.generateUploadUrl();
});

// This stores the file reference after upload
export const createVideoFile = mutation({
  args: {
    storageId: v.id("_storage"),
    title: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    
    const url = await ctx.storage.getUrl(args.storageId);
    
    return {
      storageId: args.storageId,
      url,
    };
  },
});

// Query to get URL from storage ID
export const getUrl = query({
  args: {
    storageId: v.id("_storage"),
  },
  handler: async (ctx, args) => {
    return await ctx.storage.getUrl(args.storageId);
  },
});


================================================
FILE: convex/http.ts
================================================
import { openai } from "@ai-sdk/openai";
import { streamText } from "ai";
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";

export const chat = httpAction(async (ctx, req) => {
  // Extract the `messages` from the body of the request
  const { messages } = await req.json();

  const result = streamText({
    model: openai("gpt-4o"),
    messages,
    async onFinish({ text }) {
      // implement your own logic here, e.g. for storing messages
      // or recording token usage
      console.log(text);
    },
  });

  // Respond with the stream
  return result.toDataStreamResponse({
    headers: {
      "Access-Control-Allow-Origin": process.env.FRONTEND_URL || "http://localhost:5173",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Allow-Credentials": "true",
      Vary: "origin",
    },
  });
});

const http = httpRouter();

http.route({
  path: "/api/chat",
  method: "POST",
  handler: chat,
});

http.route({
  path: "/api/chat",
  method: "OPTIONS",
  handler: httpAction(async (_, request) => {
    // Make sure the necessary headers are present
    // for this to be a valid pre-flight request
    const headers = request.headers;
    if (
      headers.get("Origin") !== null &&
      headers.get("Access-Control-Request-Method") !== null &&
      headers.get("Access-Control-Request-Headers") !== null
    ) {
      return new Response(null, {
        headers: new Headers({
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST",
          "Access-Control-Allow-Headers": "Content-Type, Authorization",
          "Access-Control-Allow-Credentials": "true",
          "Access-Control-Max-Age": "86400",
        }),
      });
    } else {
      return new Response();
    }
  }),
});

http.route({
  path: "/api/auth/webhook",
  method: "POST",
  handler: httpAction(async (_, request) => {
    // Make sure the necessary headers are present
    // for this to be a valid pre-flight request
    const headers = request.headers;
    if (
      headers.get("Origin") !== null &&
      headers.get("Access-Control-Request-Method") !== null &&
      headers.get("Access-Control-Request-Headers") !== null
    ) {
      return new Response(null, {
        headers: new Headers({
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST",
          "Access-Control-Allow-Headers": "Content-Type, Authorization",
          "Access-Control-Allow-Credentials": "true",
          "Access-Control-Max-Age": "86400",
        }),
      });
    } else {
      return new Response();
    }
  }),
});


// Transcription proxy endpoint
http.route({
  path: "/api/transcribe",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    const apiKey = process.env.ELEVENLABS_API_KEY;
    
    if (!apiKey) {
      return new Response(JSON.stringify({ error: "ElevenLabs API key not configured" }), {
        status: 500,
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*",
        },
      });
    }
    
    try {
      // Get the form data from the request
      const formData = await request.formData();
      
      // Log file details
      const file = formData.get("file") as File;
      if (file) {
        console.log("üìé Transcription request:", {
          fileName: file.name,
          fileSize: file.size,
          fileType: file.type,
          fileSizeMB: (file.size / 1024 / 1024).toFixed(2),
        });
        
        // Check file size before processing
        const MAX_SIZE = 20 * 1024 * 1024; // 20MB
        if (file.size > MAX_SIZE) {
          return new Response(JSON.stringify({ 
            error: "File size exceeds 20MB limit. Please use a smaller file or compress the audio.",
            details: {
              fileSize: file.size,
              maxSize: MAX_SIZE,
              fileSizeMB: (file.size / 1024 / 1024).toFixed(2),
              maxSizeMB: 20
            }
          }), {
            status: 413, // Payload Too Large
            headers: {
              "Content-Type": "application/json",
              "Access-Control-Allow-Origin": "*",
            },
          });
        }
      }
      
      // Forward the request to ElevenLabs
      const response = await fetch("https://api.elevenlabs.io/v1/speech-to-text", {
        method: "POST",
        headers: {
          "Xi-Api-Key": apiKey,
        },
        body: formData,
      });
      
      // Get the response data
      const responseData = await response.text();
      
      // Log response for debugging
      if (!response.ok) {
        console.error("‚ùå ElevenLabs error:", {
          status: response.status,
          statusText: response.statusText,
          response: responseData,
        });
      } else {
        console.log("‚úÖ ElevenLabs transcription successful");
        // Parse and check if it's the "no speech" response
        try {
          const result = JSON.parse(responseData);
          if (result.text === "" || result.text === "We couldn't transcribe the audio. The video might be silent or in an unsupported language.") {
            console.warn("‚ö†Ô∏è No speech detected in the file");
          }
        } catch (e) {
          // Not JSON, that's okay
        }
      }
      
      // Return the response with CORS headers
      return new Response(responseData, {
        status: response.status,
        headers: {
          "Content-Type": response.headers.get("Content-Type") || "application/json",
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type",
        },
      });
    } catch (error: any) {
      console.error("Transcription proxy error:", error);
      return new Response(JSON.stringify({ error: "Failed to process transcription request" }), {
        status: 500,
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*",
        },
      });
    }
  }),
});

// OPTIONS handler for transcription endpoint
http.route({
  path: "/api/transcribe",
  method: "OPTIONS",
  handler: httpAction(async (_, request) => {
    return new Response(null, {
      headers: {
        "Access-Control-Allow-Origin": process.env.FRONTEND_URL || "http://localhost:5173",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type",
        "Access-Control-Max-Age": "86400",
      },
    });
  }),
});

// Log that routes are configured
console.log("HTTP routes configured");

// Convex expects the router to be the default export of `convex/http.js`.
export default http;



================================================
FILE: convex/profiles.ts
================================================
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

export const get = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;
    const userId = identity.subject;

    return await ctx.db
      .query("profiles")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .first();
  },
});

export const upsert = mutation({
  args: {
    channelName: v.string(),
    contentType: v.string(),
    niche: v.string(),
    links: v.array(v.string()),
    tone: v.optional(v.string()),
    targetAudience: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const existing = await ctx.db
      .query("profiles")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .first();

    if (existing) {
      await ctx.db.patch(existing._id, {
        ...args,
        updatedAt: Date.now(),
      });
      return existing._id;
    } else {
      return await ctx.db.insert("profiles", {
        userId,
        ...args,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    }
  },
});

export const remove = mutation({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const profile = await ctx.db
      .query("profiles")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .first();

    if (profile) {
      await ctx.db.delete(profile._id);
    }
  },
});


================================================
FILE: convex/projects.ts
================================================
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

export const create = mutation({
  args: {
    title: v.string(),
    description: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const projectId = await ctx.db.insert("projects", {
      userId,
      title: args.title,
      description: args.description,
      thumbnail: undefined,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      isArchived: false,
    });

    return projectId;
  },
});

export const list = query({
  args: {
    includeArchived: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];
    const userId = identity.subject;

    let projects;
    if (args.includeArchived) {
      projects = await ctx.db
        .query("projects")
        .withIndex("by_user", (q) => q.eq("userId", userId))
        .order("desc")
        .collect();
    } else {
      projects = await ctx.db
        .query("projects")
        .withIndex("by_user_archived", (q) => 
          q.eq("userId", userId).eq("isArchived", false)
        )
        .order("desc")
        .collect();
    }

    // Get first video for each project to use as thumbnail
    const projectsWithThumbnails = await Promise.all(
      projects.map(async (project) => {
        const firstVideo = await ctx.db
          .query("videos")
          .withIndex("by_project", (q) => q.eq("projectId", project._id))
          .first();
        
        return {
          ...project,
          thumbnail: firstVideo?.videoUrl || project.thumbnail,
        };
      })
    );

    return projectsWithThumbnails;
  },
});

export const get = query({
  args: { id: v.id("projects") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const project = await ctx.db.get(args.id);
    if (!project || project.userId !== userId) {
      throw new Error("Project not found or unauthorized");
    }

    return project;
  },
});

export const update = mutation({
  args: {
    id: v.id("projects"),
    title: v.optional(v.string()),
    description: v.optional(v.string()),
    isArchived: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const project = await ctx.db.get(args.id);
    if (!project || project.userId !== userId) {
      throw new Error("Project not found or unauthorized");
    }

    const updates: any = {
      updatedAt: Date.now(),
    };
    
    if (args.title !== undefined) updates.title = args.title;
    if (args.description !== undefined) updates.description = args.description;
    if (args.isArchived !== undefined) updates.isArchived = args.isArchived;

    await ctx.db.patch(args.id, updates);
  },
});

export const remove = mutation({
  args: { id: v.id("projects") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const project = await ctx.db.get(args.id);
    if (!project || project.userId !== userId) {
      throw new Error("Project not found or unauthorized");
    }

    // Delete all related data
    const videos = await ctx.db
      .query("videos")
      .withIndex("by_project", (q) => q.eq("projectId", args.id))
      .collect();
    
    for (const video of videos) {
      await ctx.db.delete(video._id);
    }

    const agents = await ctx.db
      .query("agents")
      .withIndex("by_project", (q) => q.eq("projectId", args.id))
      .collect();
    
    for (const agent of agents) {
      await ctx.db.delete(agent._id);
    }

    const canvas = await ctx.db
      .query("projectCanvases")
      .withIndex("by_project", (q) => q.eq("projectId", args.id))
      .first();
    
    if (canvas) {
      await ctx.db.delete(canvas._id);
    }

    await ctx.db.delete(args.id);
  },
});


================================================
FILE: convex/schema.ts
================================================
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  users: defineTable({
    name: v.optional(v.string()),
    email: v.optional(v.string()),
    image: v.optional(v.string()),
    tokenIdentifier: v.string(),
  }).index("by_token", ["tokenIdentifier"]),

  projects: defineTable({
    userId: v.string(),
    title: v.string(),
    description: v.optional(v.string()),
    thumbnail: v.optional(v.string()),
    createdAt: v.number(),
    updatedAt: v.number(),
    isArchived: v.boolean(),
  })
    .index("by_user", ["userId"])
    .index("by_updated", ["updatedAt"])
    .index("by_user_archived", ["userId", "isArchived"]),

  videos: defineTable({
    userId: v.string(),
    projectId: v.optional(v.id("projects")),
    title: v.optional(v.string()),
    videoUrl: v.optional(v.string()),
    fileId: v.optional(v.string()),
    storageId: v.optional(v.id("_storage")), // Convex storage ID
    transcription: v.optional(v.string()),
    canvasPosition: v.object({
      x: v.number(),
      y: v.number(),
    }),
    // Video metadata fields
    duration: v.optional(v.number()), // Duration in seconds
    fileSize: v.optional(v.number()), // Size in bytes
    resolution: v.optional(v.object({
      width: v.number(),
      height: v.number(),
    })),
    frameRate: v.optional(v.number()), // FPS
    bitRate: v.optional(v.number()), // Bits per second
    format: v.optional(v.string()), // Video format/container
    codec: v.optional(v.string()), // Video codec
    audioInfo: v.optional(v.object({
      codec: v.string(),
      sampleRate: v.number(),
      channels: v.number(),
      bitRate: v.number(),
    })),
    metadata: v.optional(v.any()), // Additional metadata
    // Transcription status tracking
    transcriptionStatus: v.optional(v.union(
      v.literal("idle"),
      v.literal("processing"),
      v.literal("completed"),
      v.literal("failed")
    )),
    transcriptionError: v.optional(v.string()),
    transcriptionProgress: v.optional(v.string()),
    createdAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_project", ["projectId"])
    .index("by_created", ["createdAt"]),

  agents: defineTable({
    videoId: v.id("videos"),
    userId: v.string(),
    projectId: v.optional(v.id("projects")),
    type: v.union(
      v.literal("title"),
      v.literal("description"),
      v.literal("thumbnail"),
      v.literal("tweets")
    ),
    draft: v.string(),
    thumbnailUrl: v.optional(v.string()),
    thumbnailStorageId: v.optional(v.id("_storage")),
    connections: v.array(v.string()),
    chatHistory: v.array(
      v.object({
        role: v.union(v.literal("user"), v.literal("ai")),
        message: v.string(),
        timestamp: v.number(),
      })
    ),
    canvasPosition: v.object({
      x: v.number(),
      y: v.number(),
    }),
    status: v.union(
      v.literal("idle"),
      v.literal("generating"),
      v.literal("ready"),
      v.literal("error")
    ),
    createdAt: v.number(),
  })
    .index("by_video", ["videoId"])
    .index("by_user", ["userId"])
    .index("by_project", ["projectId"])
    .index("by_type", ["type"]),

  profiles: defineTable({
    userId: v.string(),
    channelName: v.string(),
    contentType: v.string(),
    niche: v.string(),
    links: v.array(v.string()),
    tone: v.optional(v.string()),
    targetAudience: v.optional(v.string()),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"]),

  shares: defineTable({
    shareId: v.string(),
    projectId: v.id("projects"),
    userId: v.string(),
    canvasState: v.object({
      nodes: v.array(v.any()),
      edges: v.array(v.any()),
      viewport: v.optional(v.object({
        x: v.number(),
        y: v.number(),
        zoom: v.number(),
      })),
    }),
    viewCount: v.number(),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_shareId", ["shareId"])
    .index("by_project", ["projectId"])
    .index("by_user", ["userId"]),

  projectCanvases: defineTable({
    userId: v.string(),
    projectId: v.id("projects"),
    nodes: v.array(
      v.object({
        id: v.string(),
        type: v.string(),
        position: v.object({
          x: v.number(),
          y: v.number(),
        }),
        data: v.any(),
      })
    ),
    edges: v.array(
      v.object({
        id: v.string(),
        source: v.string(),
        target: v.string(),
        sourceHandle: v.optional(v.string()),
        targetHandle: v.optional(v.string()),
      })
    ),
    viewport: v.object({
      x: v.number(),
      y: v.number(),
      zoom: v.number(),
    }),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_project", ["projectId"]),
});



================================================
FILE: convex/shares.ts
================================================
import { v } from "convex/values";
import { mutation, query, } from "./_generated/server";
import { Id } from "./_generated/dataModel";

// Create a share link
export const createShareLink = mutation({
  args: {
    projectId: v.id("projects"),
    canvasState: v.object({
      nodes: v.array(v.any()),
      edges: v.array(v.any()),
      viewport: v.optional(v.object({
        x: v.number(),
        y: v.number(),
        zoom: v.number(),
      })),
    }),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    // Verify project ownership
    const project = await ctx.db.get(args.projectId);
    if (!project || project.userId !== userId) {
      throw new Error("Project not found or unauthorized");
    }

    // Generate a unique share ID (8 characters)
    const shareId = Math.random().toString(36).substring(2, 10);

    // Check if share already exists for this project
    const existingShare = await ctx.db
      .query("shares")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .first();

    if (existingShare) {
      // Update existing share
      await ctx.db.patch(existingShare._id, {
        canvasState: args.canvasState,
        updatedAt: Date.now(),
      });
      return existingShare.shareId;
    }

    // Create new share
    await ctx.db.insert("shares", {
      shareId,
      projectId: args.projectId,
      userId,
      canvasState: args.canvasState,
      viewCount: 0,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });

    return shareId;
  },
});

// Get shared canvas by share ID
export const getSharedCanvas = query({
  args: {
    shareId: v.string(),
  },
  handler: async (ctx, args) => {
    const share = await ctx.db
      .query("shares")
      .withIndex("by_shareId", (q) => q.eq("shareId", args.shareId))
      .first();

    if (!share) {
      return null;
    }

    // Get project details
    const project = await ctx.db.get(share.projectId);
    if (!project) {
      return null;
    }

    // Get video from the videos table
    const video = await ctx.db
      .query("videos")
      .withIndex("by_project", (q) => q.eq("projectId", share.projectId))
      .first();
    
    if (!video) {
      return null;
    }

    // Get agents
    const agents = await ctx.db
      .query("agents")
      .withIndex("by_project", (q) => q.eq("projectId", share.projectId))
      .collect();

    return {
      share,
      project: {
        name: project.title, // projects have 'title' not 'name'
        thumbnail: project.thumbnail,
      },
      video: {
        _id: video._id,
        title: video.title || "",
        url: video.videoUrl || "",
        duration: video.duration,
        fileSize: video.fileSize,
        transcription: video.transcription,
      },
      agents: agents.map(agent => ({
        _id: agent._id,
        type: agent.type,
        draft: agent.draft,
        thumbnailUrl: agent.thumbnailUrl,
        status: agent.status,
      })),
    };
  },
});

// Get share link for a project
export const getShareLink = query({
  args: {
    projectId: v.id("projects"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const project = await ctx.db.get(args.projectId);
    if (!project || project.userId !== userId) {
      return null;
    }

    const share = await ctx.db
      .query("shares")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .first();

    return share?.shareId || null;
  },
});

// Increment view count for a share
export const incrementViewCount = mutation({
  args: {
    shareId: v.string(),
  },
  handler: async (ctx, args) => {
    const share = await ctx.db
      .query("shares")
      .withIndex("by_shareId", (q) => q.eq("shareId", args.shareId))
      .first();

    if (share) {
      await ctx.db.patch(share._id, {
        viewCount: (share.viewCount || 0) + 1,
      });
    }
  },
});

// Delete share link
export const deleteShareLink = mutation({
  args: {
    projectId: v.id("projects"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const project = await ctx.db.get(args.projectId);
    if (!project || project.userId !== userId) {
      throw new Error("Project not found or unauthorized");
    }

    const share = await ctx.db
      .query("shares")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .first();

    if (share) {
      await ctx.db.delete(share._id);
    }
  },
});


================================================
FILE: convex/thumbnail.ts
================================================
import { v } from "convex/values";
import { action } from "./_generated/server";
import { api } from "./_generated/api";
import OpenAI, { toFile } from "openai";

export const generateThumbnail = action({
  args: {
    agentType: v.literal("thumbnail"),
    videoId: v.optional(v.id("videos")),
    videoFrames: v.array(
      v.object({
        dataUrl: v.string(),
        timestamp: v.number(),
      })
    ),
    videoData: v.object({
      title: v.optional(v.string()),
      transcription: v.optional(v.string()),
      duration: v.optional(v.number()),
      resolution: v.optional(v.object({
        width: v.number(),
        height: v.number(),
      })),
      format: v.optional(v.string()),
    }),
    connectedAgentOutputs: v.array(
      v.object({
        type: v.string(),
        content: v.string(),
      })
    ),
    profileData: v.optional(
      v.object({
        channelName: v.string(),
        contentType: v.string(),
        niche: v.string(),
        tone: v.optional(v.string()),
        targetAudience: v.optional(v.string()),
      })
    ),
    additionalContext: v.optional(v.string()),
  },
  handler: async (ctx, args): Promise<{ concept: string; imageUrl: string; prompt?: string; storageId?: string }> => {
    console.log("[Thumbnail] Starting thumbnail generation process");
    console.log("[Thumbnail] Args received:", {
      agentType: args.agentType,
      videoId: args.videoId,
      frameCount: args.videoFrames.length,
      hasTranscription: !!args.videoData.transcription,
      hasProfile: !!args.profileData,
      connectedAgentsCount: args.connectedAgentOutputs.length
    });
    
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    // Get OpenAI API key from Convex environment
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      console.error("[Thumbnail] OpenAI API key not configured");
      throw new Error("Thumbnail generation service is not configured. Please contact support.");
    }

    const openai = new OpenAI({ apiKey });

    try {
      // If we have a videoId, fetch the latest video data with transcription
      let videoData = args.videoData;
      if (args.videoId) {
        console.log("[Thumbnail] Fetching fresh video data for ID:", args.videoId);
        const freshVideoData = await ctx.runQuery(api.videos.getWithTranscription, {
          id: args.videoId,
        });
        console.log("[Thumbnail] Fresh video data fetched:", {
          hasTitle: !!freshVideoData?.title,
          hasTranscription: !!freshVideoData?.transcription,
          transcriptionLength: freshVideoData?.transcription?.length || 0
        });
        if (freshVideoData && freshVideoData.transcription) {
          videoData = {
            title: freshVideoData.title || args.videoData.title,
            transcription: freshVideoData.transcription,
          };
        }
      }

      // Validate inputs
      if (!args.videoFrames || args.videoFrames.length === 0) {
        throw new Error("No video frames provided for thumbnail generation.");
      }
      
      // Validate that we have at least one image
      if (!args.videoFrames || args.videoFrames.length === 0) {
        throw new Error("No images provided for thumbnail generation.");
      }

      // Build a comprehensive prompt for thumbnail generation
      console.log("[Thumbnail] Building thumbnail generation prompt");
      
      let thumbnailPrompt = "Create an eye-catching YouTube thumbnail with the following requirements:\n\n";
      
      if (videoData.title) {
        thumbnailPrompt += `Video Title: ${videoData.title}\n`;
      }
      
      if (videoData.transcription) {
        const summary = videoData.transcription.slice(0, 500);
        thumbnailPrompt += `\nVideo Content Summary: ${summary}...\n`;
      }
      
      if (args.connectedAgentOutputs.length > 0) {
        thumbnailPrompt += "\nRelated content:\n";
        args.connectedAgentOutputs.forEach(({ type, content }) => {
          if (type === "title") {
            thumbnailPrompt += `- Title suggestion: ${content}\n`;
          }
        });
      }
      
      if (args.profileData) {
        thumbnailPrompt += `\nChannel Style:\n`;
        thumbnailPrompt += `- ${args.profileData.channelName} (${args.profileData.niche})\n`;
        thumbnailPrompt += `- Content Type: ${args.profileData.contentType}\n`;
        if (args.profileData.tone) {
          thumbnailPrompt += `- Tone: ${args.profileData.tone}\n`;
        }
      }
      
      if (args.additionalContext) {
        thumbnailPrompt += `\nSpecific requirements: ${args.additionalContext}\n`;
      }
      
      thumbnailPrompt += `\nDesign Requirements:\n`;
      thumbnailPrompt += `1. High contrast and vibrant colors\n`;
      thumbnailPrompt += `2. Clear, readable text overlay (3-5 words max)\n`;
      thumbnailPrompt += `3. Emotional facial expressions if applicable\n`;
      thumbnailPrompt += `4. 16:9 aspect ratio optimized for YouTube\n`;
      thumbnailPrompt += `5. Professional quality that stands out in search results\n`;
      
      console.log("[Thumbnail] Prompt created, length:", thumbnailPrompt.length);
      
      // First, analyze the uploaded images with GPT-4 Vision
      console.log("[Thumbnail] Analyzing uploaded images with GPT-4 Vision...");
      console.log("[Thumbnail] Number of input images:", args.videoFrames.length);
      
      const analysisMessages: OpenAI.Chat.ChatCompletionMessageParam[] = [
        {
          role: "system",
          content: "You are an expert YouTube thumbnail designer. Analyze the provided images and create a detailed thumbnail concept that will maximize click-through rates.",
        },
        {
          role: "user",
          content: [
            { type: "text", text: thumbnailPrompt + "\n\nAnalyze these images and describe the perfect YouTube thumbnail based on them. Be specific about visual elements, colors, composition, and text overlay suggestions." },
            ...args.videoFrames.map((frame) => ({
              type: "image_url" as const,
              image_url: {
                url: frame.dataUrl,
                detail: "high" as const,
              },
            })),
          ],
        },
      ];
      
      const analysisResponse = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: analysisMessages,
        max_tokens: 800,
        temperature: 0.7,
      });
      
      const thumbnailConcept = analysisResponse.choices[0].message.content || "";
      console.log("[Thumbnail] Analysis complete. Concept:", thumbnailConcept.substring(0, 200) + "...");
      
      // Now ask GPT-4 to create a very detailed description of what it sees in the images
      console.log("[Thumbnail] Getting detailed visual description...");
      
      const descriptionMessages: OpenAI.Chat.ChatCompletionMessageParam[] = [
        {
          role: "system",
          content: "You are a visual description expert. Describe EXACTLY what you see in these images in extreme detail, including: people's appearance, facial expressions, clothing, poses, backgrounds, objects, colors, lighting, and composition. Be as specific as possible.",
        },
        {
          role: "user",
          content: [
            { type: "text", text: "Describe these images in extreme detail. I need to recreate them as a YouTube thumbnail." },
            ...args.videoFrames.map((frame) => ({
              type: "image_url" as const,
              image_url: {
                url: frame.dataUrl,
                detail: "high" as const,
              },
            })),
          ],
        },
      ];
      
      const descriptionResponse = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: descriptionMessages,
        max_tokens: 1000,
        temperature: 0.3, // Lower temperature for accurate descriptions
      });
      
      const visualDescription = descriptionResponse.choices[0].message.content || "";
      console.log("[Thumbnail] Visual description obtained");
      
      // Extract key elements from the concept - better regex for text overlay
      const textOverlayMatch = thumbnailConcept.match(/text[:\s]*["']([^"']+)["']/i) ||
                             thumbnailConcept.match(/suggested text[:\s]*["']([^"']+)["']/i) ||
                             thumbnailConcept.match(/text overlay[:\s]*["']([^"']+)["']/i) ||
                             thumbnailConcept.match(/["']([^"']{5,40})["'][^"']*(?:text|overlay)/i);
      const textOverlay = textOverlayMatch ? textOverlayMatch[1].trim() : "AMAZING TIPS";
      
      console.log("[Thumbnail] Extracted text overlay:", textOverlay);
      
      // Build a comprehensive prompt for gpt-image-1 that includes video context
      let gptImagePrompt = "Create a YouTube thumbnail based on this video content:\n\n";
      
      // Debug: Log connected agent outputs
      console.log("[Thumbnail] Connected agent outputs:", args.connectedAgentOutputs);
      
      // Add AI-generated video title from connected agents
      const titleFromAgent = args.connectedAgentOutputs.find(output => output.type === "title");
      if (titleFromAgent && titleFromAgent.content && titleFromAgent.content.trim() !== "") {
        console.log("[Thumbnail] Using AI-generated title:", titleFromAgent.content);
        gptImagePrompt += `VIDEO TITLE: ${titleFromAgent.content}\n\n`;
      } else {
        console.log("[Thumbnail] No AI title found in connected agents");
        // Don't include filename as it's not useful for thumbnail generation
      }
      
      // Add transcription summary if available
      if (videoData.transcription) {
        const transcriptSummary = videoData.transcription.slice(0, 300);
        gptImagePrompt += `VIDEO CONTENT: ${transcriptSummary}...\n\n`;
      }
      
      // Add visual description from the uploaded frames
      const shortDescription = visualDescription.length > 400 ? 
        visualDescription.substring(0, 400) + "..." : 
        visualDescription;
      gptImagePrompt += `VISUAL ELEMENTS: ${shortDescription}\n\n`;
      
      // Add design requirements with the extracted text overlay
      gptImagePrompt += "DESIGN REQUIREMENTS:\n";
      gptImagePrompt += `- Main text overlay should say: "${textOverlay}"\n`;
      gptImagePrompt += "- Make the text LARGE and BOLD\n";
      gptImagePrompt += "- Use eye-catching YouTube thumbnail style\n";
      gptImagePrompt += "- High contrast and vibrant colors\n";
      gptImagePrompt += "- Professional quality\n";
      gptImagePrompt += "- 16:9 aspect ratio\n";
      
      // Add channel style if available - ensure it's not cut off
      if (args.profileData) {
        const channelInfo = `${args.profileData.channelName} - ${args.profileData.niche}`;
        gptImagePrompt += `\nCHANNEL STYLE: ${channelInfo}\n`;
        if (args.profileData.contentType) {
          gptImagePrompt += `Content type: ${args.profileData.contentType}\n`;
        }
        if (args.profileData.tone) {
          gptImagePrompt += `Tone: ${args.profileData.tone}\n`;
        }
        if (args.profileData.targetAudience) {
          gptImagePrompt += `Target audience: ${args.profileData.targetAudience}\n`;
        }
      }
      
      // Add any specific context from the user
      if (args.additionalContext) {
        gptImagePrompt += `\nSPECIFIC REQUIREMENTS: ${args.additionalContext}\n`;
      }
      
      // Add other connected agent outputs (descriptions, etc)
      const otherAgentOutputs = args.connectedAgentOutputs
        .filter(output => output.type !== "title" && output.type !== "thumbnail");
      if (otherAgentOutputs.length > 0) {
        gptImagePrompt += "\nOTHER CONTEXT:\n";
        otherAgentOutputs.forEach(output => {
          if (output.type === "description" && output.content) {
            gptImagePrompt += `- Video Description: ${output.content.slice(0, 200)}...\n`;
          }
        });
      }
      
      // Ensure prompt doesn't exceed limit
      if (gptImagePrompt.length > 1000) {
        gptImagePrompt = gptImagePrompt.substring(0, 1000) + "...";
      }
      
      console.log("[Thumbnail] Generating thumbnail with gpt-image-1...");
      console.log("[Thumbnail] Prompt:", gptImagePrompt.substring(0, 200) + "...");
      
      // Convert the first frame to use with image editing
      const firstFrame = args.videoFrames[0];
      if (!firstFrame) {
        throw new Error("No frames available for thumbnail generation");
      }

      // Process all frames as reference images
      const imageFiles = await Promise.all(
        args.videoFrames.slice(0, 3).map(async (frame, index) => {
          const base64Data = frame.dataUrl.split(',')[1];
          const binaryString = atob(base64Data);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          const imageBlob = new Blob([bytes], { type: 'image/png' });
          return toFile(imageBlob, `frame-${index}.png`, {
            type: 'image/png',
          });
        })
      );

      // Use images.edit with the first image as base
      console.log("[Thumbnail] Using images.edit API...");
      const imageResponse = await openai.images.edit({
        model: "gpt-image-1",
        image: imageFiles[0],
        prompt: gptImagePrompt,
        size: "1536x1024",
      });
      
      
      console.log("[Thumbnail] Image generation completed");
      
      // Get the generated image - handle both URL and base64 formats
      const imageData = imageResponse.data?.[0];
      if (!imageData) {
        throw new Error("No image data returned from generation");
      }
      
      let generatedImageUrl: string;
      let storageId: string;
      
      if (imageData.b64_json) {
        // Handle base64 response
        console.log("[Thumbnail] Received base64 image data");
        const base64Data = imageData.b64_json;
        
        // Convert base64 to blob
        const binaryString = atob(base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        const imageBlob = new Blob([bytes], { type: 'image/png' });
        
        // Store in Convex storage
        console.log("[Thumbnail] Storing base64 image in Convex storage...");
        storageId = await ctx.storage.store(imageBlob);
        const url = await ctx.storage.getUrl(storageId);
        
        if (!url) {
          throw new Error("Failed to get URL for stored image");
        }
        generatedImageUrl = url;
        console.log("[Thumbnail] Image stored successfully");
      } else if (imageData.url) {
        // Handle URL response (fallback)
        generatedImageUrl = imageData.url;
        
        // Download and store URL-based image
        console.log("[Thumbnail] Downloading image from URL...");
        const imageResponse2 = await fetch(generatedImageUrl);
        if (!imageResponse2.ok) {
          throw new Error("Failed to download generated image");
        }
        
        const downloadedImageBlob = await imageResponse2.blob();
        console.log("[Thumbnail] Storing URL image in Convex storage...");
        storageId = await ctx.storage.store(downloadedImageBlob);
        const permanentUrl = await ctx.storage.getUrl(storageId);
        
        if (!permanentUrl) {
          throw new Error("Failed to get permanent URL for stored image");
        }
        generatedImageUrl = permanentUrl;
      } else {
        throw new Error("No image URL or base64 data in response");
      }
      
      console.log("[Thumbnail] Final image URL:", generatedImageUrl.substring(0, 100) + "...");
      
      // Combine the concept with generation details
      const fullConcept = `${thumbnailConcept}\n\n=== Generated Thumbnail ===\nText Overlay: "${textOverlay}"\nGeneration Prompt: ${gptImagePrompt}`;
      
      // Return the result with permanent URL
      return {
        concept: fullConcept,
        imageUrl: generatedImageUrl,
        prompt: `=== Original Requirements ===\n${thumbnailPrompt}\n\n=== AI Analysis ===\n${thumbnailConcept}\n\n=== Generation Prompt ===\n${gptImagePrompt}`,
        storageId,
      };
    } catch (error: any) {
      console.error("[Thumbnail] Error generating thumbnail:", error);
      console.error("[Thumbnail] Error type:", error.constructor.name);
      console.error("[Thumbnail] Error message:", error.message);
      console.error("[Thumbnail] Error stack:", error.stack);
      
      if (error.response) {
        console.error("[Thumbnail] API response error:", error.response.data);
      }
      
      throw error;
    }
  },
});





================================================
FILE: convex/thumbnailGPTImage.ts
================================================
import { v } from "convex/values";
import { action } from "./_generated/server";
import { api } from "./_generated/api";
import OpenAI, { toFile } from "openai";

export const generateThumbnailWithGPTImage = action({
  args: {
    agentType: v.literal("thumbnail"),
    videoId: v.optional(v.id("videos")),
    videoFrames: v.array(
      v.object({
        dataUrl: v.string(),
        timestamp: v.number(),
      })
    ),
    videoData: v.object({
      title: v.optional(v.string()),
      transcription: v.optional(v.string()),
      duration: v.optional(v.number()),
      resolution: v.optional(v.object({
        width: v.number(),
        height: v.number(),
      })),
      format: v.optional(v.string()),
    }),
    connectedAgentOutputs: v.array(
      v.object({
        type: v.string(),
        content: v.string(),
      })
    ),
    profileData: v.optional(
      v.object({
        channelName: v.string(),
        contentType: v.string(),
        niche: v.string(),
        tone: v.optional(v.string()),
        targetAudience: v.optional(v.string()),
      })
    ),
    additionalContext: v.optional(v.string()),
  },
  handler: async (ctx, args): Promise<{ concept: string; imageUrl: string; prompt?: string; storageId?: string }> => {
    console.log("[GPT-Image Thumbnail] Starting thumbnail generation process");
    
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error("OpenAI API key not configured");
    }

    const openai = new OpenAI({ apiKey });

    try {
      // Get fresh video data if videoId is provided
      let videoData = args.videoData;
      if (args.videoId) {
        const freshVideoData = await ctx.runQuery(api.videos.getWithTranscription, {
          id: args.videoId,
        });
        if (freshVideoData && freshVideoData.transcription) {
          videoData = {
            title: freshVideoData.title || args.videoData.title,
            transcription: freshVideoData.transcription,
          };
        }
      }

      if (!args.videoFrames || args.videoFrames.length === 0) {
        throw new Error("No video frames provided for thumbnail generation.");
      }

      // Build prompt for thumbnail generation
      let prompt = "Generate a photorealistic image of a YouTube thumbnail on a white background ";
      
      if (videoData.title) {
        prompt += `for a video titled '${videoData.title}' `;
      }
      
      // Add channel branding if available
      if (args.profileData) {
        prompt += `in the style of ${args.profileData.channelName} (${args.profileData.niche} channel) `;
      }
      
      // Add text overlay suggestions from connected agents
      let textOverlay = "";
      args.connectedAgentOutputs.forEach(({ type, content }) => {
        if (type === "title" && content.length < 30) {
          textOverlay = content;
        }
      });
      
      if (textOverlay) {
        prompt += `with bold text overlay saying '${textOverlay}' `;
      }
      
      prompt += "containing all the visual elements from the reference pictures. ";
      prompt += "Make it eye-catching with vibrant colors and high contrast.";
      
      // Limit prompt length
      if (prompt.length > 1000) {
        prompt = prompt.substring(0, 1000);
      }
      
      console.log("[GPT-Image Thumbnail] Generated prompt:", prompt);
      
      // Process all frames into files
      const imageFiles = await Promise.all(
        args.videoFrames.slice(0, 4).map(async (frame, index) => {
          const base64Data = frame.dataUrl.split(',')[1];
          const binaryString = atob(base64Data);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          const imageBlob = new Blob([bytes], { type: 'image/png' });
          return toFile(imageBlob, `frame-${index}.png`, {
            type: 'image/png',
          });
        })
      );
      
      console.log(`[GPT-Image Thumbnail] Processing ${imageFiles.length} images`);
      
      // Use the first image as the base for editing
      const response = await openai.images.edit({
        model: "gpt-image-1",
        image: imageFiles[0],
        prompt,
        size: "1024x1024",
      });

      console.log("[GPT-Image Thumbnail] Response received");
      
      // Get the generated image data
      const imageData = response.data?.[0];
      if (!imageData) {
        throw new Error("No image data returned from generation");
      }
      
      console.log("imageData:", imageData);
      let permanentUrl: string;
      let storageId: string;
      
      if (imageData.b64_json) {
        // Handle base64 response
        console.log("[GPT-Image Thumbnail] Processing base64 image...");
        const base64Data = imageData.b64_json;
        
        // Convert base64 to blob
        const binaryString = atob(base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        const imageBlob = new Blob([bytes], { type: 'image/png' });
        
        // Store in Convex
        storageId = await ctx.storage.store(imageBlob);
        permanentUrl = await ctx.storage.getUrl(storageId) || "";
      } else if (imageData.url) {
        // Handle URL response
        console.log("[GPT-Image Thumbnail] Downloading image from URL...");
        const imageResponse = await fetch(imageData.url);
        if (!imageResponse.ok) {
          throw new Error("Failed to download generated image");
        }
        
        const imageBlob = await imageResponse.blob();
        storageId = await ctx.storage.store(imageBlob);
        permanentUrl = await ctx.storage.getUrl(storageId) || "";
      } else {
        throw new Error("No image URL or base64 data in response");
      }
      
      if (!permanentUrl) {
        throw new Error("Failed to get permanent URL for stored image");
      }
      
      console.log("[GPT-Image Thumbnail] Image stored successfully");
      
      const concept = `Generated YouTube thumbnail using gpt-image-1 model.\nText overlay: "${textOverlay || 'None'}"`;
      
      return {
        concept,
        imageUrl: permanentUrl,
        prompt,
        storageId,
      };
    } catch (error: any) {
      console.error("[GPT-Image Thumbnail] Error:", error);
      throw error;
    }
  },
});


================================================
FILE: convex/thumbnailRefine.ts
================================================
import { v } from "convex/values";
import { action } from "./_generated/server";
import { api } from "./_generated/api";
import OpenAI, { toFile } from "openai";

export const refineThumbnail = action({
  args: {
    agentId: v.id("agents"),
    currentThumbnailUrl: v.string(),
    userMessage: v.string(),
    videoId: v.optional(v.id("videos")),
    profileData: v.optional(
      v.object({
        channelName: v.string(),
        contentType: v.string(),
        niche: v.string(),
        tone: v.optional(v.string()),
        targetAudience: v.optional(v.string()),
      })
    ),
  },
  handler: async (ctx, args): Promise<{ 
    concept: string; 
    imageUrl: string; 
    prompt?: string;
    storageId?: string;
  }> => {
    console.log("[Thumbnail Refine] Starting thumbnail refinement");
    console.log("[Thumbnail Refine] User message:", args.userMessage);
    console.log("[Thumbnail Refine] Current thumbnail URL:", args.currentThumbnailUrl);
    
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error("OpenAI API key not configured");
    }

    const openai = new OpenAI({ apiKey });

    try {
      // Get video data if available
      let videoData: any = {};
      if (args.videoId) {
        const freshVideoData = await ctx.runQuery(api.videos.getWithTranscription, {
          id: args.videoId,
        });
        if (freshVideoData) {
          videoData = freshVideoData;
        }
      }

      // First, analyze the current thumbnail with GPT-4 Vision
      console.log("[Thumbnail Refine] Analyzing current thumbnail...");
      
      const analysisMessages: OpenAI.Chat.ChatCompletionMessageParam[] = [
        {
          role: "system",
          content: "You are an expert YouTube thumbnail designer. Analyze the current thumbnail and understand what needs to be changed based on the user's feedback.",
        },
        {
          role: "user",
          content: [
            { 
              type: "text", 
              text: `Current thumbnail analysis needed. User feedback: "${args.userMessage}"\n\nAnalyze this thumbnail and describe:\n1. What text overlay is currently shown\n2. The main visual elements\n3. The color scheme and style\n4. What specific changes are needed based on the user's feedback` 
            },
            {
              type: "image_url" as const,
              image_url: {
                url: args.currentThumbnailUrl,
                detail: "high" as const,
              },
            },
          ],
        },
      ];
      
      const analysisResponse = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: analysisMessages,
        max_tokens: 500,
      });
      
      const currentAnalysis = analysisResponse.choices[0].message.content || "";
      console.log("[Thumbnail Refine] Current thumbnail analysis:", currentAnalysis);

      // Download the current thumbnail to use as base
      console.log("[Thumbnail Refine] Downloading current thumbnail...");
      let imageFile;
      
      try {
        const imageResponse = await fetch(args.currentThumbnailUrl);
        if (!imageResponse.ok) {
          throw new Error("Failed to download current thumbnail");
        }
        
        const imageBlob = await imageResponse.blob();
        console.log("[Thumbnail Refine] Image blob size:", imageBlob.size);
        
        // If image is too large, we might need to resize it
        if (imageBlob.size > 4 * 1024 * 1024) { // 4MB limit
          console.warn("[Thumbnail Refine] Image is large, may cause issues");
        }
        
        // Create file directly from blob
        imageFile = await toFile(imageBlob, 'current-thumbnail.png', {
          type: imageBlob.type || 'image/png',
        });
      } catch (downloadError) {
        console.error("[Thumbnail Refine] Error downloading image:", downloadError);
        throw new Error("Failed to process current thumbnail. Please try generating a new thumbnail instead.");
      }

      // Build refinement prompt
      let refinementPrompt = "Edit this YouTube thumbnail based on user feedback:\n\n";
      
      refinementPrompt += `USER FEEDBACK: ${args.userMessage}\n\n`;
      refinementPrompt += `CURRENT THUMBNAIL ANALYSIS:\n${currentAnalysis}\n\n`;
      
      if (videoData.title) {
        refinementPrompt += `VIDEO TITLE: ${videoData.title}\n\n`;
      }
      
      refinementPrompt += "REQUIREMENTS:\n";
      refinementPrompt += "- Apply the user's requested changes while keeping what works\n";
      refinementPrompt += "- Maintain YouTube thumbnail best practices\n";
      refinementPrompt += "- Keep text large, bold, and readable\n";
      refinementPrompt += "- Ensure high contrast and vibrant colors\n";
      
      if (args.profileData) {
        refinementPrompt += `\nCHANNEL STYLE: ${args.profileData.channelName} - ${args.profileData.niche}\n`;
      }

      console.log("[Thumbnail Refine] Refinement prompt:", refinementPrompt.substring(0, 200) + "...");

      // Use images.edit to refine the thumbnail
      console.log("[Thumbnail Refine] Generating refined thumbnail...");
      let imageEditResponse;
      
      try {
        imageEditResponse = await openai.images.edit({
          model: "gpt-image-1",
          image: imageFile,
          prompt: refinementPrompt,
          size: "1536x1024",
        });
      } catch (apiError: any) {
        console.error("[Thumbnail Refine] OpenAI API error:", apiError);
        console.log("[Thumbnail Refine] Falling back to generation instead of edit");
        
        // Fallback: Generate a new image based on the analysis and user feedback
        const fallbackPrompt = `Create a YouTube thumbnail that incorporates these changes:\n\n${refinementPrompt}\n\nBased on analysis of previous thumbnail:\n${currentAnalysis}`;
        
        imageEditResponse = await openai.images.generate({
          model: "dall-e-3",
          prompt: fallbackPrompt,
          size: "1792x1024",
          quality: "hd",
          n: 1,
          style: "vivid",
        });
      }

      // Handle the response
      const imageData = imageEditResponse.data?.[0];
      if (!imageData) {
        throw new Error("No image data returned from refinement");
      }

      let finalImageUrl: string;
      let storageId: string;

      if (imageData.b64_json) {
        // Handle base64 response
        console.log("[Thumbnail Refine] Processing base64 image...");
        const base64Data = imageData.b64_json;
        
        // Convert base64 to blob
        const binaryString = atob(base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        const refinedImageBlob = new Blob([bytes], { type: 'image/png' });
        
        // Store in Convex
        storageId = await ctx.storage.store(refinedImageBlob);
        const url = await ctx.storage.getUrl(storageId);
        if (!url) {
          throw new Error("Failed to get URL for stored refined image");
        }
        finalImageUrl = url;
      } else if (imageData.url) {
        // Handle URL response
        console.log("[Thumbnail Refine] Downloading refined image from URL...");
        const downloadResponse = await fetch(imageData.url);
        if (!downloadResponse.ok) {
          throw new Error("Failed to download refined image");
        }
        
        const refinedBlob = await downloadResponse.blob();
        storageId = await ctx.storage.store(refinedBlob);
        const url = await ctx.storage.getUrl(storageId);
        if (!url) {
          throw new Error("Failed to get URL for stored refined image");
        }
        finalImageUrl = url;
      } else {
        throw new Error("No image URL or base64 data in refinement response");
      }

      console.log("[Thumbnail Refine] Refinement completed successfully");

      // Create concept description
      const concept = `Refined thumbnail based on user feedback: "${args.userMessage}"\n\nChanges applied:\n${currentAnalysis}`;

      return {
        concept,
        imageUrl: finalImageUrl,
        prompt: refinementPrompt,
        storageId,
      };
    } catch (error: any) {
      console.error("[Thumbnail Refine] Error:", error);
      throw error;
    }
  },
});


================================================
FILE: convex/transcription.ts
================================================
"use node"
import { v } from "convex/values";
import { action } from "./_generated/server";
import { api } from "./_generated/api";
import { ElevenLabsClient } from "@elevenlabs/elevenlabs-js";

// Action to transcribe video/audio using ElevenLabs (supports up to 1GB files!)
export const transcribeVideoElevenLabs = action({
  args: {
    videoId: v.id("videos"),
    storageId: v.id("_storage"),
    fileType: v.optional(v.string()), // 'video' or 'audio'
    fileName: v.optional(v.string()), // Original file name for content type detection
  },
  handler: async (ctx, args): Promise<{ success: boolean; transcription: string; service?: string }> => {
    console.log("üéôÔ∏è ElevenLabs transcription started", {
      videoId: args.videoId,
      storageId: args.storageId,
      fileType: args.fileType,
      fileName: args.fileName
    });

    // Skip auth check for internal actions (background jobs)
    // The auth was already checked when scheduling the job
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      console.log("‚ö†Ô∏è No user identity - running from internal action (this is ok)");
    }

    // Get ElevenLabs API key from Convex environment
    const apiKey = process.env.ELEVENLABS_API_KEY;
    console.log("üîë ElevenLabs API key status:", apiKey ? "Found" : "Not found");

    if (!apiKey) {
      throw new Error("ElevenLabs API key not configured. Please add ELEVENLABS_API_KEY to your Convex environment variables.");
    }

    try {
      // Update status to show we're starting
      await ctx.runMutation(api.videos.updateTranscriptionStatus, {
        videoId: args.videoId,
        status: "processing",
        progress: "Starting transcription...",
      });


      // For smaller files, continue with direct download approach
      const fileUrl = await ctx.storage.getUrl(args.storageId);
      console.log("üìÅ Storage URL retrieved:", fileUrl ? "Success" : "Failed");

      if (!fileUrl) {
        throw new Error("Could not retrieve file URL from storage. The file may have been deleted.");
      }

      // Use ElevenLabs cloud_storage_url feature instead of downloading
      console.log("üåê Starting ElevenLabs transcription with cloud URL");
      console.log("üìç File URL:", fileUrl);
      
      // Quick validation that the URL is accessible
      try {
        const fetch = (await import('node-fetch')).default;
        const headResponse = await fetch(fileUrl, { method: 'HEAD' });
        if (!headResponse.ok) {
          console.error("‚ùå File URL not accessible:", headResponse.status);
          throw new Error(`File URL is not accessible (${headResponse.status}). The file may have been deleted.`);
        }
        const contentLength = headResponse.headers.get('content-length');
        if (contentLength) {
          const sizeMB = parseInt(contentLength) / (1024 * 1024);
          console.log(`‚úÖ File URL is accessible. Size: ${sizeMB.toFixed(2)}MB`);
        }
      } catch (error: any) {
        console.error("‚ùå Failed to validate file URL:", error);
        throw new Error("Could not validate file accessibility. " + error.message);
      }
      
      // Update progress
      await ctx.runMutation(api.videos.updateTranscriptionStatus, {
        videoId: args.videoId,
        status: "processing",
        progress: "Sending file URL to ElevenLabs...",
      });

      // Call ElevenLabs Speech-to-Text API with cloud URL
      console.log("üöÄ Calling ElevenLabs API with cloud URL...");
      console.log("üîê Using API key:", apiKey.substring(0, 10) + "...");

      // Update progress
      await ctx.runMutation(api.videos.updateTranscriptionStatus, {
        videoId: args.videoId,
        status: "processing",
        progress: "Processing with ElevenLabs Speech-to-Text API...",
      });

      // Create JSON body with cloud_storage_url
      const requestBody = {
        cloud_storage_url: fileUrl,
        model_id: 'scribe_v1',
      };
      
      console.log(`üìé Request details:`, {
        cloud_storage_url: fileUrl,
        model_id: 'scribe_v1',
        fileName: args.fileName,
        fileType: args.fileType,
        requestBody: requestBody,
      });

      // Make direct API call using cloud_storage_url
      const fetch = (await import('node-fetch')).default;
      const response = await fetch('https://api.elevenlabs.io/v1/speech-to-text', {
        method: 'POST',
        headers: {
          'Xi-Api-Key': apiKey,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorText = await response.text();
        let errorMessage = `ElevenLabs API error (${response.status})`;
        
        console.error("‚ùå ElevenLabs API error response:", {
          status: response.status,
          statusText: response.statusText,
          errorText: errorText,
          headers: response.headers,
        });
        
        try {
          const errorJson = JSON.parse(errorText);
          if (errorJson.detail) {
            errorMessage = errorJson.detail;
          } else if (typeof errorJson === 'object' && errorJson.message) {
            errorMessage = errorJson.message;
          }
          console.error("‚ùå Parsed error details:", errorJson);
        } catch (parseError) {
          console.error("‚ùå Failed to parse error response:", parseError);
          errorMessage = errorText || errorMessage;
        }
        
        // Provide user-friendly error messages
        if (response.status === 400) {
          if (errorMessage.includes("parsing the body") || errorMessage.includes("Invalid file format")) {
            errorMessage = "File format not supported. Please ensure your file is a valid video or audio file.";
          } else if (errorMessage.includes("cloud_storage_url")) {
            errorMessage = "Could not access the file URL. The file may not be publicly accessible.";
          } else if (errorMessage.includes("model_id")) {
            errorMessage = "Transcription model configuration error. Please try again.";
          }
        } else if (response.status === 401) {
          errorMessage = "ElevenLabs API authentication failed. Please check your API key.";
        } else if (response.status === 413) {
          errorMessage = "File is too large. ElevenLabs supports files up to 1GB.";
        } else if (response.status === 429) {
          errorMessage = "Rate limit exceeded. Please try again in a few moments.";
        } else if (response.status === 500) {
          errorMessage = "ElevenLabs service error. Please try again later.";
        }
        
        throw new Error(errorMessage);
      }

      const elevenLabsResponse = await response.json() as {
        text: string;
        language_code: string;
        language_probability: number;
        words: { type: string }[];
      };

      console.log("‚úÖ ElevenLabs response received:", JSON.stringify(elevenLabsResponse, null, 2));

      // The SDK returns the response directly, not a fetch response
      const transcriptionText = elevenLabsResponse.text || "";
      
      // Log additional details if available
      if (elevenLabsResponse.language_code) {
        console.log(`üåê Detected language: ${elevenLabsResponse.language_code} (confidence: ${elevenLabsResponse.language_probability || 'N/A'})`);
      }
      
      if (elevenLabsResponse.words && elevenLabsResponse.words.length > 0) {
        console.log(`üìä Word count: ${elevenLabsResponse.words.filter((w: any) => w.type === 'word').length} words`);
      }

      // Update progress
      await ctx.runMutation(api.videos.updateTranscriptionStatus, {
        videoId: args.videoId,
        status: "processing",
        progress: "Processing transcription results...",
      });

      // Log transcription result for debugging
      console.log(`üìù Transcription text found. Length: ${transcriptionText.length} characters`);
      console.log(`üìÑ First 200 chars: "${transcriptionText.substring(0, 200)}..."`);

      if (!transcriptionText || transcriptionText.length === 0) {
        console.error("‚ö†Ô∏è No transcription text found in response!");
        console.error("Response object keys:", Object.keys(elevenLabsResponse));
        throw new Error("No speech detected in the file. Please ensure your video/audio contains clear speech.");
      }

      // Basic quality check
      if (transcriptionText.length < 50) {
        console.warn("Transcription seems too short, might be an issue with audio quality");
      }

      // Update the video with transcription
      await ctx.runMutation(api.videos.updateVideoTranscription, {
        videoId: args.videoId,
        transcription: transcriptionText,
      });

      return { success: true, transcription: transcriptionText, service: 'elevenlabs' };
    } catch (error: any) {
      console.error("‚ùå ElevenLabs transcription error:", error);
      console.error("Full error details:", error);
      
      // Update status to failed with user-friendly error message
      await ctx.runMutation(api.videos.updateTranscriptionStatus, {
        videoId: args.videoId,
        status: "failed",
        error: error.message || "Transcription failed. Please try again.",
      });
      
      throw error; // Re-throw the error
    }
  },
});

// Main transcription action - just use ElevenLabs
export const transcribeVideo = action({
  args: {
    videoId: v.id("videos"),
    storageId: v.id("_storage"),
    fileType: v.optional(v.string()), // 'video' or 'audio'
    fileName: v.optional(v.string()), // Pass through fileName
  },
  handler: async (ctx, args): Promise<{ success: boolean; transcription: string; service?: string }> => {
    // Just redirect to ElevenLabs
    return ctx.runAction(api.transcription.transcribeVideoElevenLabs, args);
  },
});




================================================
FILE: convex/tsconfig.json
================================================
{
  /* This TypeScript project config describes the environment that
   * Convex functions run in and is used to typecheck them.
   * You can modify it, but some settings are required to use Convex.
   */
  "compilerOptions": {
    /* These settings are not required by Convex and can be modified. */
    "allowJs": true,
    "strict": true,
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,

    /* These compiler options are required by Convex */
    "target": "ESNext",
    "lib": ["ES2021", "dom"],
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["./**/*"],
  "exclude": ["./_generated"]
}



================================================
FILE: convex/users.ts
================================================
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";

export const findUserByToken = query({
  args: { tokenIdentifier: v.string() },
  handler: async (ctx, args) => {
    // Get the user's identity from the auth context
    const identity = await ctx.auth.getUserIdentity();

    if (!identity) {
      return null;
    }

    // Check if we've already stored this identity before
    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.subject))
      .unique();

    if (user !== null) {
      return user;
    }

    return null;
  },
});

export const upsertUser = mutation({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();

    if (!identity) {
      return null;
    }

    // Check if user exists
    const existingUser = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.subject))
      .unique();

    if (existingUser) {
      // Update if needed
      if (
        existingUser.name !== identity.name ||
        existingUser.email !== identity.email
      ) {
        await ctx.db.patch(existingUser._id, {
          name: identity.name,
          email: identity.email,
        });
      }
      return existingUser;
    }

    // Create new user
    const userId = await ctx.db.insert("users", {
      name: identity.name,
      email: identity.email,
      tokenIdentifier: identity.subject,
    });

    return await ctx.db.get(userId);
  },
});



================================================
FILE: convex/videoJobs.ts
================================================
import { v } from "convex/values";
import { action, internalAction, mutation, internalMutation } from "./_generated/server";
import { internal, api } from "./_generated/api";


// Schedule transcription job
export const scheduleTranscription = mutation({
  args: {
    videoId: v.id("videos"),
    storageId: v.id("_storage"),
    fileType: v.optional(v.string()),
    fileSize: v.optional(v.number()), // File size in bytes
    fileName: v.optional(v.string()), // File name for R2 upload
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    
    console.log("Scheduling transcription for video:", args.videoId);
    
    // Update video status to processing
    await ctx.db.patch(args.videoId, {
      transcriptionStatus: "processing",
    });
    
    console.log("Updated video status to processing");
    
    // Schedule direct transcription with Convex storage
    await ctx.scheduler.runAfter(0, internal.videoJobs.transcribeInBackground, args);
    
    console.log("Scheduled background transcription job");
    
    return { scheduled: true };
  },
});

// Internal action that runs in the background
export const transcribeInBackground = internalAction({
  args: {
    videoId: v.id("videos"),
    storageId: v.id("_storage"),
    fileType: v.optional(v.string()),
    fileName: v.optional(v.string()),
    fileSize: v.optional(v.number()),
  },
  handler: async (ctx, args): Promise<{ success: boolean; transcription: string; service?: string } | void> => {
    console.log("üé¨ Background transcription started for video:", args.videoId);
    console.log("üìã Storage ID:", args.storageId);
    console.log("üìã File type:", args.fileType);
    console.log("üìã File name:", args.fileName);
    
    try {
      console.log("üöÄ Calling ElevenLabs transcription action...");
      const result = await ctx.runAction(api.transcription.transcribeVideoElevenLabs, {
        videoId: args.videoId,
        storageId: args.storageId,
        fileType: args.fileType,
        fileName: args.fileName,
      });
      console.log("‚úÖ ElevenLabs transcription completed successfully:", result);
      
      if (!result) {
        throw new Error("Transcription returned no result");
      }
      
      return result;
    } catch (error: any) {
      console.error("‚ùå Transcription failed:", error.message);
      console.error("Full error:", error);
      
      // Mark as failed
      await ctx.runMutation(internal.videoJobs.markTranscriptionFailed, {
        videoId: args.videoId,
        error: error.message || "Transcription failed",
      });
      
      throw error;
    }
  },
});

// Internal mutation to update transcription
export const updateTranscription = internalMutation({
  args: {
    videoId: v.id("videos"),
    transcription: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.videoId, {
      transcription: args.transcription,
      transcriptionStatus: "completed",
    });
  },
});

// Internal mutation to mark transcription as failed
export const markTranscriptionFailed = internalMutation({
  args: {
    videoId: v.id("videos"),
    error: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.videoId, {
      transcriptionStatus: "failed",
      transcriptionError: args.error,
    });
    console.error(`Transcription failed for video ${args.videoId}: ${args.error}`);
  },
});



// Schedule thumbnail generation
export const scheduleThumbnailGeneration = mutation({
  args: {
    videoId: v.id("videos"),
    videoTitle: v.string(),
    frames: v.array(v.object({
      dataUrl: v.string(),
      timestamp: v.number(),
    })),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    
    // Get video metadata and profile for context
    const video = await ctx.db.get(args.videoId);
    if (!video) throw new Error("Video not found");
    
    // Schedule thumbnail generation to run in background
    await ctx.scheduler.runAfter(0, internal.videoJobs.generateThumbnailInBackground, {
      videoId: args.videoId,
      videoTitle: args.videoTitle,
      frames: args.frames,
      videoData: {
        title: video.title,
        transcription: video.transcription,
        duration: video.duration,
      },
    });
    
    return { scheduled: true };
  },
});

// Internal action for thumbnail generation
export const generateThumbnailInBackground = internalAction({
  args: {
    videoId: v.id("videos"),
    videoTitle: v.string(),
    frames: v.array(v.object({
      dataUrl: v.string(),
      timestamp: v.number(),
    })),
    videoData: v.object({
      title: v.optional(v.string()),
      transcription: v.optional(v.string()),
      duration: v.optional(v.number()),
    }),
  },
  handler: async (ctx, args) => {
    // Call the existing thumbnail generation action with correct args
    await ctx.runAction(api.thumbnail.generateThumbnail, {
      agentType: "thumbnail" as const,
      videoId: args.videoId,
      videoFrames: args.frames,
      videoData: args.videoData,
      connectedAgentOutputs: [],
      profileData: undefined,
    });
  },
});


================================================
FILE: convex/videos.ts
================================================
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

export const create = mutation({
  args: {
    projectId: v.id("projects"),
    title: v.optional(v.string()),
    videoUrl: v.optional(v.string()),
    fileId: v.optional(v.string()),
    storageId: v.optional(v.id("_storage")),
    canvasPosition: v.object({
      x: v.number(),
      y: v.number(),
    }),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    // If we have a storageId, get the URL from Convex storage
    let videoUrl = args.videoUrl;
    if (args.storageId) {
      const url = await ctx.storage.getUrl(args.storageId);
      if (url) {
        videoUrl = url;
      }
    }

    const videoId = await ctx.db.insert("videos", {
      userId,
      projectId: args.projectId,
      title: args.title,
      videoUrl,
      fileId: args.fileId || args.storageId,
      canvasPosition: args.canvasPosition,
      transcriptionStatus: "idle",
      createdAt: Date.now(),
    });
    
    // Return the created video with its URL
    const video = await ctx.db.get(videoId);
    return video;
  },
});

export const update = mutation({
  args: {
    id: v.id("videos"),
    title: v.optional(v.string()),
    transcription: v.optional(v.string()),
    canvasPosition: v.optional(v.object({
      x: v.number(),
      y: v.number(),
    })),
    clearTranscription: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const video = await ctx.db.get(args.id);
    if (!video || video.userId !== userId) {
      throw new Error("Video not found or unauthorized");
    }

    const { id, clearTranscription, ...updates } = args;
    
    // If clearTranscription is true, clear the transcription and reset status
    if (clearTranscription) {
      await ctx.db.patch(args.id, {
        transcription: undefined,
        transcriptionStatus: "idle",
        transcriptionError: undefined,
      });
    } else {
      await ctx.db.patch(args.id, updates);
    }
  },
});

// New mutation to update video metadata
export const updateMetadata = mutation({
  args: {
    id: v.id("videos"),
    duration: v.optional(v.number()),
    fileSize: v.optional(v.number()),
    resolution: v.optional(v.object({
      width: v.number(),
      height: v.number(),
    })),
    frameRate: v.optional(v.number()),
    bitRate: v.optional(v.number()),
    format: v.optional(v.string()),
    codec: v.optional(v.string()),
    audioInfo: v.optional(v.object({
      codec: v.string(),
      sampleRate: v.number(),
      channels: v.number(),
      bitRate: v.number(),
    })),
    metadata: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const video = await ctx.db.get(args.id);
    if (!video || video.userId !== userId) {
      throw new Error("Video not found or unauthorized");
    }

    const { id, ...metadata } = args;
    await ctx.db.patch(args.id, metadata);
    
    return await ctx.db.get(args.id);
  },
});

export const getByUser = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];
    const userId = identity.subject;

    return await ctx.db
      .query("videos")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .order("desc")
      .collect();
  },
});

export const getByProject = query({
  args: { projectId: v.id("projects") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];
    const userId = identity.subject;

    // Verify project ownership
    const project = await ctx.db.get(args.projectId);
    if (!project || project.userId !== userId) {
      return [];
    }

    return await ctx.db
      .query("videos")
      .withIndex("by_project", (q) => q.eq("projectId", args.projectId))
      .collect();
  },
});

export const getById = query({
  args: { id: v.id("videos") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const video = await ctx.db.get(args.id);
    if (!video || video.userId !== userId) {
      throw new Error("Video not found or unauthorized");
    }

    return video;
  },
});

// New query to get video with transcription for AI generation
export const getWithTranscription = query({
  args: { id: v.id("videos") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;
    const userId = identity.subject;

    const video = await ctx.db.get(args.id);
    if (!video || video.userId !== userId) {
      return null;
    }

    return {
      title: video.title,
      transcription: video.transcription,
    };
  },
});

export const remove = mutation({
  args: { id: v.id("videos") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");
    const userId = identity.subject;

    const video = await ctx.db.get(args.id);
    if (!video || video.userId !== userId) {
      throw new Error("Video not found or unauthorized");
    }

    // Delete associated agents
    const agents = await ctx.db
      .query("agents")
      .withIndex("by_video", (q) => q.eq("videoId", args.id))
      .collect();
    
    for (const agent of agents) {
      await ctx.db.delete(agent._id);
    }

    await ctx.db.delete(args.id);
  },
});

// Mutation to update video transcription (moved from transcription.ts)
export const updateVideoTranscription = mutation({
  args: {
    videoId: v.id("videos"),
    transcription: v.string(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.videoId, {
      transcription: args.transcription,
      transcriptionStatus: "completed",
      transcriptionError: undefined,
    });
  },
});

// Mutation to update transcription status
export const updateTranscriptionStatus = mutation({
  args: {
    videoId: v.id("videos"),
    status: v.union(v.literal("idle"), v.literal("processing"), v.literal("completed"), v.literal("failed")),
    error: v.optional(v.string()),
    progress: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const updates: any = {
      transcriptionStatus: args.status,
    };
    
    if (args.error) {
      updates.transcriptionError = args.error;
    }
    
    if (args.progress) {
      updates.transcriptionProgress = args.progress;
    }
    
    await ctx.db.patch(args.videoId, updates);
  },
});

// Mutation to update video storage ID
export const updateVideoStorageId = mutation({
  args: {
    id: v.id("videos"),
    storageId: v.id("_storage"),
  },
  handler: async (ctx, args) => {
    // Get the URL from Convex storage
    const videoUrl = await ctx.storage.getUrl(args.storageId);
    
    await ctx.db.patch(args.id, {
      storageId: args.storageId,
      videoUrl: videoUrl || undefined,
      fileId: args.storageId, // Also update fileId to match storageId
    });
  },
});



================================================
FILE: convex/_generated/api.d.ts
================================================
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type * as agents from "../agents.js";
import type * as ai from "../ai.js";
import type * as aiHackathon from "../aiHackathon.js";
import type * as canvas from "../canvas.js";
import type * as chat from "../chat.js";
import type * as files from "../files.js";
import type * as http from "../http.js";
import type * as profiles from "../profiles.js";
import type * as projects from "../projects.js";
import type * as shares from "../shares.js";
import type * as thumbnail from "../thumbnail.js";
import type * as thumbnailGPTImage from "../thumbnailGPTImage.js";
import type * as thumbnailRefine from "../thumbnailRefine.js";
import type * as transcription from "../transcription.js";
import type * as users from "../users.js";
import type * as videoJobs from "../videoJobs.js";
import type * as videos from "../videos.js";

import type {
  ApiFromModules,
  FilterApi,
  FunctionReference,
} from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
declare const fullApi: ApiFromModules<{
  agents: typeof agents;
  ai: typeof ai;
  aiHackathon: typeof aiHackathon;
  canvas: typeof canvas;
  chat: typeof chat;
  files: typeof files;
  http: typeof http;
  profiles: typeof profiles;
  projects: typeof projects;
  shares: typeof shares;
  thumbnail: typeof thumbnail;
  thumbnailGPTImage: typeof thumbnailGPTImage;
  thumbnailRefine: typeof thumbnailRefine;
  transcription: typeof transcription;
  users: typeof users;
  videoJobs: typeof videoJobs;
  videos: typeof videos;
}>;
declare const fullApiWithMounts: typeof fullApi;

export declare const api: FilterApi<
  typeof fullApiWithMounts,
  FunctionReference<any, "public">
>;
export declare const internal: FilterApi<
  typeof fullApiWithMounts,
  FunctionReference<any, "internal">
>;

export declare const components: {
  polar: {
    lib: {
      createProduct: FunctionReference<
        "mutation",
        "internal",
        {
          product: {
            createdAt: string;
            description: string | null;
            id: string;
            isArchived: boolean;
            isRecurring: boolean;
            medias: Array<{
              checksumEtag: string | null;
              checksumSha256Base64: string | null;
              checksumSha256Hex: string | null;
              createdAt: string;
              id: string;
              isUploaded: boolean;
              lastModifiedAt: string | null;
              mimeType: string;
              name: string;
              organizationId: string;
              path: string;
              publicUrl: string;
              service?: string;
              size: number;
              sizeReadable: string;
              storageVersion: string | null;
              version: string | null;
            }>;
            metadata?: Record<string, any>;
            modifiedAt: string | null;
            name: string;
            organizationId: string;
            prices: Array<{
              amountType?: string;
              createdAt: string;
              id: string;
              isArchived: boolean;
              modifiedAt: string | null;
              priceAmount?: number;
              priceCurrency?: string;
              productId: string;
              recurringInterval?: "month" | "year" | null;
              type?: string;
            }>;
            recurringInterval?: "month" | "year" | null;
          };
        },
        any
      >;
      createSubscription: FunctionReference<
        "mutation",
        "internal",
        {
          subscription: {
            amount: number | null;
            cancelAtPeriodEnd: boolean;
            checkoutId: string | null;
            createdAt: string;
            currency: string | null;
            currentPeriodEnd: string | null;
            currentPeriodStart: string;
            customerCancellationComment?: string | null;
            customerCancellationReason?: string | null;
            customerId: string;
            endedAt: string | null;
            id: string;
            metadata: Record<string, any>;
            modifiedAt: string | null;
            priceId?: string;
            productId: string;
            recurringInterval: "month" | "year" | null;
            startedAt: string | null;
            status: string;
          };
        },
        any
      >;
      getCurrentSubscription: FunctionReference<
        "query",
        "internal",
        { userId: string },
        {
          amount: number | null;
          cancelAtPeriodEnd: boolean;
          checkoutId: string | null;
          createdAt: string;
          currency: string | null;
          currentPeriodEnd: string | null;
          currentPeriodStart: string;
          customerCancellationComment?: string | null;
          customerCancellationReason?: string | null;
          customerId: string;
          endedAt: string | null;
          id: string;
          metadata: Record<string, any>;
          modifiedAt: string | null;
          priceId?: string;
          product: {
            createdAt: string;
            description: string | null;
            id: string;
            isArchived: boolean;
            isRecurring: boolean;
            medias: Array<{
              checksumEtag: string | null;
              checksumSha256Base64: string | null;
              checksumSha256Hex: string | null;
              createdAt: string;
              id: string;
              isUploaded: boolean;
              lastModifiedAt: string | null;
              mimeType: string;
              name: string;
              organizationId: string;
              path: string;
              publicUrl: string;
              service?: string;
              size: number;
              sizeReadable: string;
              storageVersion: string | null;
              version: string | null;
            }>;
            metadata?: Record<string, any>;
            modifiedAt: string | null;
            name: string;
            organizationId: string;
            prices: Array<{
              amountType?: string;
              createdAt: string;
              id: string;
              isArchived: boolean;
              modifiedAt: string | null;
              priceAmount?: number;
              priceCurrency?: string;
              productId: string;
              recurringInterval?: "month" | "year" | null;
              type?: string;
            }>;
            recurringInterval?: "month" | "year" | null;
          };
          productId: string;
          recurringInterval: "month" | "year" | null;
          startedAt: string | null;
          status: string;
        } | null
      >;
      getCustomerByUserId: FunctionReference<
        "query",
        "internal",
        { userId: string },
        { id: string; metadata?: Record<string, any>; userId: string } | null
      >;
      getProduct: FunctionReference<
        "query",
        "internal",
        { id: string },
        {
          createdAt: string;
          description: string | null;
          id: string;
          isArchived: boolean;
          isRecurring: boolean;
          medias: Array<{
            checksumEtag: string | null;
            checksumSha256Base64: string | null;
            checksumSha256Hex: string | null;
            createdAt: string;
            id: string;
            isUploaded: boolean;
            lastModifiedAt: string | null;
            mimeType: string;
            name: string;
            organizationId: string;
            path: string;
            publicUrl: string;
            service?: string;
            size: number;
            sizeReadable: string;
            storageVersion: string | null;
            version: string | null;
          }>;
          metadata?: Record<string, any>;
          modifiedAt: string | null;
          name: string;
          organizationId: string;
          prices: Array<{
            amountType?: string;
            createdAt: string;
            id: string;
            isArchived: boolean;
            modifiedAt: string | null;
            priceAmount?: number;
            priceCurrency?: string;
            productId: string;
            recurringInterval?: "month" | "year" | null;
            type?: string;
          }>;
          recurringInterval?: "month" | "year" | null;
        } | null
      >;
      getSubscription: FunctionReference<
        "query",
        "internal",
        { id: string },
        {
          amount: number | null;
          cancelAtPeriodEnd: boolean;
          checkoutId: string | null;
          createdAt: string;
          currency: string | null;
          currentPeriodEnd: string | null;
          currentPeriodStart: string;
          customerCancellationComment?: string | null;
          customerCancellationReason?: string | null;
          customerId: string;
          endedAt: string | null;
          id: string;
          metadata: Record<string, any>;
          modifiedAt: string | null;
          priceId?: string;
          productId: string;
          recurringInterval: "month" | "year" | null;
          startedAt: string | null;
          status: string;
        } | null
      >;
      insertCustomer: FunctionReference<
        "mutation",
        "internal",
        { id: string; metadata?: Record<string, any>; userId: string },
        string
      >;
      listCustomerSubscriptions: FunctionReference<
        "query",
        "internal",
        { customerId: string },
        Array<{
          amount: number | null;
          cancelAtPeriodEnd: boolean;
          checkoutId: string | null;
          createdAt: string;
          currency: string | null;
          currentPeriodEnd: string | null;
          currentPeriodStart: string;
          customerCancellationComment?: string | null;
          customerCancellationReason?: string | null;
          customerId: string;
          endedAt: string | null;
          id: string;
          metadata: Record<string, any>;
          modifiedAt: string | null;
          priceId?: string;
          productId: string;
          recurringInterval: "month" | "year" | null;
          startedAt: string | null;
          status: string;
        }>
      >;
      listProducts: FunctionReference<
        "query",
        "internal",
        { includeArchived?: boolean },
        Array<{
          createdAt: string;
          description: string | null;
          id: string;
          isArchived: boolean;
          isRecurring: boolean;
          medias: Array<{
            checksumEtag: string | null;
            checksumSha256Base64: string | null;
            checksumSha256Hex: string | null;
            createdAt: string;
            id: string;
            isUploaded: boolean;
            lastModifiedAt: string | null;
            mimeType: string;
            name: string;
            organizationId: string;
            path: string;
            publicUrl: string;
            service?: string;
            size: number;
            sizeReadable: string;
            storageVersion: string | null;
            version: string | null;
          }>;
          metadata?: Record<string, any>;
          modifiedAt: string | null;
          name: string;
          organizationId: string;
          priceAmount?: number;
          prices: Array<{
            amountType?: string;
            createdAt: string;
            id: string;
            isArchived: boolean;
            modifiedAt: string | null;
            priceAmount?: number;
            priceCurrency?: string;
            productId: string;
            recurringInterval?: "month" | "year" | null;
            type?: string;
          }>;
          recurringInterval?: "month" | "year" | null;
        }>
      >;
      listUserSubscriptions: FunctionReference<
        "query",
        "internal",
        { userId: string },
        Array<{
          amount: number | null;
          cancelAtPeriodEnd: boolean;
          checkoutId: string | null;
          createdAt: string;
          currency: string | null;
          currentPeriodEnd: string | null;
          currentPeriodStart: string;
          customerCancellationComment?: string | null;
          customerCancellationReason?: string | null;
          customerId: string;
          endedAt: string | null;
          id: string;
          metadata: Record<string, any>;
          modifiedAt: string | null;
          priceId?: string;
          product: {
            createdAt: string;
            description: string | null;
            id: string;
            isArchived: boolean;
            isRecurring: boolean;
            medias: Array<{
              checksumEtag: string | null;
              checksumSha256Base64: string | null;
              checksumSha256Hex: string | null;
              createdAt: string;
              id: string;
              isUploaded: boolean;
              lastModifiedAt: string | null;
              mimeType: string;
              name: string;
              organizationId: string;
              path: string;
              publicUrl: string;
              service?: string;
              size: number;
              sizeReadable: string;
              storageVersion: string | null;
              version: string | null;
            }>;
            metadata?: Record<string, any>;
            modifiedAt: string | null;
            name: string;
            organizationId: string;
            prices: Array<{
              amountType?: string;
              createdAt: string;
              id: string;
              isArchived: boolean;
              modifiedAt: string | null;
              priceAmount?: number;
              priceCurrency?: string;
              productId: string;
              recurringInterval?: "month" | "year" | null;
              type?: string;
            }>;
            recurringInterval?: "month" | "year" | null;
          } | null;
          productId: string;
          recurringInterval: "month" | "year" | null;
          startedAt: string | null;
          status: string;
        }>
      >;
      updateProduct: FunctionReference<
        "mutation",
        "internal",
        {
          product: {
            createdAt: string;
            description: string | null;
            id: string;
            isArchived: boolean;
            isRecurring: boolean;
            medias: Array<{
              checksumEtag: string | null;
              checksumSha256Base64: string | null;
              checksumSha256Hex: string | null;
              createdAt: string;
              id: string;
              isUploaded: boolean;
              lastModifiedAt: string | null;
              mimeType: string;
              name: string;
              organizationId: string;
              path: string;
              publicUrl: string;
              service?: string;
              size: number;
              sizeReadable: string;
              storageVersion: string | null;
              version: string | null;
            }>;
            metadata?: Record<string, any>;
            modifiedAt: string | null;
            name: string;
            organizationId: string;
            prices: Array<{
              amountType?: string;
              createdAt: string;
              id: string;
              isArchived: boolean;
              modifiedAt: string | null;
              priceAmount?: number;
              priceCurrency?: string;
              productId: string;
              recurringInterval?: "month" | "year" | null;
              type?: string;
            }>;
            recurringInterval?: "month" | "year" | null;
          };
        },
        any
      >;
      updateSubscription: FunctionReference<
        "mutation",
        "internal",
        {
          subscription: {
            amount: number | null;
            cancelAtPeriodEnd: boolean;
            checkoutId: string | null;
            createdAt: string;
            currency: string | null;
            currentPeriodEnd: string | null;
            currentPeriodStart: string;
            customerCancellationComment?: string | null;
            customerCancellationReason?: string | null;
            customerId: string;
            endedAt: string | null;
            id: string;
            metadata: Record<string, any>;
            modifiedAt: string | null;
            priceId?: string;
            productId: string;
            recurringInterval: "month" | "year" | null;
            startedAt: string | null;
            status: string;
          };
        },
        any
      >;
      upsertCustomer: FunctionReference<
        "mutation",
        "internal",
        { id: string; metadata?: Record<string, any>; userId: string },
        string
      >;
    };
  };
};



================================================
FILE: convex/_generated/api.js
================================================
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import { anyApi, componentsGeneric } from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
export const api = anyApi;
export const internal = anyApi;
export const components = componentsGeneric();



================================================
FILE: convex/_generated/dataModel.d.ts
================================================
/* eslint-disable */
/**
 * Generated data model types.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  DataModelFromSchemaDefinition,
  DocumentByName,
  TableNamesInDataModel,
  SystemTableNames,
} from "convex/server";
import type { GenericId } from "convex/values";
import schema from "../schema.js";

/**
 * The names of all of your Convex tables.
 */
export type TableNames = TableNamesInDataModel<DataModel>;

/**
 * The type of a document stored in Convex.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Doc<TableName extends TableNames> = DocumentByName<
  DataModel,
  TableName
>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Id<TableName extends TableNames | SystemTableNames> =
  GenericId<TableName>;

/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like `queryGeneric` and
 * `mutationGeneric` to make them type-safe.
 */
export type DataModel = DataModelFromSchemaDefinition<typeof schema>;



================================================
FILE: convex/_generated/server.d.ts
================================================
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  ActionBuilder,
  AnyComponents,
  HttpActionBuilder,
  MutationBuilder,
  QueryBuilder,
  GenericActionCtx,
  GenericMutationCtx,
  GenericQueryCtx,
  GenericDatabaseReader,
  GenericDatabaseWriter,
  FunctionReference,
} from "convex/server";
import type { DataModel } from "./dataModel.js";

type GenericCtx =
  | GenericActionCtx<DataModel>
  | GenericMutationCtx<DataModel>
  | GenericQueryCtx<DataModel>;

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const query: QueryBuilder<DataModel, "public">;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const internalQuery: QueryBuilder<DataModel, "internal">;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const mutation: MutationBuilder<DataModel, "public">;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const internalMutation: MutationBuilder<DataModel, "internal">;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export declare const action: ActionBuilder<DataModel, "public">;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export declare const internalAction: ActionBuilder<DataModel, "internal">;

/**
 * Define an HTTP action.
 *
 * This function will be used to respond to HTTP requests received by a Convex
 * deployment if the requests matches the path and method where this action
 * is routed. Be sure to route your action in `convex/http.js`.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Import this function from `convex/http.js` and route it to hook it up.
 */
export declare const httpAction: HttpActionBuilder;

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 */
export type QueryCtx = GenericQueryCtx<DataModel>;

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */
export type MutationCtx = GenericMutationCtx<DataModel>;

/**
 * A set of services for use within Convex action functions.
 *
 * The action context is passed as the first argument to any Convex action
 * function run on the server.
 */
export type ActionCtx = GenericActionCtx<DataModel>;

/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {@link DatabaseReader.get}, which fetches a single
 * document by its {@link Id}, or {@link DatabaseReader.query}, which starts
 * building a query.
 */
export type DatabaseReader = GenericDatabaseReader<DataModel>;

/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 */
export type DatabaseWriter = GenericDatabaseWriter<DataModel>;



================================================
FILE: convex/_generated/server.js
================================================
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  actionGeneric,
  httpActionGeneric,
  queryGeneric,
  mutationGeneric,
  internalActionGeneric,
  internalMutationGeneric,
  internalQueryGeneric,
  componentsGeneric,
} from "convex/server";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const query = queryGeneric;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const internalQuery = internalQueryGeneric;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const mutation = mutationGeneric;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const internalMutation = internalMutationGeneric;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export const action = actionGeneric;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export const internalAction = internalActionGeneric;

/**
 * Define a Convex HTTP action.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * @returns The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.
 */
export const httpAction = httpActionGeneric;



================================================
FILE: .vercel/react-router-build-result.json
================================================
{
  "buildManifest": {
    "serverBundles": {
      "nodejs_eyJydW50aW1lIjoibm9kZWpzIn0": {
        "id": "nodejs_eyJydW50aW1lIjoibm9kZWpzIn0",
        "file": "build/server/nodejs_eyJydW50aW1lIjoibm9kZWpzIn0/index.js",
        "config": {
          "runtime": "nodejs"
        }
      }
    },
    "routeIdToServerBundleId": {
      "routes/home": "nodejs_eyJydW50aW1lIjoibm9kZWpzIn0",
      "routes/sign-in": "nodejs_eyJydW50aW1lIjoibm9kZWpzIn0",
      "routes/sign-up": "nodejs_eyJydW50aW1lIjoibm9kZWpzIn0",
      "routes/pricing": "nodejs_eyJydW50aW1lIjoibm9kZWpzIn0",
      "routes/success": "nodejs_eyJydW50aW1lIjoibm9kZWpzIn0",
      "routes/subscription-required": "nodejs_eyJydW50aW1lIjoibm9kZWpzIn0",
      "routes/dashboard/index": "nodejs_eyJydW50aW1lIjoibm9kZWpzIn0",
      "routes/dashboard/chat": "nodejs_eyJydW50aW1lIjoibm9kZWpzIn0",
      "routes/dashboard/settings": "nodejs_eyJydW50aW1lIjoibm9kZWpzIn0"
    },
    "routes": {
      "root": {
        "path": "",
        "id": "root",
        "file": "app/root.tsx",
        "config": {}
      },
      "routes/home": {
        "id": "routes/home",
        "parentId": "root",
        "file": "app/routes/home.tsx",
        "index": true,
        "config": {
          "runtime": "nodejs"
        }
      },
      "routes/sign-in": {
        "id": "routes/sign-in",
        "parentId": "root",
        "file": "app/routes/sign-in.tsx",
        "path": "sign-in/*",
        "config": {
          "runtime": "nodejs"
        }
      },
      "routes/sign-up": {
        "id": "routes/sign-up",
        "parentId": "root",
        "file": "app/routes/sign-up.tsx",
        "path": "sign-up/*",
        "config": {
          "runtime": "nodejs"
        }
      },
      "routes/pricing": {
        "id": "routes/pricing",
        "parentId": "root",
        "file": "app/routes/pricing.tsx",
        "path": "pricing",
        "config": {
          "runtime": "nodejs"
        }
      },
      "routes/success": {
        "id": "routes/success",
        "parentId": "root",
        "file": "app/routes/success.tsx",
        "path": "success",
        "config": {
          "runtime": "nodejs"
        }
      },
      "routes/subscription-required": {
        "id": "routes/subscription-required",
        "parentId": "root",
        "file": "app/routes/subscription-required.tsx",
        "path": "subscription-required",
        "config": {
          "runtime": "nodejs"
        }
      },
      "routes/dashboard/layout": {
        "id": "routes/dashboard/layout",
        "parentId": "root",
        "file": "app/routes/dashboard/layout.tsx",
        "config": {}
      },
      "routes/dashboard/index": {
        "id": "routes/dashboard/index",
        "parentId": "routes/dashboard/layout",
        "file": "app/routes/dashboard/index.tsx",
        "path": "dashboard",
        "config": {
          "runtime": "nodejs"
        }
      },
      "routes/dashboard/chat": {
        "id": "routes/dashboard/chat",
        "parentId": "routes/dashboard/layout",
        "file": "app/routes/dashboard/chat.tsx",
        "path": "dashboard/chat",
        "config": {
          "runtime": "nodejs"
        }
      },
      "routes/dashboard/settings": {
        "id": "routes/dashboard/settings",
        "parentId": "routes/dashboard/layout",
        "file": "app/routes/dashboard/settings.tsx",
        "path": "dashboard/settings",
        "config": {
          "runtime": "nodejs"
        }
      }
    }
  },
  "reactRouterConfig": {
    "appDirectory": "/Users/michaelshimeles/Desktop/rsk/app",
    "basename": "/",
    "buildDirectory": "/Users/michaelshimeles/Desktop/rsk/build",
    "future": {
      "unstable_middleware": false,
      "unstable_optimizeDeps": false,
      "unstable_splitRouteModules": false,
      "unstable_subResourceIntegrity": false,
      "unstable_viteEnvironmentApi": false
    },
    "routes": {
      "root": {
        "path": "",
        "id": "root",
        "file": "root.tsx"
      },
      "routes/home": {
        "id": "routes/home",
        "parentId": "root",
        "file": "routes/home.tsx",
        "index": true
      },
      "routes/sign-in": {
        "id": "routes/sign-in",
        "parentId": "root",
        "file": "routes/sign-in.tsx",
        "path": "sign-in/*"
      },
      "routes/sign-up": {
        "id": "routes/sign-up",
        "parentId": "root",
        "file": "routes/sign-up.tsx",
        "path": "sign-up/*"
      },
      "routes/pricing": {
        "id": "routes/pricing",
        "parentId": "root",
        "file": "routes/pricing.tsx",
        "path": "pricing"
      },
      "routes/success": {
        "id": "routes/success",
        "parentId": "root",
        "file": "routes/success.tsx",
        "path": "success"
      },
      "routes/subscription-required": {
        "id": "routes/subscription-required",
        "parentId": "root",
        "file": "routes/subscription-required.tsx",
        "path": "subscription-required"
      },
      "routes/dashboard/layout": {
        "id": "routes/dashboard/layout",
        "parentId": "root",
        "file": "routes/dashboard/layout.tsx"
      },
      "routes/dashboard/index": {
        "id": "routes/dashboard/index",
        "parentId": "routes/dashboard/layout",
        "file": "routes/dashboard/index.tsx",
        "path": "dashboard"
      },
      "routes/dashboard/chat": {
        "id": "routes/dashboard/chat",
        "parentId": "routes/dashboard/layout",
        "file": "routes/dashboard/chat.tsx",
        "path": "dashboard/chat"
      },
      "routes/dashboard/settings": {
        "id": "routes/dashboard/settings",
        "parentId": "routes/dashboard/layout",
        "file": "routes/dashboard/settings.tsx",
        "path": "dashboard/settings"
      }
    },
    "routeDiscovery": {
      "mode": "lazy",
      "manifestPath": "/__manifest"
    },
    "serverBuildFile": "index.js",
    "serverModuleFormat": "esm",
    "ssr": true
  },
  "viteConfig": {
    "build": {
      "assetsDir": "assets"
    }
  }
}


